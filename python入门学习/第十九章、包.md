![](https://cdn.nlark.com/yuque/0/2023/webp/25700096/1680767668729-adb17d95-9b23-4269-b729-5810dbce56e0.webp)

<h2 id="uVGCY"><font style="color:rgb(18, 18, 18);">一、 包介绍</font></h2>
<font style="color:rgb(18, 18, 18);">随着模块数目的增多，把所有模块不加区分地放到一起也是极不合理的，于是Python为我们提供了一种把模块组织到一起的方法，即创建一个包。包就是一个含有__init__.py文件的文件夹，文件夹内可以组织子模块或子包，例如</font>

```python
pool/                #顶级包
├── __init__.py     
├── futures          #子包
│   ├── __init__.py
│   ├── process.py
│   └── thread.py
└── versions.py      #子模块
```

<font style="color:rgb(18, 18, 18);">需要强调的是</font>

```python
#1. 在python3中，即使包下没有__init__.py文件，import 包仍然不会报错，而在python2中，包下一定要有该文件，否则import 包报错

#2. 创建包的目的不是为了运行，而是被导入使用，记住，包只是模块的一种形式而已，包的本质就是一种模
```

1、包就是一个包含有__init__.py文件的文件夹

2、包的本质是模块的一种形式，包是用来当做模块导入



<h2 id="GsEIG"><font style="color:rgb(18, 18, 18);">二 、包的使用</font></h2>
<h2 id="zC0ZX"><font style="color:rgb(18, 18, 18);">2.1 导入包与__init__.py</font></h2>
<font style="color:rgb(18, 18, 18);">包属于模块的一种，因而包以及包内的模块均是用来被导入使用的，而绝非被直接执行，首次导入包（如import pool）</font><font style="color:#DF2A3F;">同样会做三件事</font><font style="color:rgb(18, 18, 18);">：</font>

<font style="color:rgb(18, 18, 18);">1、执行包下的__init__.py文件</font>

<font style="color:rgb(18, 18, 18);">2、产生一个新的名称空间用于存放__init__.py执行过程中产生的名字</font>

<font style="color:rgb(18, 18, 18);">3、在当前执行文件所在的名称空间中得到一个名字pool，该名字指向__init__.py的名称空间，</font>



**<font style="color:rgb(18, 18, 18);">强调</font>**

```python
1.关于包相关的导入语句也分为import和from ... import ...两种，但是无论哪种，无论在什么位置，在导入时都必须遵循一个原则：凡是在导入时带点的，点的左边都必须是一个包，否则非法。可以带有一连串的点，如import 顶级包.子包.子模块,但都必须遵循这个原则。但对于导入后，在使用时就没有这种限制了，点的左边可以是包,模块，函数，类(它们都可以用点的方式调用自己的属性)。

2、包A和包B下有同名模块也不会冲突，如A.a与B.a来自俩个命名空间

3、import导入文件时，产生名称空间中的名字来源于文件，import 包，产生的名称空间的名字同样来源于文件，即包下的__init__.py，导入包本质就是在导入该文件
```

<h2 id="lmmDN"><font style="color:rgb(18, 18, 18);">2.2 绝对导入与相对导入</font></h2>
<font style="color:rgb(18, 18, 18);">针对包内的模块之间互相导入，导入的方式有两种</font>

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1700657673014-dc302594-a867-4773-83fa-384e1de5bbc6.png)

<font style="color:rgb(18, 18, 18);">1、绝对导入：以顶级包为起始</font>

```python
#0） 创建foo包
# 1、准备工作
# 1）foo/m1.py
def f1():
    print('功能1...')

# 2）foo/m2.py
def f2():
    print('功能2...')

# 3）foo/m3.py
def f3():
    print('功能3...')

# 4）foo/__init__.py
# 将子模块导入到init.py中
# 绝对导入，以包的文件夹作为起始来进行导入。说白了先找foo--->再找m1--->最后找f1
from foo.m1 import f1
from foo.m2 import f2
from foo.m3 import f3

from foo.bbb.m4 import f4  # foo内有了一个f4

# import foo.bbb.m4.f4  # 语法错误，点的左侧必须是一个包。


# 示例1
# 05包使用.py
"""环境变量以执行文件为准备的，所有的被导入的模块或者说后续的其他文件引用的
sys.path都是按照执行文件的sys.path"""
import sys
sys.path.append(r'D:\py1\python\python-project\day16\aaa')  # 把foo的包添加到aaa文件夹，然后把aaa文件夹加到sys.path中
print(sys.path)

"""第一种方法：导入foo包"""
import foo
foo.f1()   # 这里这样写的原因，是设计者已经把自己的foo下的功能导入到__init__.py文件中了，所以可以直接可以调用。
foo.f2()
foo.f3() #通俗来讲：问什么模块要什么名字

# 输出结果：
功能1...
功能2...
功能3...




# 示例2
# foo/bbb/m4.py
def f4():
    print('功能f4....')

# foo/__init__.py
# 将子模块导入到init.py中
# 绝对导入，以包的文件夹作为起始来进行导入。
from foo.m1 import f1
from foo.m2 import f2
from foo.m3 import f3

from foo.bbb.m4 import f4  # foo内有了一个f4

# 05包使用.py
import sys
sys.path.append(r'D:\py1\python\python-project\day16\aaa')  # 把foo的包添加到aaa文件夹，然后把aaa文件夹加到sys.path中
print(sys.path)
# 使用from import 导入 我们使用者只需要知道foo包下有f1 f2 f3 名字即可，
"""第二种方法："""
from foo import f1,f2,f3,f4
f1()
f2()
f3()
f4()

# 输出结果：
功能1...
功能2...
功能3...
功能f4....


```

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1680769518748-072c02ab-f576-4ad8-ae25-6998a307dd5e.png)



<font style="color:rgb(18, 18, 18);">2、相对导入：.代表当前文件所在的目录，..代表当前目录的上一级目录，依此类推</font>

```python
# foo/__init__.py路径

# 2、相对导入:仅限于包内使用，不能跨出包。（包内模块之间的导入，推荐使用相对导入）
# .: 代表当前文件夹
# ..: 代表上一层文件夹


from .m1 import f1
from .m2 import f2
from .m3 import f3
from .bbb.m4 import f4

# 强调：
# 1、相对导入不能跨出包，所以相对导入仅限于包内模板彼此之间闹着玩。
# 2、绝对导入没有任何限制的，所以绝对导入是一种通用的导入方式。

# 使用者.py
import foo
foo.f1()
foo.f2()
foo.f3()
foo.f4()

```

示例:      m4.py

```python
# 绝对路径
# from foo.m1 import f1
# 相对路径
from ..m1 import f1 # 这快是设计者考虑的

def f4():
    print('功能f4....')
    f1()
```



```python
import sys
sys.path.append(r'D:\py1\python\python-project\day16\aaa')  # 把foo的包添加到aaa文件夹，然后把aaa文件夹加到sys.path中

# 使用者不管三七二十一 我只需要知道foo下有f4即可
import foo

foo.f4()


# 输出结果：

功能f4....
功能1...
```

<font style="color:rgb(18, 18, 18);">针对包内部模块之间的相互导入推荐使用相对导入，需要特别强调：</font>

<font style="color:rgb(18, 18, 18);">1、相对导入只能在包内部使用，用相对导入不同目录下的模块是非法的</font>

<font style="color:rgb(18, 18, 18);">2、无论是import还是from-import，但凡是在导入时带点的，点的左边必须是包,否则语法错误</font>

<font style="color:rgb(18, 18, 18);"></font>

<font style="color:rgb(18, 18, 18);">总结包的使用需要牢记三点</font>  
<font style="color:rgb(18, 18, 18);">1、导包就是在导包下__init__.py文件</font>  
<font style="color:rgb(18, 18, 18);">2、包内部的导入应该使用相对导入，相对导入也只能在包内部使用，而且...取上一级不能出包</font>  
<font style="color:rgb(18, 18, 18);">3、</font>  
<font style="color:rgb(18, 18, 18);">使用语句中的点代表的是访问属性</font>  
<font style="color:rgb(18, 18, 18);">m.n.x ----> 向m要n，向n要x</font>  
<font style="color:rgb(18, 18, 18);">而导入语句中的点代表的是路径分隔符</font>  
<font style="color:rgb(18, 18, 18);">import a.b.c --> a/b/c，文件夹下a下有子文件夹b，文件夹b下有子文件或文件夹c</font>  
<font style="color:rgb(18, 18, 18);">所以导入语句中点的左边必须是一个包</font>

<h2 id="dk0rX"></h2>
参考链接：[https://zhuanlan.zhihu.com/p/109221768](https://zhuanlan.zhihu.com/p/109221768)

