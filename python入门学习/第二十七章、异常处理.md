<h2 id="dvgtx"><font style="color:rgb(25, 27, 31);">一 什么是异常</font></h2>
<font style="color:rgb(25, 27, 31);">异常是程序发生错误的信号。程序一旦出现错误，便会产生一个异常，若程序中没有处理它，就会抛出该异常，程序的运行也随之终止。在Python中,错误触发的异常如下</font>

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1702609246155-97f83717-c7d6-4e3a-add8-adb2f7f8725b.png)

<font style="color:rgb(25, 27, 31);">而错误分成两种，</font><font style="color:#DF2A3F;">一种是语法上的错误SyntaxError</font><font style="color:rgb(25, 27, 31);">，这种错误应该在程序运行前就修改正确</font>

```python
>>> if  
  File "<stdin>", line 1
    if
     ^
SyntaxError: invalid syntax
```

<font style="color:rgb(25, 27, 31);">在了解了异常处理机制后，本着提高程序容错性和可靠性的目的，读者可能会错误地认为应该尽可能多地为程序加上try...except...，这其是在过度消费程序的可读性，因为try...except本来就是你附加给程序的一种额外的逻辑，与你的主要工作是没有多大关系的。</font>

<font style="color:rgb(25, 27, 31);">如果错误发生的条件是“可预知的”，我们应该用</font><font style="color:rgb(25, 27, 31);background-color:#FBDE28;">if来进行”预防”</font><font style="color:rgb(25, 27, 31);">，如下</font>

```python
age=input('input your age>>: ').strip()
if age.isdigit(): # 可预知只有满足字符串age是数字的条件，int(age)才不会触发异常，
    age=int(age)
else:
    print('You must enter the number')
```

<font style="color:#DF2A3F;">另一类就是逻辑错误</font><font style="color:rgb(25, 27, 31);">，常见的逻辑错误如</font>

<font style="color:rgb(25, 27, 31);">如果错误发生的条件“不可预知”，即异常一定会触发，那么我们才应该使用try...except语句来处理。例如我们编写一个下载网页内容的功能，网络发生延迟之类的异常是很正常的事，而我们根本无法预知在满足什么条件的情况下才会出现延迟，因而只能用异常处理机制了</font>

```python
# TypeError：数字类型无法与字符串类型相加
1+’2’

# ValueError：当字符串包含有非数字的值时，无法转成int类型
num=input(">>: ") #输入hello
int(num)

# NameError：引用了一个不存在的名字x
x

# IndexError：索引超出列表的限制
l=['egon','aa']
l[3]

# KeyError：引用了一个不存在的key
dic={'name':'egon'}
dic['age']

# AttributeError：引用的属性不存在
class Foo:
    pass
Foo.x

# ZeroDivisionError：除数不能为0
1/0

```

<h2 id="ZM0Sq"><font style="color:rgb(25, 27, 31);">二 异常处理</font></h2>
<font style="color:rgb(25, 27, 31);">为了保证程序的容错性与可靠性，即在遇到错误时有相应的处理机制不会任由程序崩溃掉，我们需要对异常进行处理，处理的基本形式为</font>

```python
try:
    被检测的代码块
except 异常类型：
    检测到异常，就执行这个位置的逻辑
```

<font style="color:rgb(25, 27, 31);">举例</font>

```python
try:
    print('start...')
    print(x) # 引用了一个不存在的名字，触发异常NameError
    print('end...')
except NameError as e: # as语法将异常类型的值赋值给变量e，这样我们通过打印e便可以知道错误的原因
    print('异常值为：%s' %e)
print('run other code...')

#执行结果为
start...
异常值为：name 'x' is not defined
run other code...
```

<font style="color:rgb(25, 27, 31);">本来程序一旦出现异常就整体结束掉了，有了异常处理以后，在被检测的代码块出现异常时，被检测的代码块中异常发生位置之后的代码将不会执行，取而代之的是执行匹配异常的except子代码块，其余代码均正常运行。</font>

<font style="color:rgb(25, 27, 31);">当被检测的代码块中有可能触发不同类型的异常时，针对不同类型的异常：</font>

<font style="color:#DF2A3F;">如果我们想分别用不同的逻辑处理，需要用到多分支的except（类似于多分支的elif，从上到下依次匹配，匹配成功一次便不再匹配其他）</font>

```python
try:
    被检测的代码块
except NameError:
    触发NameError时对应的处理逻辑
except IndexError:
    触发IndexError时对应的处理逻辑
except KeyError:
    触发KeyError时对应的处理逻辑
```



<font style="color:rgb(25, 27, 31);">举例</font>

```python
print('start。。。。。')
try:

    print(x)

    l=[111,222]
    l[2]


    dic={'name': 'egon'}
    dic['age']

    class Foo:
        pass

    Foo.x

except NameError as e:
    print('异常值为： %s' %e)
except IndexError as e:
    print('异常值为： %s' %e)
except KeyError as e:
    print('异常值为： %s' %e)
except AttributeError as e:
    print('异常值为：%s'  %e)


print('end。。。。。')



# 输出
# start。。。。。
# 异常值为： name 'x' is not defined
# end。。。。。
```

<font style="color:rgb(25, 27, 31);">如果我们想多种类型的异常统一用一种逻辑处理，可以将多个异常放到一个元组内，用一个except匹配</font>

```python
try:
    被检测的代码块
except (NameError,IndexError,TypeError):
    触发NameError或IndexError或TypeError时对应的处理逻辑
```

<font style="color:rgb(25, 27, 31);">举例</font>

```python
print('start。。。。。')
try:

    print(x)

    l=[111,222]
    l[2]


    dic={'name': 'egon'}
    dic['age']

    class Foo:
        pass

    Foo.x



except (NameError,IndexError,KeyError) as e:
    print('异常值： %s' %e)


# 输出：
# start。。。。。
# 异常值： name 'x' is not defined
# end。。。。。
```

<font style="color:rgb(25, 27, 31);">如果我们想捕获所有异常并用一种逻辑处理，Python提供了一个</font><font style="color:#DF2A3F;">万能异常类型Exception</font>

```python
try:
    被检测的代码块
except NameError:
    触发NameError时对应的处理逻辑
except IndexError:
    触发IndexError时对应的处理逻辑
except Exception:
    其他类型的异常统一用此处的逻辑处理

```

举例：

```python
print('start。。。。。')
try:

    print(x)

    l=[111,222]
    l[2]


    dic={'name': 'egon'}
    dic['age']

    class Foo:
        pass

    Foo.x

 

except Exception as e:
    print('异常值： %s' %e)

else:
    print('不管代码是否异常，都会执行此finally块代码')

print('end。。。。。')

# 输出

# start。。。。。
# 异常值： name 'x' is not defined
# 不管代码是否异常，都会执行此finally块代码
# end。。。。。
```

<font style="color:rgb(25, 27, 31);">在多分支except之后还可以跟一个else（else必须跟在except之后，不能单独存在），</font><font style="color:rgb(25, 27, 31);background-color:#FBDE28;">只有在被检测的代码块没有触发任何异常的情况下才会执行else的子代码块</font>

```python
try:
    被检测的代码块
except 异常类型1:
    pass
except 异常类型2:
    pass
......
else:
    没有异常发生时执行的代码块
```

<font style="color:rgb(25, 27, 31);">举例：</font>

```python
print('start。。。。。')
try:
    x=10
    print(x)

    l=[111,222]
    l[1]


    dic={'name': 'egon'}
    dic['name']

    class Foo:
        x=0

    Foo.x



except Exception as e:
    print('异常值为： %s' %e)

else:
    print('如果没有异常，就执行到我这里')

print('end。。。。。')

# 输出
# start。。。。。
# 10
# 如果没有异常，就执行到我这里
# end。。。。。

```

<font style="color:rgb(25, 27, 31);">此外try还可以与finally连用，从语法上讲finally必须放到else之后，但可以使用try-except-finally的形式，也可以直接使用try-finally的形式。</font><font style="color:rgb(25, 27, 31);background-color:#FBDE28;">无论被检测的代码块是否触发异常，都会执行finally的子代码块</font><font style="color:rgb(25, 27, 31);">，因此通常在finally的子代码块做一些回收资源的操作，比如关闭打开的文件、关闭数据库连接等</font>

<font style="color:rgb(25, 27, 31);background-color:rgb(248, 248, 250);">python try: 被检测的代码块 except 异常类型1: pass except 异常类型2: pass ...... else: 没有异常发生时执行的代码块 finally: 无论有无异常发生都会执行的代码块</font>

<font style="color:rgb(25, 27, 31);">举例</font>

```python
print('start。。。。。')
try:

    print(x)

    l=[111,222]
    l[2]


    dic={'name': 'egon'}
    dic['age']

    class Foo:
        pass

    Foo.x

 

except Exception as e:
    print('异常值： %s' %e)

finally:
    print('不管代码是否异常，都会执行此finally块代码')

print('end。。。。。')

# 输出

# start。。。。。
# 异常值： name 'x' is not defined
# 不管代码是否异常，都会执行此finally块代码
# end。。。。。
```

<font style="color:rgb(25, 27, 31);">在不符合Python解释器的语法或逻辑规则时，是由Python解释器主动触发的各种类型的异常，而对于违反程序员自定制的各类规则，则需要由程序员自己来明确地触发异常，这就用到了</font><font style="color:#DF2A3F;">raise语句，raise后必须是一个异常的类或者是异常的实例</font>

```python
class Student:
    def __init__(self,name,age):
        if not isinstance(name,str):
            raise TypeError('name must be str')
        if not isinstance(age,int):
            raise TypeError('age must be int')

        self.name=name
        self.age=age

stu1=Student(4573,18) # TypeError: name must be str
stu2=Student('egon','18') # TypeError: age must be int
```





参考文章：[https://zhuanlan.zhihu.com/p/109340070](https://zhuanlan.zhihu.com/p/109340070)

[https://www.cnblogs.com/linhaifeng/p/6045600.html](https://www.cnblogs.com/linhaifeng/p/6045600.html) 

