<h1 id="oYgSh"><font style="color:rgb(255, 255, 255);background-color:rgb(43, 102, 149);">一 time与datetime模块</font></h1>
<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">在Python中，通常有这几种方式来表示时间：</font>

+ <font style="color:#DF2A3F;background-color:rgb(244, 237, 227);">时间戳(timestamp)</font><font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">：通常来说，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量。我们运行“type(time.time())”，返回的是float类型。</font>
+ <font style="color:#DF2A3F;background-color:rgb(244, 237, 227);">格式化的时间字符串(Format String)</font>
+ <font style="color:#DF2A3F;background-color:rgb(244, 237, 227);">结构化的时间(struct_time)</font><font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">：struct_time元组共有9个元素共九个元素:(年，月，日，时，分，秒，一年中第几周，一年中第几天，夏令时)</font>

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1681117966920-3e70ec97-a321-4a59-b218-62e9c6b400ef.png)

```python

# 有限掌握的操作
# 一、time
# 时间分为三种格式：
# 1、时间戳: 从1970年到现在经过的秒数
#    作用: 用于时间间隔的计算
import time
print(time.time())

# 2、格式化的字符串形式
# 按照某种格式显示的时间： 2023-04-07 11:11:11
# 作用: 用于展示时间
print(time.strftime('%Y-%m-%d %H:%M:%S'))
print(time.strftime('%Y-%m-%d %H:%M:%S %p'))
print(time.strftime('%Y-%m-%d %X'))

'''
结果：
2023-11-23 13:53:54
2023-11-23 13:53:54 PM
2023-11-23 13:53:54
'''

# 3、结构化的时间
# 作用: 用于单独获取时间的某一部分
res=time.localtime()
print(res)
print(res.tm_year)
print(res.tm_yday)

# 输出
time.struct_time(tm_year=2023, tm_mon=11, tm_mday=23, tm_hour=13, tm_min=53, tm_sec=3, tm_wday=3, tm_yday=327, tm_isdst=0)
2023
327


# 二、datetime
#
import datetime
print(datetime.datetime.noew())
print(datetime.datetime.now() + datetime.timedelta(days=3))
print(datetime.datetime.now() + datetime.timedelta(days=-3))
print(datetime.datetime.now() + datetime.timedelta(weeks=1))
print(datetime.datetime.now() + datetime.timedelta(days=365*3))


'''
#输出：
2023-11-23 11:47:38.410913
2023-11-26 11:47:38.410930
2023-11-20 11:47:38.410935
2023-11-30 11:47:38.410939
2026-11-22 11:47:38.410943
'''
################ 时间模块需要掌握的操作##############

# 1、时间格式的转换
# 结构化时间   ===》 时间戳格式
import time
s_time=time.localtime()
print(time.mktime(s_time))

# 时间戳 ====》 结构化时间
tp_time=time.time()
print(time.localtime(tp_time))


# 世界标准时间与本地时间
print(time.localtime())
print(time.gmtime())  # 世界标准时间


# 结构化时间  ====》 格式化的字符串形式的时间
s_time=time.localtime()
print(time.strftime('%Y-%m-%d %H:%M:%S',s_time))

# 格式化的字符串形式的时间  ====》 结构化时间
res=time.strptime('1988-03-03 11:11:11','%Y-%m-%d %H:%M:%S')
print(res)

################# !!!真正需要掌握的只有一条： format string  <---------> timestamp
# '1988-03-03 11:11:11' +7

# format string ---> struct_time ----> timestamp
struct_time=time.strptime('1988-03-03 11:11:11','%Y-%m-%d %H:%M:%S')
timestamp=time.mktime(struct_time)+7*86400
print(timestamp)


#  timestamp  ----> struct_time  ---->  format string
res=time.strftime('%Y-%m-%d %H:%M:%S',time.localtime(timestamp))
print(res)

# 了解知识
import time
print(time.asctime())  # Fri Apr  7 17:30:48 2023
time.sleep(0.3)

import datetime
print(datetime.datetime.utcnow())  # 2023-04-07 09:31:49.128898
print(datetime.datetime.fromtimestamp(33333))  # 1970-01-01 17:15:33

```


<h1 id="IqfTU"><font style="color:rgb(255, 255, 255);background-color:rgb(43, 102, 149);">二 random模块</font></h1>

```python
import random
print(random.random())                     # (0,1)----float 大于0且小于1之间的小数
print(random.randint(1,3))                 # [1,3] 大于等于1且小于等于3之间的整数
print(random.randrange(1,3))               # [1,3) 大于等于1且小于3之间的整数
print(random.choice([111,'aaa',[4,5]]))    # 1或者aaa或者[4,5]
print(random.sample([111,'aaa',[4,5]],2))  # 列表元素任意2个组合
print(random.uniform(1,3))                 # 大于1小于3的小数，如1.927109612082716

item=[1,3,5,7,9]
random.shuffle(item) #打乱item的顺序,相当于"洗牌"
print(item)

# 应用： 随机验证码
# x12abc
#
# 伪代码
import random
res=''
for i in range(6):
    从26个大写字母中随机取出一个=chr(random.randint(65,90))
    从10个数字随机取出一个=str(random.randint(0,9))

    随机字符=random.choice([从26个大写字母中随机取出一个，从10个数字随机取出一个])
    res+=随机字符

"""
储备知识：chr内置函数
输入数字 65-91，返回值是大写字母
chr(65,91)
输入数字 97-122，返回值是小写字母
chr(97,122)
ord函数知识储备
ord( {需要转换的字符} )，返回值是对应的Unicode编码
ord('A')
65
C:\Users\13747>python
Python 3.6.8 (tags/v3.6.8:3c6b436a57, Dec 23 2018, 23:31:17) [MSC v.1916 32 bit (Intel)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> chr(65)
'A'
>>> chr(90)
'Z'
>>> chr(95)
'_'
>>> chr(96)
'`'
>>> chr(97)
'a'
>>> chr(122)
'z'
>>> ord('A')
65
"""

# 示例1:
import random
res=''
for i in range(6):
    s1=chr(random.randint(65,90))
    s2=str(random.randint(0,9))

    l=random.choice([s1,s2])
    res+=l
print(res)


# 示例2: 写成一个功能
import random
def make_code(size=4):
    res=''
    for i in range(size):
        s1=chr(random.randint(65,90))
        s2=str(random.randint(0,9))
        l=random.choice([s1,s2])
        res+=l
    return res

res=make_code(6)
print(res)
```

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1681118103475-b34d2c47-107d-43da-bf49-ed1bbc40e537.png)

<h1 id="HcBOq"><font style="color:rgb(255, 255, 255);background-color:rgb(43, 102, 149);">三 os模块</font></h1>
<font style="color:#DF2A3F;background-color:rgb(244, 237, 227);">os模块是与操作系统交互的一个接口</font>

```python
# 需要掌握的
os.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径
os.chdir("dirname")  改变当前脚本工作目录；相当于shell下cd
os.curdir  返回当前目录: ('.')
os.pardir  获取当前目录的父目录字符串名：('..')
os.makedirs('dirname1/dirname2')    可生成多层递归目录
os.removedirs('dirname1')    若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推
os.mkdir('dirname')    生成单级目录；相当于shell中mkdir dirname
os.rmdir('dirname')    删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname
os.listdir('dirname')    列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印
os.remove()  删除一个文件
os.rename("oldname","newname")  重命名文件/目录
os.stat('path/filename')  获取文件/目录信息
os.system("bash command")  运行shell命令，直接显示
os.environ  获取系统环境变量

# 重点掌握
os.path.abspath(path)  返回path规范化的绝对路径
os.path.split(path)  将path分割成目录和文件名二元组返回
os.path.dirname(path)  返回path的目录。其实就是os.path.split(path)的第一个元素
os.path.basename(path)  返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素
os.path.exists(path)  如果path存在，返回True；如果path不存在，返回False
os.path.isabs(path)  如果path是绝对路径，返回True
os.path.isfile(path)  如果path是一个存在的文件，返回True。否则返回False
os.path.isdir(path)  如果path是一个存在的目录，则返回True。否则返回False
os.path.join(path1[, path2[, ...]])  将多个路径组合后返回，第一个绝对路径之前的参数将被忽略
os.path.getatime(path)  返回path所指向的文件或者目录的最后存取时间
os.path.getmtime(path)  返回path所指向的文件或者目录的最后修改时间
os.path.getsize(path) 返回path的大小

# 了解即可
os.sep    输出操作系统特定的路径分隔符，win下为"\\",Linux下为"/"
os.linesep    输出当前平台使用的行终止符，win下为"\r\n",Linux下为"\n"
os.pathsep    输出用于分割文件路径的字符串 win下为;,Linux下为:
os.name    输出字符串指示当前使用平台。win->'nt'; Linux->'posix'

```

```python

在Linux和Mac平台上，该函数会原样返回path，在windows平台上会将路径中所有字符转换为小写，并将所有斜杠转换为饭斜杠。
>>> os.path.normcase('c:/windows\\system32\\')   
'c:\\windows\\system32\\'   
   

规范化路径，如..和/
>>> os.path.normpath('c://windows\\System32\\../Temp/')   
'c:\\windows\\Temp'   

>>> a='/Users/jieli/test1/\\\a1/\\\\aa.py/../..'
>>> print(os.path.normpath(a))
/Users/jieli/test1

```



```python

# 获取某一个文件夹下的所有子文件以及子文件夹的名字
import os
res=os.listdir(r'D:\py1\python\python-project\day17')
res1=os.listdir('.')
print(res)
print(res1)


# 统计问价大小
import os
size=os.path.getsize(r'D:\py1\python\python-project\day17')
print(size)

# 应用程序---》 'ls /'
import os
os.system(r"dir C:\Users\\13747")
os.system('ls /')

# 规定：key与value都为字符串
import os
os.environ['aaaaaaaaa']='1111111111111'
print(os.environ)


import os
print(os.path.dirname(r'D:\\a\\b\\c\\d.txt'))
print(os.path.basename(r'D:\\a\\b\\c\\d.txt'))
# 输出结果：
D:\\a\\b\\c
d.txt

import os
print(os.path.isfile(r'01 时间模块.py'))
print(os.path.isfile(r'aaa'))
print(os.path.isdir(r'aaa'))

import os
print(os.path.join('a','b','c','d'))  # windows下：a\b\c\d
print(os.path.join('a','b','/','c','d'))  # windows下：/c\d


# 了解
import os
print(os.path.split(r'D:\\a\\b\\c\\d.txt'))
# 输出结果
('D:\\\\a\\\\b\\\\c', 'd.txt')

import os
print(os.path.isabs(r'D:\\a\\b\\c\\d.txt'))
# 输出结果： True

import os
print(__file__)
print(os.path.abspath(__file__))
# 输出结果：
D:/py1/python/python-project/day17/03 os模块.py
D:\py1\python\python-project\day17\03 os模块.py



# 推荐使用
import os
BASE_DIR=os.path.dirname(os.path.dirname(__file__))
print(BASE_DIR)  # D:\py1\python\python-project

# 不推荐使用
import os
BASE_DIR=os.path.normpath(os.path.join(
    __file__,
    '..',
    '..',
))
print(BASE_DIR)  # D:\py1\python\python-project


# python3.5之后退出了一个新的模块Pathlib（推荐使用）
from pathlib import Path

root = Path(__file__)
res = root.parent.parent
print(res)  # D:\py1\python\python-project

from pathlib import Path
res=Path(r'D:\\a\\b\\c') / 'd\\e.txt'
print(res)
print(res.resolve())


from pathlib import Path
res=Path('a/b/c') / 'd/e.txt'
print(res)
print(res.resolve())

```



<h1 id="O6rXq"><font style="color:rgb(255, 255, 255);background-color:rgb(43, 102, 149);">四 sys模块</font></h1>

```python
1 sys.argv           命令行参数List，第一个元素是程序本身路径
2 sys.exit(n)        退出程序，正常退出时exit(0)
3 sys.version        获取Python解释程序的版本信息
4 sys.maxint         最大的Int值
5 sys.path           返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值
6 sys.platform       返回操作系统平台名称

```

```python

import  sys
python run.py 1 2 3 4 5
# sys.argv 获取的是解释器后参数值
print(sys.argv)

# cmd调用脚本：
C:\Users\13747>python D:\py1\python\python-project\day17\run.py 1 2 3 4 5
['D:\\py1\\python\\python-project\\day17\\run.py', '1', '2', '3', '4', '5']


# 之前的copy工具

scr_file=input('源文件路径: ').strip()
dst_file=input('目标文件路径： ').strip()
with open(r'%s' %src_file,mode='rb') as read_f,\
    open(r'%s' %dst_file,mode='rb') as write_f:
    for line in read_f:
        write_f.write(line)
        
# 在cmd终端调用脚本：
C:\Users\13747>python D:\py1\python\python-project\day17\run.py
目标文件路径：

# 现在更进一步的文件copy工具
import sys
src_file=sys.argv[1]
dst_file=sys.argv[2]

dst_file=input('目标文件路径： ').strip()
with open(r'%s' %src_file,mode='rb') as read_f,\
    open(r'%s' %dst_file,mode='rb') as write_f:
    for line in read_f:
        write_f.write(line)
        
# 在cmd终端调用脚本：
# C:\Users\13747>python D:\py1\python\python-project\day17\run.py src_file dst_file
# 目标文件路径：

```

```python

# 知识储备
import time
res=''
for i in range(50):
    res+='#'
    # \r:代表每次跳到行首打印 %-50s:-代表是左侧 50是宽度 %s占位符
    time.sleep(0.5)
    print('\r[%-50s]' %res, end='')


# 打印进度条的案例1:
import time
recv_size=0
total_size=1025
while recv_size < total_size:
    time.sleep(0.01)  # 下载了1024个字节
    recv_size+=1024

    # 打印进度条
    percent=recv_size / total_size
    if percent > 1:
        percent = 1

    res=int(percent * 50) * '#'
    # 字符串中百分号为%%
    print('\r[%-50s] %d%%' %(res, int(percent*100)), end='')


# 把打印进度条写一个功能

import time
def process(percent):
    if percent > 1:
        percent = 1
    res=int(percent * 50) * '#'
    # 字符串中百分号为%%
    print('\r[%-50s] %d%%' %(res, int(percent*100)), end='')

recv_size=0
total_size=10250111
while recv_size < total_size:
    time.sleep(0.01)  # 下载了1024个字节
    recv_size+=1024
    # 打印进度条
    percent=recv_size / total_size

    process(percent)

```



<h1 id="jmRTI"><font style="color:rgb(255, 255, 255);background-color:rgb(43, 102, 149);">五 shutil模块（了解）</font></h1>
<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">高级的 文件、文件夹、压缩包 处理模块</font>

**<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">shutil.copyfileobj(fsrc, fdst[, length])</font>**<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">  
</font><font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">将文件内容拷贝到另一个文件中</font>

```python

1 import shutil
2  
3 shutil.copyfileobj(open('old.xml','r'), open('new.xml', 'w'))

```

**<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">shutil.copyfile(src, dst)</font>**  
<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">拷贝文件</font>

```python

1 shutil.copyfile('f1.log', 'f2.log') #目标文件无需存在

```

**<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">shutil.copyfile(src, dst)</font>**  
<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">拷贝文件</font>

```python

1 shutil.copyfile('f1.log', 'f2.log') #目标文件无需存在

```

**<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">shutil.copymode(src, dst)</font>**  
<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">仅拷贝权限。内容、组、用户均不变</font>

```python

1 shutil.copymode('f1.log', 'f2.log') #目标文件必须存在

```

**<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">shutil.copystat(src, dst)</font>**  
<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">仅拷贝状态的信息，包括：mode bits, atime, mtime, flags</font>

```python

1 shutil.copystat('f1.log', 'f2.log') #目标文件必须存在

```

**<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">shutil.copy(src, dst)</font>**  
<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">拷贝文件和权限</font>

```python

1 import shutil
2  
3 shutil.copy('f1.log', 'f2.log')

```



**<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">shutil.copy2(src, dst)</font>**  
<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">拷贝文件和状态信息</font>

```python

1 import shutil
2  
3 shutil.copy2('f1.log', 'f2.log')

```

**<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">shutil.ignore_patterns(*patterns)</font>**  
**<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">shutil.copytree(src, dst, symlinks=False, ignore=None)</font>**  
<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">递归的去拷贝文件夹</font>

```python

import shutil
2  
3 shutil.copytree('folder1', 'folder2', ignore=shutil.ignore_patterns('*.pyc', 'tmp*')) #目标目录不能存在，注意对folder2目录父级目录要有可写权限，ignore的意思是排除

```

```python

import shutil

shutil.copytree('f1', 'f2', symlinks=True, ignore=shutil.ignore_patterns('*.pyc', 'tmp*'))

'''
通常的拷贝都把软连接拷贝成硬链接，即对待软连接来说，创建新的文件
'''

```

**<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">shutil.rmtree(path[, ignore_errors[, onerror]])</font>**  
<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">递归的去删除文件</font>

```python

1 import shutil
2  
3 shutil.rmtree('folder1')

```

**<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">shutil.move(src, dst)</font>**  
<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">递归的去移动文件，它类似mv命令，其实就是重命名。</font>

```python

1 import shutil
2  
3 shutil.move('folder1', 'folder3')

```

**<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">shutil.make_archive(base_name, format,...)</font>**

<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">创建压缩包并返回文件路径，例如：zip、tar</font>

<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">创建压缩包并返回文件路径，例如：zip、tar</font>

+ <font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">base_name： 压缩包的文件名，也可以是压缩包的路径。只是文件名时，则保存至当前目录，否则保存至指定路径，  
</font><font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">如 data_bak                       =>保存至当前路径  
</font><font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">如：/tmp/data_bak =>保存至/tmp/</font>
+ <font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">format： 压缩包种类，“zip”, “tar”, “bztar”，“gztar”</font>
+ <font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">root_dir： 要压缩的文件夹路径（默认当前目录）</font>
+ <font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">owner： 用户，默认当前用户</font>
+ <font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">group： 组，默认当前组</font>
+ <font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">logger： 用于记录日志，通常是logging.Logger对象</font>

```python

#将 /data 下的文件打包放置当前程序目录
2 import shutil
3 ret = shutil.make_archive("data_bak", 'gztar', root_dir='/data')
4   
5   
6 #将 /data下的文件打包放置 /tmp/目录
7 import shutil
8 ret = shutil.make_archive("/tmp/data_bak", 'gztar', root_dir='/data')

```

<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">shutil 对压缩包的处理是调用 ZipFile 和 TarFile 两个模块来进行的，详细：</font>

<font style="color:rgb(0, 0, 0);">zipfile压缩解压缩</font>

```python

import zipfile

# 压缩
z = zipfile.ZipFile('laxi.zip', 'w')
z.write('a.log')
z.write('data.data')
z.close()

# 解压
z = zipfile.ZipFile('laxi.zip', 'r')
z.extractall(path='.')
z.close()

```

<font style="color:rgb(0, 0, 0);">tarfile压缩解压缩</font>

```python

import tarfile

# 压缩
>>> t=tarfile.open('/tmp/egon.tar','w')
>>> t.add('/test1/a.py',arcname='a.bak')
>>> t.add('/test1/b.py',arcname='b.bak')
>>> t.close()


# 解压
>>> t=tarfile.open('/tmp/egon.tar','r')
>>> t.extractall('/egon')
>>> t.close()

```

<h1 id="FfAbS"><font style="color:rgb(255, 255, 255);background-color:rgb(43, 102, 149);">六 json&pickle模块</font></h1>
<font style="color:rgb(37, 41, 51);">json模块和pickle模块是用来序列化和反序列化数据的模块。</font>

<font style="color:rgb(37, 41, 51);">序列化指的是把内存的数据类型转换成一种特定的格式的内容，</font>

<font style="color:rgb(37, 41, 51);">该格式的内容可用于存储或者传输给其他平台(其他编程语言)使用，</font>

<font style="color:rgb(37, 41, 51);">反序列化就是将其他平台上的数据转换成python能够识别的数据格式。</font>

```python

# 土方法：
{'aaa':111} --->序列化str({'aaa':111})---->"{'aaa':111}"
{'aaa':111} --->反序列化eval("{'aaa':111}")---->"{'aaa':111}"

```

```bash

# 序列化：

'''内存中的数据类型----》序列化----》特定的格式（json/pickle格式）'''

# 反序列化：
''' 内存中的数据类型《----反序列化《----特定的格式（json/pickle格式）'''

```

数据进行序列化有两种用途：

其一，可以持久保存程序运行过程中产生的数据，将数据写到磁盘中。

其二，序列化之后，不仅可以把序列化后的内容写入磁盘，还可以通过网络传输到别的机器上，如果收发的双方约定好使用一种序列化的格式，那么便打破了平台/语言差异化带来的限制，实现了跨平台数据交互。

序列化和反序列化的操作可以借助json和pickle模块。



```python

# 序列化得到结果----》特定格式的内容有两种用途
# 1）、该格式的内容可用于存储
# 2）、传输给其他平台使用

# 强调：
#      针对用途1的特定格式：可以是一种专用的格式===》pickle格式（只有python可以识别）
#      针对用途2的特定格式：应该是一种通用，能够被所有语言识别的格式===》json格式

```

<h2 id="eoRzx"><font style="color:rgb(37, 41, 51);">1、json模块</font></h2>
json格式的数据是所有编程语言通用的数据类型，如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，<font style="color:#DF2A3F;">但更好的方法是序列化为json格式</font>，<font style="color:#DF2A3F;">因为json格式表示出来就是一个字符串</font>，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。但是json不能用于某种语言独有数据类型的序列化或者反序列化操作，比如python的集合类型。

<font style="color:#DF2A3F;">还需要注意json格式的字符串与Python语法之间的区别，不要混淆了哟，比如json格式字符串是不支持单引号的，但是字典支持单引号哦~</font>

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1681119323510-d09b2e76-7f00-4aaa-bf22-5a7541805fdd.png)

```python

# 如何序列化与反序列化
# 示范1：
# 序列化
import json
json_res=json.dumps([1,'aaa',True,False])
print(json_res,type(json_res))  # [1, "aaa", true, false] <class 'str'>

# # 反序列化
l=json.loads(json_res)
print(l)

# 示范2：
####################### 序列化##############################
import json
# 将序列化的结果写入文件的复杂方法
json_res=json.dumps([1,'aaa',True,False])
print(json_res,type(json_res))  # [1, "aaa", true, false] <class 'str'>
with open('test.json',mode='wt',encoding='utf-8') as f:
    f.write(json_res)  # [1, "aaa", true, false]

# 将序列化的结果写入文件的简单方法
import json
with open('test.json',mode='wt',encoding='utf-8') as f:
    # 第一个参数序列化的内容，第二个参数打开的文件对象
    json.dump([1,'aaa',True,False], f)




# #######################反序列化############################
# 从文件读取json格式的字符串进行反序列化的复杂方法
import json
with open('test.json',mode='rt',encoding='utf-8') as f:
    json_res=f.read()
    l=json.loads(json_res)
    print(l,type(l))  # [1, 'aaa', True, False] <class 'list'>

# 从文件读取json格式的字符串进行反序列化的简单方法
import json
with open('test.json',mode='rt',encoding='utf-8') as f:
   l=json.load(f)
   print(l,type(l))  # [1, 'aaa', True, False] <class 'list'>

```

<h4 id="B6EXD">补充：</h4>

```python

# 4、json验证
# json格式兼容所有语言通用的数据类型，不能识别某一语言所独有的类型
json.dumps({1,2,3,4,5})


# json强调：一定要搞清楚json格式，不要与python混淆
l=json.loads('[1, "aaa", true, false]')  # loads这里放的是json对象,说白了json格式就是字符串形式里面套着一些东西。
print(l)
print(l[0])

# 输出结果：
[1, 'aaa', True, False]
1



# 了解即可
# 在3.6以后json也可以是byte类型也没问题,也可以是字符串类型。
l=json.loads(b'[1, "aaa", true, false]')  # loads这里放的是json对象,说白了json格式就是字符串形式里面套着一些东西。
print(l)
print(l[0])

# 输出结果：
[1, 'aaa', True, False]
1


with open('test.json',mode='rb') as f:
    l=json.load(f)
    print(l,type(l))


res=json.dumps({'name': '哈哈哈'})
print(res,type(res))  # {"name": "\u54c8\u54c8\u54c8"} <class 'str'>

dic=json.loads('{"name": "\u54c8\u54c8\u54c8"}')
print(dic)  # {'name': '哈哈哈'}

```

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1681117530982-1e24a489-ac4f-4ad1-bc0c-3a64ad21d9ab.png)

<h3 id="MBG9n">猴子补丁</h3>

```python

# 一.什么是猴子补丁?
      属性在运行时的动态替换，叫做猴子补丁（Monkey Patch）。
      猴子补丁的核心就是用自己的代码替换所用模块的源代码，详细地如下
　　1，这个词原来为Guerrilla Patch，杂牌军、游击队，说明这部分不是原装的，在英文里guerilla发音和gorllia(猩猩)相似，再后来就写了monkey(猴子)。
　　2，还有一种解释是说由于这种方式将原来的代码弄乱了(messing with it)，在英文里叫monkeying about(顽皮的)，所以叫做Monkey Patch。


# 二. 猴子补丁的功能(一切皆对象)
　　1.拥有在模块运行时替换的功能, 例如: 一个函数对象赋值给另外一个函数对象(把函数原本的执行的功能给替换了)
class Monkey:
    def hello(self):
        print('hello')

    def world(self):
        print('world')


def other_func():
    print("from other_func")



monkey = Monkey()
monkey.hello = monkey.world
monkey.hello()
monkey.world = other_func
monkey.world()

# 三.monkey patch的应用场景
如果我们的程序中已经基于json模块编写了大量代码了，发现有一个模块ujson比它性能更高，
但用法一样，我们肯定不会想所有的代码都换成ujson.dumps或者ujson.loads,那我们可能
会想到这么做
import ujson as json，但是这么做的需要每个文件都重新导入一下，维护成本依然很高
此时我们就可以用到猴子补丁了
只需要在入口处加上
, 只需要在入口加上:

import json
import ujson

def monkey_patch_json():
    json.__name__ = 'ujson'
    json.dumps = ujson.dumps
    json.loads = ujson.loads

monkey_patch_json() # 之所以在入口处加，是因为模块在导入一次后，后续的导入便直接引用第一次的成果

#其实这种场景也比较多, 比如我们引用团队通用库里的一个模块, 又想丰富模块的功能, 除了继承之外也可以考虑用Monkey
Patch.采用猴子补丁之后，如果发现ujson不符合预期，那也可以快速撤掉补丁。个人感觉Monkey
Patch带了便利的同时也有搞乱源代码的风险!
    
```

<h2 id="vjsHk">**<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">2、pickle</font>**</h2>
![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1681289432313-5ec7c15f-0022-4348-8356-cbcf758e4543.png)



```python

# 存档有限选择pickle模块
import pickle
res=pickle.dumps({1,2,3,4,5})
print(res)  # b'\x80\x03cbuiltins\nset\nq\x00]q\x01(K\x01K\x02K\x03K\x04K\x05e\x85q\x02Rq\x03.'
s=pickle.loads(res)
print(s,type(s))  # {1, 2, 3, 4, 5} <class 'set'>


# Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，
# 并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，
# 不能成功地反序列化也没关系。 

import pickle
dic={'name':'alvin','age':23,'sex':'male'}
print(type(dic))#<class 'dict'>
j=pickle.dumps(dic)
print(type(j))#<class 'bytes'>
 
 
f=open('序列化对象_pickle','wb')#注意是w是写入str,wb是写入bytes,j是'bytes'
f.write(j)  #-------------------等价于pickle.dump(dic,f)
  
f.close()
#-------------------------反序列化
import pickle
f=open('序列化对象_pickle','rb')
  
data=pickle.loads(f.read())#  等价于data=pickle.load(f)
 
 
print(data['age'])

```



<h1 id="j679j"><font style="color:rgb(255, 255, 255);background-color:rgb(43, 102, 149);">七、 configparser模块</font></h1>
configparser模块： 加载某种特定格式的配置文件

```properties
# 注释1
; 注释2

[section1]
k1 = v1
k2:v2
user=egon
age=18
is_admin=true
salary=31

[section2]
k1 = v1
```

读取

```python

# configparser模块： 加载某种特定格式的配置文件

import configparser

config = configparser.ConfigParser()
config.read('test.ini')

# 1、获取所有的sections
print(config.sections())  # ['section1', 'section2']

# 2、获取某一section下的所有options
print(config.options('section1'))  # ['k1', 'k2', 'user', 'age', 'is_admin', 'salary']

# 3、获取items
print(config.items(
    'section1'))  # [('k1', 'v1'), ('k2', 'v2'), ('user', 'egon'), ('age', '18'), ('is_admin', 'true'), ('salary', '31')]

# 4、获取指定的key的值
#查看标题section1下user的值=>字符串格式
res = config.get('section1', 'user')
print(res, type(res))  # egon <class 'str'>

# 但是这样还需要我们手动吧str的8 转成int 18，有点麻烦。
res1 = config.get('section1', 'age')
print(res1, type(res1))  # 18 <class 'str'>

#查看标题section1下age的值=>整数格式
res2 = config.getint('section1', 'age')
print(res2, type(res2))  # 18 <class 'int'>

#查看标题section1下is_admin的值=>布尔值格式
res3=config.getboolean('section1', 'is_admin')
print(res3, type(res3))  # True <class 'bool'>


res4=config.getfloat('section1', 'salary')
print(res4,type(res4))  # 31.11111 <class 'float'>

```

**<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">改写（了解）</font>**

```python

修改配置文件的案例（了解即可）

import configparser

config=configparser.ConfigParser()
config.read('test.ini',encoding='utf-8')

#
#删除整个标题section2
config.remove_section('section2')

#删除标题section1下的某个k1和k2
config.remove_option('section1','k1')
config.remove_option('section1','k2')

#判断是否存在某个标题
print(config.has_section('section1'))

#判断标题section1下是否有user
print(config.has_option('section1','user'))


#添加一个标题
config.add_section('egon')

#在标题egon下添加name=egon,age=18的配置
config.set('egon','name','egon')
config.set('egon','age','18') #报错,必须是字符串
#
#
# #最后将修改的内容写入文件,完成最终的修改
config.write(open('test.ini','wt'))


# 案例：
import configparser

config = configparser.ConfigParser()
config["DEFAULT"] = {'ServerAliveInterval': '45',
                     'Compression': 'yes',
                     'CompressionLevel': '9'}

config['bitbucket.org'] = {}
config['bitbucket.org']['User'] = 'hg'
config['topsecret.server.com'] = {}
topsecret = config['topsecret.server.com']
topsecret['Host Port'] = '50022'  # mutates the parser
topsecret['ForwardX11'] = 'no'  # same here
config['DEFAULT']['ForwardX11'] = 'yes'
with open('example.ini', 'w') as configfile:
    config.write(configfile)



```

<h1 id="IkouQ"><font style="color:rgb(255, 255, 255);background-color:rgb(43, 102, 149);">八 hashlib模块</font></h1>

```bash
# 1、什么叫hash:

hash是一种算法（3.x里代替了md5模块和sha模块，主要提供 SHA1, SHA224, SHA256, SHA384, SHA512 ，MD5 算法），该算法接受传入的内容，经过运算得到一串hash值

# 2、hash值的特点是：

I 只要传入的内容一样，得到的hash值必然一样=====>要用明文传输密码文件完整性校验
II 不能由hash值返解成内容=======》把密码做成hash值，不应该在网络传输明文密码
III 只要使用的hash算法不变，无论校验的内容有多大，得到的hash值长度是固定的

# 123456abc=====》md5 =====> hash字符串
# 客户端=====》hash字符串====》 服务端

# 特点
特点II用于密码密文传输与验证
特点I与特点III用于文件完整性校验

# 3、hash的用途
hash算法就像一座工厂，工厂接收你送来的原材料（可以用m.update()
为工厂运送原材料），经过加工返回的产品就是hash值

```

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1681289899584-186a2c4f-4f4a-40fc-819c-f524d5023fe5.png)



```python

import hashlib

m=hashlib.md5()
# update里面传入参数必须是bytes类型。
m.update('hello'.encode('utf-8'))  #update里面传入的必须是bytes类型。str===》bytes类型
m.update('world'.encode('utf-8'))
res=m.hexdigest()  # 'hello world'
print(res)  # fc5e038d38a57032085441e7fe7010b0


import hashlib
m1=hashlib.md5('he'.encode('utf-8'))
m1.update('llo'.encode('utf-8'))
m1.update('w'.encode('utf-8'))
m1.update('orld'.encode('utf-8'))
res=m1.hexdigest()
print(res)  # fc5e038d38a57032085441e7fe7010b0

'''
注意：把一段很长的数据update多次，与一次update这段长数据，得到的结果一样
但是update多次为校验大文件提供了可能
'''


# 思考
# 一下子把文件加载到内存，容易内存溢出。
m.update(文件所有的内容)   
m.hexdigest()


# 换种逻辑，可以使用这种。
f=open('a.txt',mode='rb')
f.seek()
f.read(2000)
m1.update(文件的一行)
m1.hexdigest()



```

<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);"></font>

> <font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">以上加密算法虽然依然非常厉害，但时候存在缺陷，即：通过撞库可以反解。所以，有必要对加密算法中添加自定义key再来做加密。</font>
>

```python

# 模拟撞库
cryptograph='aee949757a2e698417463d47acac93df'  # 已知的md5加密后的字符串
import hashlib

# 制作密码字段
passwds=[
    'alex3714',
    'alex1313',
    'alex94139413',
    'alex123456',
    '123456alex',
    'a123lex',
    ]

dic={}
for p in passwds:
    res=hashlib.md5(p.encode('utf-8'))
    dic[p]=res.hexdigest()

# 模拟撞库得到密码
for k,v in dic.items():
    if v == cryptograph:
        print('撞库成功，明文密码是：%s' %k)
        break



######进阶一下############
import hashlib
cryptograph='aee949757a2e698417463d47acac93df'
passwds=[
    'alex3714',
    'alex1313',
    'alex94139413',
    'alex123456',
    '123456alex',
    'a123lex',
    ]
def make_passwd_dic(passwds):
    dic={}
    for passwd in passwds:
        m=hashlib.md5()
        m.update(passwd.encode('utf-8'))
        dic[passwd]=m.hexdigest()
    return dic

def break_code(cryptograph,passwd_dic):
    for k,v in passwd_dic.items():
        if v == cryptograph:
            print('密码是===>\033[46m%s\033[0m' %k)
            break

break_code(cryptograph,make_passwd_dic(passwds))



```

<h4 id="c2bEX">密码加盐</h4>

```python
# 密码加盐
import hashlib
m=hashlib.md5()
m.update('天王'.encode('utf-8'))
m.update('alex3714'.encode('utf-8'))
m.update('盖地虎'.encode('utf-8'))
res=m.hexdigest() # '天王alex3714盖地虎'
print(res)  # ef606e983c958a13273eaad0b29a054c

```

<h1 id="cmYKj"><font style="color:rgb(255, 255, 255);background-color:rgb(43, 102, 149);">九 suprocess模块</font></h1>

```python

# 作用：用来执行系统命令的
import subprocess

obj=subprocess.Popen('ls /root', shell=True,
                     stdout=subprocess.PIPE,
                     stderr=subprocess.PIPE,
                     )

res=obj.stdout.read()
print(res)

err_res=obj.stderr.read()
print(err_res)

```

```python

'''
  sh-3.2# ls /Users/egon/Desktop |grep txt$
  mysql.txt
  tt.txt
  事物.txt
'''
import  subprocess
res1=subprocess.Popen('ls /Users/jieli/Desktop',shell=True,stdout=subprocess.PIPE)
res=subprocess.Popen('grep txt$',shell=True,stdin=res1.stdout,
                 stdout=subprocess.PIPE)

print(res.stdout.read().decode('utf-8'))

#等同于上面,但是上面的优势在于,一个数据流可以和另外一个数据流交互,可以通过爬虫得到结果然后交给grep
res1=subprocess.Popen('ls /Users/jieli/Desktop |grep txt$',shell=True,stdout=subprocess.PIPE)
print(res1.stdout.read().decode('utf-8'))
#windows下:
# dir | findstr 'test*'
# dir | findstr 'txt$'
import subprocess
res1=subprocess.Popen(r'dir C:\Users\Administrator\PycharmProjects\test\函数备课',shell=True,stdout=subprocess.PIPE)
res=subprocess.Popen('findstr test*',shell=True,stdin=res1.stdout,
                 stdout=subprocess.PIPE)
print(res.stdout.read().decode('gbk')) #subprocess使用当前系统默认编码，得到结果为bytes类型，在windows下需要用gbk解码



# 详情参考官方：https://docs.python.org/2/library/subprocess.html?highlight=subprocess#frequently-used-arguments

```



<h1 id="DZFCy"><font style="color:rgb(255, 255, 255);background-color:rgb(43, 102, 149);">十 logging模块</font></h1>
logging模块可以用来记录程序运行的日志，日志在程序开发中是非常重要的部分，在线上生产环境或者在测试环境中可以通过日志来查看程序运行是否正常，如果程序异常，可以通过日志快速定位到异常的代码位置，因此记录日志需要尽可能的详细，在python开发中可以借助logging模块记录日志。

```python

import logging

# 数字大小代表不同等级
CRITICAL = 50 
ERROR = 40
WARNING = 30 
INFO = 20
DEBUG = 10
NOTSET = 0 


logging.debug('调试debug')
logging.info('消息info')
logging.warning('警告warn')
logging.error('错误error')
logging.critical('严重critical')

'''
WARNING:root:警告warn
ERROR:root:错误error
CRITICAL:root:严重critical
'''


```

<font style="color:rgb(37, 41, 51);">默认warning及以上级别的日志(waring error critical)可以输出到终端上， 日志应该记录在文件中方便查看，可以为logging模块通过logging.basicConfig()指定全局配置，可以将日志保存到文件中。</font>

```python

import logging

logging.basicConfig(filename='test.log',
                    format='%(asctime)s - %(name)s - %(levelname)s -%(module)s:  %(message)s',
                    datefmt='%Y-%m-%d %H:%M:%S %p',
                    level=10)

上述参数及其他未用到的参数介绍如下：
filename：用指定的文件名创建FiledHandler，用来打印到文件中
datefmt：指定日期时间格式。
level：根据数字设置的日志级别

format参数中可能用到的格式化串：
%(name)s Logger的名字
%(levelno)s 数字形式的日志级别
%(levelname)s 文本形式的日志级别
%(pathname)s 调用日志输出函数的模块的完整路径名，可能没有
%(filename)s 调用日志输出函数的模块的文件名
%(module)s 调用日志输出函数的模块名
%(funcName)s 调用日志输出函数的函数名
%(lineno)d 调用日志输出函数的语句所在的代码行
%(asctime)s 字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒
%(thread)d 线程ID。可能没有
%(threadName)s 线程名。可能没有
%(process)d 进程ID。可能没有
%(message)s用户输出的消息

```

logging模块在使用过程中，需要用到**Formatter，Handler，Logger，Filter对象**：

logger：产生日志的对象；

Filter：过滤日志的对象，不常用；

Handler：接收日志然后控制打印到不同的地方，FileHandler用来打印到文件中，StreamHandler用来打印到终端；

Formatter对象：可以定制不同的日志格式对象，然后绑定给不同的Handler对象使用，以此来控制不同的Handler的日志格式。

上面说了这么多，到底如何在python的项目中使用logging模块记录日志呢？**在项目开发中，只需要记住下面的用法就OK了。**

****

**<font style="color:rgb(255, 0, 0);background-color:rgb(244, 237, 227);">logger是第一级过滤，然后才能到handler，我们可以给logger和handler同时设置level</font>**

首先，在项目的配置文件(settings.py)中对日志格式进行配置：



```python

# settings.py

"""
logging配置
"""

import os

# 2、强调：其中的%(name)s为getlogger时指定的名字
standard_format = '[%(asctime)s][%(threadName)s:%(thread)d][task_id:%(name)s][%(filename)s:%(lineno)d]' \
                  '[%(levelname)s][%(message)s]'

simple_format = '[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d]%(message)s'

test_format = '%(asctime)s] %(message)s'

# 3、日志配置字典
LOGGING_DIC = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'standard': {
            'format': standard_format
        },
        'simple': {
            'format': simple_format
        },
        'test': {
            'format': test_format
        },
    },
    'filters': {},
    'handlers': {
        #打印到终端的日志
        'console': {
            'level': 'DEBUG',
            'class': 'logging.StreamHandler',  # 打印到屏幕
            'formatter': 'simple'
        },
        #打印到文件的日志,收集info及以上的日志
        'default': {
            'level': 'DEBUG',
            'class': 'logging.handlers.RotatingFileHandler',  # 保存到文件,日志轮转
            'formatter': 'standard',
            # 可以定制日志文件路径
            # BASE_DIR = os.path.dirname(os.path.abspath(__file__))  # log文件的目录
            # LOG_PATH = os.path.join(BASE_DIR,'a1.log')
            'filename': 'a1.log',  # 日志文件
            'maxBytes': 1024*1024*5,  # 日志大小 5M
            'backupCount': 20,  # 最多保存几份
            'encoding': 'utf-8',  # 日志文件的编码，再也不用担心中文log乱码了
        },
        'other': {
            'level': 'DEBUG',
            'class': 'logging.FileHandler',  # 保存到文件
            'formatter': 'test',
            'filename': 'a2.log',  # 现实开发中定义路径：os.path.join(os.path.dirname(os.path.dirname(__file__)),'log','a2.log')
            'encoding': 'utf-8',
        },
    },
    'loggers': {
        #logging.getLogger(__name__)拿到的logger配置
        '': {
            'handlers': ['default', 'console'],  # 这里把上面定义的两个handler都加上，即log数据既写入文件又打印到屏幕
            'level': 'DEBUG', # loggers(第一层日志级别关限制)--->handlers(第二层日志级别关卡限制)
            'propagate': False,  # 默认为True，向上（更高level的logger）传递，通常设置为False即可，否则会一份日志向上层层传递
        },
        '专门的采集': {
            'handlers': ['other',],
            'level': 'DEBUG',
            'propagate': False,
        },
    },
}
```

<font style="color:rgb(37, 41, 51);">然后，在其他文件中使用logging模块记录日志:</font>

```python

# test.py

import settings

# !!!强调!!!
# 1、logging是一个包，需要使用其下的config、getLogger，可以如下导入
# from logging import config
# from logging import getLogger

# 2、也可以使用如下导入
import logging.config # 这样连同logging.getLogger都一起导入了,然后使用前缀logging.config.

# 3、加载配置
logging.config.dictConfig(settings.LOGGING_DIC)

# 4、输出日志
logger1=logging.getLogger('用户交易')
logger1.info('egon儿子alex转账3亿冥币')

# logger2=logging.getLogger('专门的采集') # 名字传入的必须是'专门的采集'，与LOGGING_DIC中的配置唯一对应
# logger2.debug('专门采集的日志')



# 注意：
getLogger和加载日志配置应该写在common.py中去，做成小工具，在src中直接拿来用既可以。

```



<font style="color:rgb(37, 41, 51);">logging模块看起来非常复杂，但是使用起来按照上面的方式，在项目开发的时候，只需要拷贝过去使用就可以了。</font>

<font style="color:rgb(37, 41, 51);"></font>

<h1 id="GJTDB"><font style="color:rgb(255, 255, 255);background-color:rgb(43, 102, 149);">十一 re模块</font></h1>
<h2 id="aLjnK"><font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">1、什么是正则？</font></h2>
**<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">正则就是用一些具有特殊含义的符号组合到一起（称为正则表达式）来描述字符或者字符串的方法。或者说：正则就是用来描述一类事物的规则。</font>****<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">（在Python中）它内嵌在Python中，并通过 re 模块实现。正则表达式模式被编译成一系列的字节码，然后由用 C 编写的匹配引擎执行。</font>**

**<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">生活中处处都是正则：</font>**

**<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">比如我们描述：4条腿</font>**

**<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">你可能会想到的是四条腿的动物或者桌子，椅子等</font>**

**<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">继续描述：4条腿，活的</font>**

**<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">就只剩下四条腿的动物这一类了</font>**

**<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);"></font>**

<h1 id="i1gJj"><font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">2、</font><font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">常用匹配模式(元字符)</font></h1>
[http://blog.csdn.net/yufenghyc/article/details/51078107](http://blog.csdn.net/yufenghyc/article/details/51078107)

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1681374245930-596f80aa-ce6a-44f9-926a-db0420e843ee.png)

```python

\w:匹配包括下划线在内任何字母数字字符，它相当于类[a-zA-Z0-9_]
\W:匹配非任何字母数字字符包括下划线在内，它相当于类[^a-zA-Z0-9_]
\s:匹配任何空白字符，它相当于类[\t\n\r\f\v]
\S:匹配任何非空白字符，它相当于类[^\t\n\r\f\v]
\d:匹配任何十进制数，它相当于类[0-9]
\D:匹配任何非数字字符，它相当于类[^0-9]
^元字符:匹配字符串开头。
$元字符:匹配字符串末尾。
.:匹配除了\n之外任意一个字符
*元字符:匹配前一个字符0或多次，性格贪婪。
+元字符:匹配前一个字符1次或无限次
?元字符(防止贪婪匹配):匹配一个字符0次或1次:还有一个功能是在量词后面加上？号防止贪婪匹配 。
{m}元字符(范围):自定义字符数{m}匹配前一个字符m次，多一个也不行。
{m,n}匹配前一个字符m至n次，若省略n，则匹配m至无限次
{0,}匹配前一个字符0或多次,等同于*元字符
{1,}匹配前一个字符1次或无限次,等同于+元字符
{0,1}匹配前一个字符0次或1次,等同于?元字符

[]元字符(字符集):[]里的任意一个字符就匹配字符集。字符集中的字符可以逐个列出，也可以给出范围，如[abc]或[a-c]。[^abc]表示取反，即非abc。
所有特殊字符在字符集中都失去其原有的特殊含义。用\反斜杠转义恢复特殊字符的特殊含义。
[^]:反取，匹配出除[^]里面的字符。
^元字符如果写到字符集里就是反取

()元字符(分组):分组匹配。()里面的为一个组也可以理解成一个整体。
如果()后面跟的是特殊元字符如 (adc)* 那么*控制的前导字符就是()里的整体内容，不再是前导一个字符。

|元字符(或):就是前后其中一个符合就匹配

```

```python

# =================================匹配模式=================================
#一对一的匹配
# 'hello'.replace(old,new)
# 'hello'.find('pattern')

#正则匹配
import re
#\w与\W
print(re.findall('\w','hello egon 123')) #['h', 'e', 'l', 'l', 'o', 'e', 'g', 'o', 'n', '1', '2', '3']
print(re.findall('\W','hello egon 123')) #[' ', ' ']

#\s与\S
print(re.findall('\s','hello  egon  123')) #[' ', ' ', ' ', ' ']
print(re.findall('\S','hello  egon  123')) #['h', 'e', 'l', 'l', 'o', 'e', 'g', 'o', 'n', '1', '2', '3']

#\n \t都是空,都可以被\s匹配
print(re.findall('\s','hello \n egon \t 123')) #[' ', '\n', ' ', ' ', '\t', ' ']

#\n与\t
print(re.findall(r'\n','hello egon \n123')) #['\n']
print(re.findall(r'\t','hello egon\t123')) #['\n']

#\d与\D
print(re.findall('\d','hello egon 123')) #['1', '2', '3']
print(re.findall('\D','hello egon 123')) #['h', 'e', 'l', 'l', 'o', ' ', 'e', 'g', 'o', 'n', ' ']

#\A与\Z
print(re.findall('\Ahe','hello egon 123')) #['he'],\A==>^
print(re.findall('123\Z','hello egon 123')) #['he'],\Z==>$

```



```python

^ 
指定匹配必须出现在字符串的开头或行的开头。

\A 
指定匹配必须出现在字符串的开头（忽略 Multiline 选项）。

$ 
指定匹配必须出现在以下位置：字符串结尾、字符串结尾的 \n 之前或行的结尾。

\Z 
指定匹配必须出现在字符串的结尾或字符串结尾的 \n 之前（忽略 Multiline 选项）。

#^与$
print(re.findall('^h','hello egon 123')) #['h']
print(re.findall('3$','hello egon 123')) #['3']

# 重复匹配：| . | * | ? | .* | .*? | + | {n,m} |
#.
print(re.findall('a.b','a1b')) #['a1b']
print(re.findall('a.b','a1b a*b a b aaab')) #['a1b', 'a*b', 'a b', 'aab']
print(re.findall('a.b','a\nb')) #[]
print(re.findall('a.b','a\nb',re.S)) #['a\nb']
print(re.findall('a.b','a\nb',re.DOTALL)) #['a\nb']同上一条意思一样

#*
print(re.findall('ab*','bbbbbbb')) #[]
print(re.findall('ab*','a')) #['a']
print(re.findall('ab*','abbbb')) #['abbbb']

#?
print(re.findall('ab?','a')) #['a']
print(re.findall('ab?','abbb')) #['ab']
#匹配所有包含小数在内的数字
print(re.findall('\d+\.?\d*',"asdfasdf123as1.13dfa12adsf1asdf3")) #['123', '1.13', '12', '1', '3']

#.*默认为贪婪匹配
print(re.findall('a.*b','a1b22222222b')) #['a1b22222222b']

#.*?为非贪婪匹配：推荐使用
print(re.findall('a.*?b','a1b22222222b')) #['a1b']

#+
print(re.findall('ab+','a')) #[]
print(re.findall('ab+','abbb')) #['abbb']

#{n,m}
print(re.findall('ab{2}','abbb')) #['abb']
print(re.findall('ab{2,4}','abbb')) #['abb']
print(re.findall('ab{1,}','abbb')) #'ab{1,}' ===> 'ab+'
print(re.findall('ab{0,}','abbb')) #'ab{0,}' ===> 'ab*'

#[]
print(re.findall('a[1*-]b','a1b a*b a-b')) #[]内的都为普通字符了，且如果-没有被转意的话，应该放到[]的开头或结尾
print(re.findall('a[^1*-]b','a1b a*b a-b a=b')) #[]内的^代表的意思是取反，所以结果为['a=b']
print(re.findall('a[0-9]b','a1b a*b a-b a=b')) #[]内的^代表的意思是取反，所以结果为['a=b']
print(re.findall('a[a-z]b','a1b a*b a-b a=b aeb')) #[]内的^代表的意思是取反，所以结果为['a=b']
print(re.findall('a[a-zA-Z]b','a1b a*b a-b a=b aeb aEb')) #[]内的^代表的意思是取反，所以结果为['a=b']

#\# print(re.findall('a\\c','a\c')) #对于正则来说a\\c确实可以匹配到a\c,但是在python解释器读取a\\c时，会发生转义，然后交给re去执行，所以抛出异常
print(re.findall(r'a\\c','a\c')) #r代表告诉解释器使用rawstring，即原生字符串，把我们正则内的所有符号都当普通字符处理，不要转义
print(re.findall('a\\\\c','a\c')) #同上面的意思一样，和上面的结果一样都是['a\\c']

#():分组
print(re.findall('ab+','ababab123')) #['ab', 'ab', 'ab']
print(re.findall('(ab)+123','ababab123')) #['ab']，匹配到末尾的ab123中的ab
print(re.findall('(?:ab)+123','ababab123')) #findall的结果不是匹配的全部内容，而是组内的内容,?:可以让结果为匹配的全部内容
print(re.findall('href="(.*?)"','<a href="http://www.baidu.com">点击</a>'))#['http://www.baidu.com']
print(re.findall('href="(?:.*?)"','<a href="http://www.baidu.com">点击</a>'))#['href="http://www.baidu.com"']

#|
print(re.findall('compan(?:y|ies)','Too many companies have gone bankrupt, and the next one is my company'))

```



```python

# ===========================re模块提供的方法介绍===========================
import re
#1
print(re.findall('e','alex make love') )   #['e', 'e', 'e'],返回所有满足匹配条件的结果,放在列表里
#2
print(re.search('e','alex make love').group()) #e,只到找到第一个匹配然后返回一个包含匹配信息的对象,该对象可以通过调用group()方法得到匹配的字符串,如果字符串没有匹配，则返回None。

#3
print(re.match('e','alex make love'))    #None,同search,不过在字符串开始处进行匹配,完全可以用search+^代替match

#4
print(re.split('[ab]','abcd'))     #['', '', 'cd']，先按'a'分割得到''和'bcd',再对''和'bcd'分别按'b'分割

#5
print('===>',re.sub('a','A','alex make love')) #===> Alex mAke love，不指定n，默认替换所有
print('===>',re.sub('a','A','alex make love',1)) #===> Alex make love
print('===>',re.sub('a','A','alex make love',2)) #===> Alex mAke love
print('===>',re.sub('^(\w+)(.*?\s)(\w+)(.*?\s)(\w+)(.*?)$',r'\5\2\3\4\1','alex make love')) #===> love make alex

print('===>',re.subn('a','A','alex make love')) #===> ('Alex mAke love', 2),结果带有总共替换的个数


#6
obj=re.compile('\d{2}')

print(obj.search('abc123eeee').group()) #12
print(obj.findall('abc123eeee')) #['12'],重用了obj

```

<h3 id="JhTKe">补充：</h3>
补充1：

```python

import re
print(re.findall("<(?P<tag_name>\w+)>\w+</(?P=tag_name)>","<h1>hello</h1>")) #['h1']
print(re.search("<(?P<tag_name>\w+)>\w+</(?P=tag_name)>","<h1>hello</h1>").group()) #<h1>hello</h1>
print(re.search("<(?P<tag_name>\w+)>\w+</(?P=tag_name)>","<h1>hello</h1>").groupdict()) #<h1>hello</h1>

print(re.search(r"<(\w+)>\w+</(\w+)>","<h1>hello</h1>").group())
print(re.search(r"<(\w+)>\w+</\1>","<h1>hello</h1>").group())

```

补充2：

```python

#补充二
import re

#使用|，先匹配的先生效，|左边是匹配小数，而findall最终结果是查看分组，所有即使匹配成功小数也不会存入结果
#而不是小数时，就去匹配(-?\d+)，匹配到的自然就是，非小数的数，在此处即整数
#
print(re.findall(r"-?\d+\.\d*|(-?\d+)","1-2*(60+(-40.35/5)-(-4*3))")) #找出所有整数['1', '-2', '60', '', '5', '-4', '3']

#找到所有数字:
print(re.findall('\D?(\-?\d+\.?\d*)',"1-2*(60+(-40.35/5)-(-4*3))")) # ['1','2','60','-40.35','5','-4','3']





#计算器作业参考：http://www.cnblogs.com/wupeiqi/articles/4949995.html
expression='1-2*((60+2*(-3-40.0/5)*(9-2*5/3+7/3*99/4*2998+10*568/14))-(-4*3)/(16-3*2))'

content=re.search('\(([\-\+\*\/]*\d+\.?\d*)+\)',expression).group() #(-3-40.0/5)

```

补充3：

```python
#为何同样的表达式search与findall却有不同结果:
print(re.search('\(([\+\-\*\/]*\d+\.?\d*)+\)',"1-12*(60+(-40.35/5)-(-4*3))").group()) #(-40.35/5)
print(re.findall('\(([\+\-\*\/]*\d+\.?\d*)+\)',"1-12*(60+(-40.35/5)-(-4*3))")) #['/5', '*3']

#看这个例子:(\d)+相当于(\d)(\d)(\d)(\d)...,是一系列分组
print(re.search('(\d)+','123').group()) #group的作用是将所有组拼接到一起显示出来
print(re.findall('(\d)+','123')) #findall结果是组内的结果,且是最后一个组的结果
```





```python

#_*_coding:utf-8_*_
__author__ = 'Linhaifeng'
#在线调试工具:tool.oschina.net/regex/#
import re

s='''
http://www.baidu.com
egon@oldboyedu.com
你好
010-3141
'''

#最常规匹配
# content='Hello 123 456 World_This is a Regex Demo'
# res=re.match('Hello\s\d\d\d\s\d{3}\s\w{10}.*Demo',content)
# print(res)
# print(res.group())
# print(res.span())

#泛匹配
# content='Hello 123 456 World_This is a Regex Demo'
# res=re.match('^Hello.*Demo',content)
# print(res.group())


#匹配目标,获得指定数据

# content='Hello 123 456 World_This is a Regex Demo'
# res=re.match('^Hello\s(\d+)\s(\d+)\s.*Demo',content)
# print(res.group()) #取所有匹配的内容
# print(res.group(1)) #取匹配的第一个括号内的内容
# print(res.group(2)) #去陪陪的第二个括号内的内容



#贪婪匹配:.*代表匹配尽可能多的字符
# import re
# content='Hello 123 456 World_This is a Regex Demo'
#
# res=re.match('^He.*(\d+).*Demo$',content)
# print(res.group(1)) #只打印6,因为.*会尽可能多的匹配,然后后面跟至少一个数字


#非贪婪匹配:?匹配尽可能少的字符
# import re
# content='Hello 123 456 World_This is a Regex Demo'
#
# res=re.match('^He.*?(\d+).*Demo$',content)
# print(res.group(1)) #只打印6,因为.*会尽可能多的匹配,然后后面跟至少一个数字


#匹配模式:.不能匹配换行符
content='''Hello 123456 World_This
is a Regex Demo
'''
# res=re.match('He.*?(\d+).*?Demo$',content)
# print(res) #输出None

# res=re.match('He.*?(\d+).*?Demo$',content,re.S) #re.S让.可以匹配换行符
# print(res)
# print(res.group(1))


#转义:\

# content='price is $5.00'
# res=re.match('price is $5.00',content)
# print(res)
#
# res=re.match('price is \$5\.00',content)
# print(res)


#总结:尽量精简,详细的如下
    # 尽量使用泛匹配模式.*
    # 尽量使用非贪婪模式:.*?
    # 使用括号得到匹配目标:用group(n)去取得结果
    # 有换行符就用re.S:修改模式










#re.search:会扫描整个字符串,不会从头开始,找到第一个匹配的结果就会返回

# import re
# content='Extra strings Hello 123 456 World_This is a Regex Demo Extra strings'
#
# res=re.match('Hello.*?(\d+).*?Demo',content)
# print(res) #输出结果为None

#
# import re
# content='Extra strings Hello 123 456 World_This is a Regex Demo Extra strings'
#
# res=re.search('Hello.*?(\d+).*?Demo',content) #
# print(res.group(1)) #输出结果为



#re.search:只要一个结果,匹配演练,
import re
content='''
<tbody>
<tr id="4766303201494371851675" class="even "><td><div class="hd"><span class="num">1</span><div class="rk "><span class="u-icn u-icn-75"></span></div></div></td><td class="rank"><div class="f-cb"><div class="tt"><a href="/song?id=476630320"><img class="rpic" src="http://p1.music.126.net/Wl7T1LBRhZFg0O26nnR2iQ==/19217264230385030.jpg?param=50y50&amp;quality=100"></a><span data-res-id="476630320" "
# res=re.search('<a\shref=.*?<b\stitle="(.*?)".*?b>',content)
# print(res.group(1))


#re.findall:找到符合条件的所有结果
# res=re.findall('<a\shref=.*?<b\stitle="(.*?)".*?b>',content)
# for i in res:
#     print(i)



#re.sub:字符串替换
import re
content='Extra strings Hello 123 456 World_This is a Regex Demo Extra strings'

# content=re.sub('\d+','',content)
# print(content)


#用\1取得第一个括号的内容
#用法:将123与456换位置
# import re
# content='Extra strings Hello 123 456 World_This is a Regex Demo Extra strings'
#
# # content=re.sub('(Extra.*?)(\d+)(\s)(\d+)(.*?strings)',r'\1\4\3\2\5',content)
# content=re.sub('(\d+)(\s)(\d+)',r'\3\2\1',content)
# print(content)




# import re
# content='Extra strings Hello 123 456 World_This is a Regex Demo Extra strings'
#
# res=re.search('Extra.*?(\d+).*strings',content)
# print(res.group(1))


# import requests,re
# respone=requests.get('https://book.douban.com/').text

# print(respone)
# print('======'*1000)
# print('======'*1000)
# print('======'*1000)
# print('======'*1000)
# res=re.findall('<li.*?cover.*?href="(.*?)".*?title="(.*?)">.*?more-meta.*?author">(.*?)</span.*?year">(.*?)</span.*?publisher">(.*?)</span.*?</li>',respone,re.S)
# # res=re.findall('<li.*?cover.*?href="(.*?)".*?more-meta.*?author">(.*?)</span.*?year">(.*?)</span.*?publisher">(.*?)</span>.*?</li>',respone,re.S)
#
#
# for i in res:
#     print('%s    %s    %s   %s' %(i[0].strip(),i[1].strip(),i[2].strip(),i[3].strip()))

```

<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">作业：</font>

```python

import re

# 1、匹配密码，密码必须是由6位数字与字母组成，并且不能是纯数字也不能是纯字母
# 1.1 知识点：# ?!pattern,表示在没有配到pattern的字符串的前提下，再进行后续的正则表达式匹配，后续匹配仍然从被匹配字符串的头开始

# 1.2 答案：
print(re.search("(?!^[0-9]+$)(?!^[a-zA-Z]+$)^[0-9A-Za-z]{6}$","123asf").group())  # 123asf

# 1.3 解释：
# 上述正则的意思为：在匹配(?!^[0-9]+$)以及(?!^[a-zA-Z]+$)过后，如果字符串成功后在从头去匹配(?!^[a-zA-Z]+$)，最终匹配完。


# 2、匹配密码，密码强度：强，必须包含大写，小写和数字,和特殊字符(!,@,#,%,&),且大于6位
# 2.1 知识点：# ?=pattern,表示在配到pattern的字符串的前提下，再进行后续的正则表达式匹配，后续匹配仍然从被匹配字符串的头开始

# 2.2 答案：
# while True:
#     pwd = input("please your password: ").strip()  # 比如输入：Aa3@adf123
#     pwd_pattern= re.compile("(?=.*[A-Z])(?=.*[a-z])(?=.*[0-9])(?=.*[!@#%&])^([a-zA-Z0-9!@#%&]){6,}$")
#     if pwd_pattern.search(pwd) is None:
#         print("密码强度不够")
#     else:
#         break

# 2.3 解释：
# 上述正则表达式的意思：
#（1）首先是(?=.*[A-Z])匹配，.*表示密码中可以包含多个字符，[A-Z]代表密码中需要包含至少一个大写字母，注意一定不要去掉.*写成(?=[A-Z]),那样表示密码只能由一个字符组成，该字符是大写字母
#（2）其次是(?=.*[a-z])匹配，同上，确保密码中必须至少有一个小写字母
#（3）然后是(?=.*[0-9])匹配，同上，确保密码中必须至少有一个数字
#（4）然后是(?=.*[!@#%&])匹配，同上，，确保密码中必须至少有一个特殊符号!@#%&

#（5）最后是^([a-zA-Z0-9!@#%&]){6,}$，确保密码是由[a-zA-Z0-9!@#%&]字符构成，至少有6位


# 3、匹配email
# print(re.findall("(?:[a-zA-Z0-9]+)@(?:[0-9a-zA-Z]+).com","18611323113@163.com xxx@qq.com"))

# 4、匹配身份证
# your_id=input(">>: ").strip()
# print(re.findall("^([0-9]){17}([0-9]|X)$",your_id)) # 17个数字组成，最后一个字符可以是数字或X

# 5、匹配用户名，包含字母或者数字,且8位
# print(re.findall("^[0-9a-zA-Z]{8}$","egonlinh"))

# 5.1、要求输入的内容只能是汉字
# name=input('>>: ').strip()
# print(re.search(r'[\u4E00-\u9fa5]+',name))

# 6、取出字符串里的数字
# print(re.findall(r'\d+(?:\.\d+)?', 'sww123kw11.333e2lkd'))

# 7、取出所有负整数
# print(re.findall(r'-\d+', '-12,3,54,-13.11,64，-9'))  # 错误答案
# print(re.findall(r'(?!-\d+\.\d+)-\d+', '-12,3,54,-13.11,64，-9'))  # 正确答案

# 8、所有数字
# print(re.findall(r'\-?\d+(?:\.\d+)?', '-12.9,3.92,54.11,64，89，-9，-45.2'))

# 9、所有负数
# print(re.findall(r'\-\d+(?:\.\d+)?', '-12.9,3.92,54.11,64，89，-9，-45.2'))

# 10、所有的非负浮点数
print(re.findall(r'\d+\.\d+', '-12.9,3.92,54.11,64，89，-9，-45.2'))

# 11、
msg = """
中文名 贝拉克·侯赛因·奥巴马 
外文名 Barack Hussein Obama II 
别名 欧巴马 
性 别 男
国籍 美国 
民 族 德裔族 
出生地 美国夏威夷州檀香山 
出生日期 1961年8月4日 
职 业政治家、律师、总统 
毕业院校 哥伦比亚大学，哈佛大学 
信 仰新教 
主要成就 1996年伊利诺伊州参议员 
主要成就 美国第56届、57届总统 2009年诺贝尔和平奖获得者 时代周刊年度风云人物2008、2011 任期内清除本·拉登 
代表作品 《我相信变革》《我父亲的梦想》《无畏的希望》 
所属政党美国民主党 
血 型 AB型 
学 院西方学院 
妻 子 米歇尔·拉沃恩·奥巴马 

"""
#外文名
print(re.findall("外文名 (.*)",msg))

#出生日期
print(re.findall('出生日期 (\d{4})年(\d+)月(\d+)日',msg))

#妻子姓名
print(re.findall('妻 子 (\S+)',msg))

```

参考链接：[https://juejin.cn/post/6968320405341732871](https://juejin.cn/post/6968320405341732871)

参考链接：[https://www.cnblogs.com/linhaifeng/articles/6384466.html](https://www.cnblogs.com/linhaifeng/articles/6384466.html)

参考链接：[https://egonlin.com/?p=4188](https://egonlin.com/?p=4188)

<h2 id="KI2Mm">补充2：</h2>
<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">推荐阅读：</font>

[https://www.cnblogs.com/linhaifeng/articles/13432794.html](https://www.cnblogs.com/linhaifeng/articles/13432794.html)

<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);"></font>

[正则表达式中(?:pattern)、(?=pattern)、(?!pattern)、(?<=pattern)和(?<!pattern)](https://www.cnblogs.com/linhaifeng/articles/13432615.html)

<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">下述表达式都是断言，不占用宽度</font>

<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);"></font>

**<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">前面有，正向后发(?<=exp)，放前面；</font>**

<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);"></font>

**<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">后面有，正向先行(?=exp)，放后面；</font>**

<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);"></font>

**<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">前面无，反向后发(?<!exp)，放前面；</font>**

<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);"></font>

**<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">后面无，反向先行(?!exp)，放后面。</font>**

<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">例如</font>


```python
re.findall("egon(?=100|N)(?=N)N123","egonN123")  # ['egonN123']

# 位置：   0    1    2    3    4    5    6     7
# 字符串：e    g    o    n    N    1    2    3


# 分析：
# 步骤1、正则表达式egon匹配到了字符串的位置3

然后连续进行两次断言匹配
# 步骤2、(?=100|N)从位置3作为起始匹配位置4的字符是否100或者N
# 步骤3、2成功后，继续匹配(?=N)，因为?=patter不会吃字符，所以此时会重新回到步骤1所在位置3，然后继续匹配，匹配成功

# 步骤4、从位置3开始匹配N123


# 思考下述输出结果，为何会不同？？？：
re.findall("egon(?=100|N)(?=N)N123","egonN123")
re.findall("egon(?=100|N)(?=N)123","egonN123")

```

<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);"></font>

<h3 id="EQung"><font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">介绍</font></h3>
<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">(pattern) ： 匹配 pattern 并获取这一匹配，所获取的匹配可以从产生的 Matches 集合得到。  
</font><font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">(?:pattern) ：匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。  
</font><font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">(?=pattern) ：正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</font>

<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);"></font>

<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">共同点</font>

<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);"></font>

<font style="color:rgb(232, 62, 140);background-color:rgb(246, 246, 246);">(?:pattern)</font><font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);"> 与 </font><font style="color:rgb(232, 62, 140);background-color:rgb(246, 246, 246);">(?=pattern)</font><font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">都匹配pattern，但不会把pattern结果放到Matches的集合中，即Matcher.group()不会匹配到(?;pattern)与(?=pattern)</font>

<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);"></font>

<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">区别</font>

<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);"></font>

    - <font style="color:rgb(232, 62, 140);background-color:rgb(246, 246, 246);">(?:pattern)</font><font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);"> 匹配得到的结果包含pattern，</font><font style="color:rgb(232, 62, 140);background-color:rgb(246, 246, 246);">(?=pattern)</font><font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);"> 则不包含。如：</font>


```python
  ○ 对字符串："industry abc"的匹配结果：
  ○  industr(?:y|ies) ---> "industry" 
  ○ industr(?=y|ies) ---> "industr"
```

    - <font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">是否消耗字符  
</font><font style="color:rgb(232, 62, 140);background-color:rgb(246, 246, 246);">(?:pattern)</font><font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);"> 消耗字符，下一字符匹配会从已匹配后的位置开始。  
</font><font style="color:rgb(232, 62, 140);background-color:rgb(246, 246, 246);">(?=pattern)</font><font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);"> 不消耗字符，下一字符匹配会从预查之前的位置开始。  
</font><font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);">即后者只预查，不移动匹配指针。如：</font>

<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);"></font>

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1681374628976-330f8e72-2d2f-4b92-93f1-2aef439ab3ac.png)

<font style="color:rgb(73, 73, 73);background-color:rgb(244, 237, 227);"></font>



