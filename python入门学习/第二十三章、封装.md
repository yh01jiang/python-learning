![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1700817291283-3a077502-b350-4558-a250-c526ddae75b6.png)

<h1 id="LyxOu"><font style="color:rgb(18, 18, 18);">一 引入</font></h1>
<font style="color:rgb(18, 18, 18);">面向对象编程有三大特性：封装、继承、多态，其中最重要的一个特性就是封装。封装指的就是把数据与功能都整合到一起，听起来是不是很熟悉，没错，我们之前所说的”整合“二字其实就是封装的通俗说法。除此之外，针对封装到对象或者类中的属性，我们还可以严格控制对它们的访问，分两步实现：</font><font style="color:#DF2A3F;">隐藏与开放接口</font>

<font style="color:rgb(18, 18, 18);"></font>

<h2 id="dkdH1"><font style="color:rgb(18, 18, 18);">二 隐藏属性 & 开放接口</font></h2>
```python

# 我们之前所说的”整合“二字其实就是封装的通俗说法。
# 除此之外，针对封装到对象或者类中的属性，我们还可以严格控制对它们的访问，分两步实现：隐藏与开放接口


# 二 封装的属性如何隐藏操作
# 1. 如何隐藏：在属性名前面加__前缀，就会实现对外隐藏属性的效果
# 2. 该隐藏需要注意的问题：
#I、在类外部无法直接访问双下滑线开头的属性，但知道了类名和属性名就可以拼出名字：_类名__属性，然后就可以访问了，如Foo._Foo__x，所以说这种操作并没有严格意义上地限制外部访问，仅仅只是一种语法意义上的变形。
class Foo:
    __x = 1  # _Foo__x
    def __f1():  # _Foo__f1
        print('from test') 


# 在外部通过_类__属性可以访问到，但是没有意义
print(Foo._Foo__x)
print(Foo._Foo__f1)

# 输出
# {'__module__': '__main__', '_Foo__x': 1, '_Foo__f1': <function Foo.__f1 at 0x104f44940>, '__dict__': <attribute '__dict__' of 'Foo' objects>, '__weakref__': <attribute '__weakref__' of 'Foo' objects>, '__doc__': None}


# II: 这种隐藏对外不对内,在类内部是可以直接访问双下滑线开头的属性的，比如self.__f1()，因为在类定义阶段类内部双下滑线开头的属性统一发生了变形。
# 因为__开头的属性会在检查类内的代码语法时统一发生变形
class Foo:
    __x = 1  # _Foo__x = 1

    def __f1(self):  # _Foo__f1
        print('from test') 
    
    def f2(self):
        print(self.__x) # print(self._Foo__x)
        print(self.__f1) # print(self._Foo__f1)


obj=Foo()
obj.f2()

# 结果：
# 1
# <bound method Foo.__f1 of <__main__.Foo object at 0x104c6aee0>>

# III:这种变形操作只在检查类体语法时候发生一次，之后__开头的属性不会发生改变
class Foo:
    __x = 1  # _Foo__x = 1

    def __f1(self):  # _Foo__f1
        print('from test') 
    
    def f2(self):
        print(self.__x) # print(self._Foo__x)
        print(self.__f1) # print(self._Foo__f1)

Foo.__y=3

print(Foo.__dict__)
print(Foo.__y)
# 输出
# {'__module__': '__main__', '_Foo__x': 1, '_Foo__f1': <function Foo.__f1 at 0x10021c940>, 'f2': <function Foo.f2 at 0x10021c9d0>, '__dict__': <attribute '__dict__' of 'Foo' objects>, '__weakref__': <attribute '__weakref__' of 'Foo' objects>, '__doc__': None, '__y': 3}
# 3




# 示例
class Foo:
    __x = 1  
    def __init__(self,name,age):  
        self.name=name
        self.age=age

obj=Foo('egon', 18)
print(obj.__dict__)
print(obj.name,obj.age)

# 输出
# {'name': 'egon', 'age': 18}
# egon 18



class Foo:
    __x = 1  
    def __init__(self,name,age):  
        self.__name=name
        self.__age=age
    def func(slef):
        print(self.__name)
        print(self.__age)

obj=Foo('egon', 18)
print(obj.__dict__)
print(obj.func)
print(obj.name,obj.age)

# 输出结果：
# {'_Foo__name': 'egon', '_Foo__age': 18}
# <bound method Foo.func of <__main__.Foo object at 0x104e72fd0>>

# 3. 为何要隐藏？
# 将数据隐藏起来就限制了类外部对数据的直接操作，
# 然后类内应该提供相应的接口来允许类外部间接地操作数据，接口之上可以附加额外的逻辑来对数据的操作进行严格地控制
# I 隐藏数据属性
# 设计者

class People:
    def __init__(self,name):
        # self.name=name
        self.__name=name

    def get_name(self):
            # 通过该接口就可以访问到名字属性
        # print('小垃圾，不让看')
        print(self.__name)

    def set_name(self,val):
        self.__name=val
        

# 使用者
obj=People('egon')
# print(obj.name) # 无法直接用名字属性
# obj.get_name()  # egon
obj.set_name('EGON') 
obj.get_name()    



# 三 开放接口
# 定义属性就是为了使用，所以隐藏并不是目的

class People:
    def __init__(self,name):
        # self.name=name
        self.__name=name

    def get_name(self):
            # 通过该接口就可以访问到名字属性
        # print('小垃圾，不让看')
        print(self.__name)

    def set_name(self,val):
        if type(val) is not str:
            print('小垃圾，必须传字符串类型')
            return
        self.__name=val

obj=People('egon')
obj.set_name(123346)  #因为这里不是字符串
obj.get_name()

# 输出：
# 小垃圾，必须传字符串类型
# egon      


# II 隐藏函数属性
# 目的的是为了隔离复杂度，例如ATM程序的取款功能,该功能有很多其他功能组成，比如插卡、身份认证、输入金额、打印小票、取钱等，
# 而对使用者来说,只需要开发取款这个功能接口即可,其余功能我们都可以隐藏起来


>>> class ATM:
...     def __card(self): #插卡
...         print('插卡')
...     def __auth(self): #身份认证
...         print('用户认证')
...     def __input(self): #输入金额
...         print('输入取款金额')
...     def __print_bill(self): #打印小票
...         print('打印账单')
...     def __take_money(self): #取钱
...         print('取款')
...     def withdraw(self): #取款功能
...         self.__card()
...         self.__auth()
...         self.__input()
...         self.__print_bill()
...         self.__take_money()
...
>>> obj=ATM()
>>> obj.withdraw()
```

<h2 id="Agv7k">总结</h2>
> <font style="color:rgb(18, 18, 18);">总结隐藏属性与开放接口，本质就是为了明确地区分内外，</font><font style="color:rgb(18, 18, 18);background-color:#FBDE28;">类内部可以修改封装内的东西而不影响外部调用者的代码；而类外部只需拿到一个接口，只要接口名、参数不变，则无论设计者如何改变内部实现代码，使用者均无需改变代码。这就提供一个良好的合作基础，只要接口这个基础约定不变，则代码的修改不足为虑</font>
>

<h2 id="xHM9X"><font style="color:rgb(18, 18, 18);">三 property</font></h2>
```python
class People:

    def __init__(self,name,weight,height):
        self.name=name
        self.weight=weight
        self.height=height
    
    # 定义函数的原因：
    # 1. 从bmi的公式上看，应该是触发功能计算得到的
    # 2. bmi是随着身高 体重变化的到的，不是一个固定的值，说白了，每次都是临时计算的到的 
    
    # 但是bmi更像是一个数据属性，而不是一个功能
    def bmi(self):
        return self.weight / (self.height ** 2)
        
obj=People('egon', 70, 1.8)


print(obj.bmi())  # 21.604938271604937
 

# 案例1 

# property是一个装饰器，是用来将绑定给对象的方法伪装成一个数据属性。

class People:

    def __init__(self,name,weight,height):
        self.name=name
        self.weight=weight
        self.height=height
    
    # 定义函数的原因：
    # 1. 从bmi的公式上看，应该是触发功能计算得到的
    # 2. bmi是随着身高 体重变化的到的，不是一个固定的值，说白了，每次都是临时计算的到的 
    
    # 但是bmi更像是一个数据属性，而不是一个功能
    @property   # 使用装饰器将绑定给对象的方法伪装成一个数据属性，下文就不需要再次调用obj.bmi()使用了
    def bmi(self):
        return self.weight / (self.height ** 2)
        
obj=People('egon', 70, 1.8)


print(obj.bmi)  # 21.604938271604937
     


# 案例2:

class People:
    def __init__(self,name):
        self.__name=name  # 属性隐藏

    # 开放接口
    def get_name(self):
        return self.__name

    def set_name(self,val):
        if type(val) is not str:
            print('请传入字符串')
            return
        self.__name=val

    def del_name(self):
        print('不让删除')
        del self.__name


obj1=People('egon')
print(obj1.get_name())
obj1.set_name('EGON')
print(obj1.get_name())
obj1.del_name()

# # 输出结果：
# egon
# EGON
# 不让删除



class People:
    def __init__(self,name):
        self.__name=name  # 属性隐藏

    # 开放接口
    def get_name(self):
        return self.__name

    def set_name(self,val):
        if type(val) is not str:
            print('请传入字符串')
            return
        self.__name=val

    def del_name(self):
        print('不让删除')
        del self.__name

    # 将绑定方法伪装策称一个数据属性，@property 代表的就是 函数=property(函数)
    name=property(get_name,set_name,del_name)


obj1=People('egon')

print(obj1.name) # 其实就是找name属性中的get_name 的方法去执行，将name返回出去

obj1.name = 18  #  其实就是找name属性中的set_name 方法的运行，set_name 需要两个参数，将obj1 以及 18 传给set_name 函数

del obj1.name

# 输出
# egon
# 请传入字符串
# 不让删除


# 案例3:

# 首先对name 属性的三个访问操作，都定义成想让外部使用者访问的属性名字
class People:
    def __init__(self,name):
        self.__name=name  # 属性隐藏

    @property  # 其实就是执行了这种操作：name=property(name)
    def name(self):  # obj1.name
        return self.__name

    @name.setter
    def name(self,val):  # obj1.name = 'EGON'
        if type(val) is not str:
            print('请传入字符串')
            return
        self.__name=val

    @name.deleter
    def name(self):  # del obj1.name
        print('不让删除')
        del self.__name




obj1=People('egon')
# 人正常的思维逻辑
print(obj1.name) 

obj1.name = 18  
del obj1.name

# 输出：
# egon
# 请传入字符串
# 不让删除

```

