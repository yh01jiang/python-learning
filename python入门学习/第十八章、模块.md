![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1680594713052-59781681-d6e5-49fc-ac72-ac373de965b6.png)



<h2 id="wcfTU"><font style="color:rgb(18, 18, 18);">一 、模块介绍</font></h2>
```python
# 1、什么是模块？
    模块就是一系列功能的集合体，分为三大类：
          I  内置的模块
          II 第三方模块
          III 自定义模块
            一个python文件本身就是一个模块，文件名m.py,模块名为m
            python、c++、c编写

            ps: 模块分为4种形式：

            　　1） 使用python编写的.py文件

            　　2）已被编译为共享库或DLL的C或C++扩展

            　　3） 把一系列模块组织到一起的文件夹（注：文件夹下有一个__init__.py文件，该文件夹称之为包）

            　　4） 使用C编写并链接到python解释器的内置模块




# 2、为何要有模块
    I: 内置与第三方的模块拿来就用，无需定义，这种拿来主义，可以极大的提高自己的开发效率
    II: 自定义模块
        可以将程序的各部分功能提取出来放到一模块中为大家共享使用
        好处是为了减少了代码的冗余，程序组织结构更加清晰。


# 3、首次导入模块发生了几件事？
    1、产生foo的名称空间，将foo.py运行过程中产生的名字都丢到foo的名称空间中去
    2、执行了foo.py
    3、在当前文件中产生了的有一个名字foo，该名字指向1中产生的名称空间

```

<h2 id="FBn3R"><font style="color:rgb(18, 18, 18);">二 、模块的使用</font></h2>
<h2 id="gQVSX"><font style="color:rgb(18, 18, 18);">2.1 import语句</font></h2>
```python
#文件名：foo.py
x=1
def get():
    print(x)
def change():
    global x
    x=0
class Foo:
    def func(self):
       print('from the func')
```

<font style="color:rgb(18, 18, 18);">要想在另外一个py文件中引用foo.py中的功能，需要使用import foo，</font><font style="color:#DF2A3F;">首次导入模块会做三件事：</font>

<font style="color:#DF2A3F;">1、产生一个新的名称空间用于存放源文件执行过程中产生的名字</font>

<font style="color:#DF2A3F;">2、执行源文件代码</font>

<font style="color:#DF2A3F;">3、在当前执行文件所在的名称空间中得到一个名字foo，该名字指向新创建的模块名称空间，若要引用模块名称空间中的名字，需要加上该前缀，如下</font>

```python
import foo #导入模块foo
a=foo.x #引用模块foo中变量x的值赋值给当前名称空间中的名字a
foo.get() #调用模块foo的get函数
foo.change() #调用模块foo中的change函数
obj=foo.Foo() #使用模块foo的类Foo来实例化，进一步可以执行obj.func()


print(foo.x) #1
print(foo.get) # 内存地址
print(foo.change)
```

<font style="color:#DF2A3F;">加上foo.作为前缀就相当于指名道姓地说明要引用foo名称空间中的名字</font><font style="color:rgb(18, 18, 18);">，所以肯定不会与当前执行文件所在名称空间中的名字相冲突，</font><font style="color:#DF2A3F;">并且若当前执行文件的名称空间中存在x，执行foo.get()或foo.change()操作的都是源文件中的全局变量x。</font>

<font style="color:rgb(18, 18, 18);"></font>

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1680511137969-718ef212-8662-4770-82f4-83745c281511.png)

<font style="color:rgb(18, 18, 18);">需要</font>**<font style="color:#DF2A3F;">强调</font>**<font style="color:rgb(18, 18, 18);">一点是，</font><font style="color:#2F8EF4;">第一次导入模块已经将其加载到内存空间了，之后的重复导入会直接引用内存中已存在的模块，不会重复执行文件</font><font style="color:rgb(18, 18, 18);">，通过import sys，打印sys.modules的值可以看到内存中已经加载的模块名。</font>

<font style="color:rgb(18, 18, 18);">提示：</font>

```python
#1、在Python中模块也属于第一类对象，可以进行赋值、以数据形式传递以及作为容器类型的元素等操作。
#2、模块名应该遵循小写形式，标准库从python2过渡到python3做出了很多这类调整，比如ConfigParser、Queue、SocketServer全更新为纯小写形式。
```

<font style="color:rgb(18, 18, 18);">用import语句导入多个模块，可以写多行import语句</font>

```python
import module1
import module2
    ...
import moduleN
```

<font style="color:rgb(18, 18, 18);">还可以在一行导入，用逗号分隔开不同的模块(不建议)</font>

```python
import module1,module2,...,moduleN
```

<font style="color:rgb(18, 18, 18);">但其实第一种形式更为规范，可读性更强，推荐使用，而且我们导入的模块中可能包含有python内置的模块、第三方的模块、自定义的模块，为了便于明显地区分它们，我们通常在文件的开头导入模块，并且分类导入，一类模块的导入与另外一类的导入用空行隔开，不同类别的导入顺序如下：</font>

```python
#1. python内置模块
#2. 第三方模块
#3. 程序员自定义模块
```

<font style="color:rgb(18, 18, 18);"> 当然，我们也可以在函数内导入模块，对比在文件开头导入模块属于</font><font style="color:#DF2A3F;">全局</font><font style="color:rgb(18, 18, 18);">作用域，在函数内导入的模块则属于</font><font style="color:#DF2A3F;">局部</font><font style="color:rgb(18, 18, 18);">的作用域。</font>



补充：

```python
# 3、可以使用逗号为分隔符在一行导入多个模块
# 建议这样写
import time
import sys

# 不建议在一行同时导入多个模块
import time,sys

# 4、import导入模块的规范
I: python内置模块
II: 第三方模块
III: 自定义模块
模块是第一类对象(与函数都是第一类对象，4大特性。)

import foo
    1） 可以被赋值
    2） 可以当做参数
    3） 可以做返回值
    4） 可以当做容器内的元素

# 5、import...  as ...   as用来起别名
import foo as f
f.x
f.get()
f.change()

# 6、自定义模块的命名应该采用纯小写+下划线的风格

# 7、可以在函数外部以及函数内部导入模块
# 区别：就是作用域的影响，全局或者局部
```

<h2 id="T5ecV"><font style="color:rgb(18, 18, 18);">2.2 py文件的两种用途</font></h2>
<font style="color:#DF2A3F;">1、被当做程序运行</font>

<font style="color:#DF2A3F;">2、被当做模块导入</font>



<font style="color:rgb(18, 18, 18);">一个Python文件有两种用途，一种被当主程序/脚本执行，另一种被当模块导入，</font><font style="color:#EDCE02;">为了区别同一个文件的不同用途，每个py文件都内置了__name__变量，该变量在py文件被当做脚本执行时赋值为“__main__”,在py文件被当做模块导入时赋值为模块名</font>

<font style="color:rgb(18, 18, 18);">作为模块foo.py的开发者，可以在文件末尾基于__name__在不同应用场景下值的不同来控制文件执行不同的逻辑</font>

```python
#foo.py
...
if __name__ == '__main__':
    # foo.py被当做脚本执行时运行的代码
else:
    # foo.py被当做模块导入时运行的代码
```

<font style="color:rgb(18, 18, 18);">通常我们会在if的子代码块中编写针对模块功能的测试代码，这样foo.py在被当做脚本运行时，就会执行测试代码，而被当做模块导入时则不用执行测试代码。</font>

```python
print('模块名foo===>')
__all__=['x',]  # 控制*代表的名字有哪些
x=1
def get():
    print(x)

def change():
    global x
    x=0

def say():
    print('我还活在内存中呢。。。')
# print(__name__)  # __name__ = '__main__'
# 当foo.py被运行时，__name__的值为'__main__'
# 当foo.py被当做模块导入时，__name__的值为'foo',也就是模块名。
if __name__ == '__main__':
    print('文件被执行')
    get()
    change()
else:
    # 被当做模块导入时做的事情
    print('文件被导入')
    pass

```

<h2 id="kuF3J"><font style="color:rgb(18, 18, 18);">2.3 from-import 语句</font></h2>
<font style="color:rgb(18, 18, 18);">from...import...与import语句基本一致，唯一不同的是：</font>

<font style="color:#07787E;">使用import foo导入模块后，引用模块中的名字都需要加上foo.作为前缀，而使用from foo import x,get,change,Foo则可以在当前执行文件中直接引用模块foo中的名字</font><font style="color:rgb(18, 18, 18);">，如下</font>

```python
from foo import x,get,change #将模块foo中的x和get导入到当前名称空间
a=x #直接使用模块foo中的x赋值给a
get() #直接执行foo中的get函数
change() #即便是当前有重名的x，修改的仍然是源文件中的x
```

import导入模块的优缺点

```python
# import导入模块在使用时必须加前缀"模块."
# 优点：肯定不会与当前空间中的名字冲突
# 缺点： 加前缀显得麻烦
```

<font style="color:#DF2A3F;">from...import ... 导入也发生了三件事</font>

```python
# 1、产生一个模块的名称空间
# 2、运行foo.py将运行过程中产生的名字都丢到模块的名称空间去
# 3、在当前名称空间拿到一个名字，该名字指向模块名称空间中的某一个内存地址
```

<font style="color:#8CCF17;">无需加前缀的好处是使得我们的代码更加简洁，坏处则是容易与当前名称空间中的名字冲突，如果当前名称空间存在相同的名字，则后定义的名字会覆盖之前定义的名字。</font>

<font style="color:rgb(18, 18, 18);">另外from语句支持from foo import </font>_<font style="color:rgb(18, 18, 18);">语法，</font>_<font style="color:rgb(18, 18, 18);">代表将foo中所有的名字都导入到当前位置</font>

```python
from foo import * #把foo中所有的名字都导入到当前执行文件的名称空间中，在当前位置直接可以使用这些名字

a=x
get()
change()
obj=Foo()
```

<font style="color:rgb(18, 18, 18);">如果我们需要引用模块中的名字过多的话，可以采用上述的导入形式来达到节省代码量的效果，但是需要强调的一点是：只能在模块最顶层使用</font>_<font style="color:rgb(18, 18, 18);">的方式导入，在函数内则非法，并且</font>_<font style="color:rgb(18, 18, 18);">的方式会带来一种副作用，即我们无法搞清楚究竟从源文件中导入了哪些名字到当前位置，这极有可能与当前位置的名字产生冲突。模块的编写者可以在自己的文件中定义__all__变量用来控制*代表的意思</font>

```python
#foo.py
__all__=['x','get'] #该列表中所有的元素必须是字符串类型，每个元素对应foo.py中的一个名字
x=1
def get():
    print(x)
def change():
    global x
    x=0
class Foo:
    def func(self):
       print('from the func')
```

<font style="color:rgb(18, 18, 18);">这样我们在另外一个文件中使用*导入时，就只能导入__all__定义的名字了</font>

```python
from foo import * #此时的*只代表x和get

x #可用
get() #可用
change() #不可用
Foo() #不可用
```

<font style="color:#DF2A3F;">from  import 图例</font>

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1680587078052-a8fe4342-2b5c-4eb7-86e9-1879a6f03bc8.png)



<font style="color:#DF2A3F;">get---> change---> get 图例</font>

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1680587300692-cb40e0db-2655-4ca3-a54a-ce165bc9a2b0.png)

补充：

```python
from foo import x  # x=模块foo中值0的内存地址
from foo import get
from foo import change

print(x)
print(get)
print(change)

# 输出结果：
模块名foo===>
1
<function get at 0x015EBF60>
<function change at 0x015EBFA8>
x=33333333
print(x)  # 33333333
get()  # 1
change()
get()  # 0
print(x)  # 1
重新导入一次，x的值由原来的1变成0了
from foo import x  # x=新地址
print(x)  # 0

# from... import ... 导入模块在使用时不用加前缀
# 优点：代码更精简
# 缺点： 容易与当前名称空间混淆

from foo import x  # x=模块foo中值1的内存地址
x=1111

# 一行导入多个名字(不推荐)
from foo import x,get,change

# *:导入模块中的所有名字（不推荐）
from foo import *
print(x)
print(get)
print(change)

# 了解: __all__
from foo import *
print(x)  # 可以找到
print(get)  # 找不到
print(change)  # 找不到

# 起别名
# 针对get起的别名
from foo import  get as g
```

<h2 id="QrovD"><font style="color:rgb(18, 18, 18);">2.4 循环导入问题</font></h2>
<font style="color:#117CEE;">循环导入问题指的是在一个模块加载/导入的过程中导入另外一个模块，而在另外一个模块中又返回来导入第一个模块中的名字，由于第一个模块尚未加载完毕，所以引用失败、抛出异常</font><font style="color:rgb(18, 18, 18);">，究其根源就是在python中，同一个模块只会在第一次导入时执行其内部代码，再次导入该模块时，即便是该模块尚未完全加载完毕也不会去重复执行内部代码</font>

**<font style="color:rgb(18, 18, 18);">我们以下述文件为例，来详细分析循环/嵌套导入出现异常的原因以及解决的方案</font>**

<font style="color:rgb(18, 18, 18);">m1.py</font>

```python
print('正在导入m1')
from m2 import y

x='m1'
```

<font style="color:rgb(18, 18, 18);">m2.py</font>

```python
print('正在导入m2')
from m1 import x

y='m2'
```

<font style="color:rgb(18, 18, 18);">run.py</font>

```python
import m1
```

**<font style="color:rgb(18, 18, 18);">测试一</font>**

```python
#1、执行run.py会抛出异常
正在导入m1
正在导入m2
Traceback (most recent call last):
  File "/Users/linhaifeng/PycharmProjects/pro01/1 aaaa练习目录/aa.py", line 1, in <module>
    import m1
  File "/Users/linhaifeng/PycharmProjects/pro01/1 aaaa练习目录/m1.py", line 2, in <module>
    from m2 import y
  File "/Users/linhaifeng/PycharmProjects/pro01/1 aaaa练习目录/m2.py", line 2, in <module>
    from m1 import x
ImportError: cannot import name 'x'

#2、分析
先执行run.py--->执行import m1，开始导入m1并运行其内部代码--->打印内容"正在导入m1"
--->执行from m2 import y 开始导入m2并运行其内部代码--->打印内容“正在导入m2”--->执行from m1 import x,由于m1已经被导入过了，所以不会重新导入，所以直接去m1中拿x，然而x此时并没有存在于m1中，所以报错
```

**<font style="color:rgb(18, 18, 18);">测试二</font>**

```python
#1、执行文件不等于导入文件，比如执行m1.py不等于导入了m1
直接执行m1.py抛出异常
正在导入m1
正在导入m2
正在导入m1
Traceback (most recent call last):
  File "/Users/linhaifeng/PycharmProjects/pro01/1 aaaa练习目录/m1.py", line 2, in <module>
    from m2 import y
  File "/Users/linhaifeng/PycharmProjects/pro01/1 aaaa练习目录/m2.py", line 2, in <module>
    from m1 import x
  File "/Users/linhaifeng/PycharmProjects/pro01/1 aaaa练习目录/m1.py", line 2, in <module>
    from m2 import y
ImportError: cannot import name 'y'

#2、分析
执行m1.py，打印“正在导入m1”，执行from m2 import y ，导入m2进而执行m2.py内部代码--->打印"正在导入m2"，执行from m1 import x，此时m1是第一次被导入，执行m1.py并不等于导入了m1，于是开始导入m1并执行其内部代码--->打印"正在导入m1"，执行from m1 import y，由于m1已经被导入过了，所以无需继续导入而直接问m2要y，然而y此时并没有存在于m2中所以报错
```

**<font style="color:rgb(18, 18, 18);">解决方案</font>**

```python
# 方案一：导入语句放到最后，保证在导入时，所有名字都已经加载过
# 文件：m1.py
print('正在导入m1')

x='m1'

from m2 import y

# 文件：m2.py
print('正在导入m2')
y='m2'

from m1 import x

# 文件：run.py内容如下，执行该文件，可以正常使用
import m1
print(m1.x)
print(m1.y)

# 方案二：导入语句放到函数中，只有在调用函数时才会执行其内部代码
# 文件：m1.py
print('正在导入m1')

def f1():
    from m2 import y
    print(x,y)

x = 'm1'

# 文件：m2.py
print('正在导入m2')

def f2():
    from m1 import x
    print(x,y)

y = 'm2'

# 文件：run.py内容如下，执行该文件，可以正常使用
import m1

m1.f1()
```

**<font style="color:rgb(18, 18, 18);">注意：循环导入问题大多数情况是因为程序设计失误导致，上述解决方案也只是在烂设计之上的无奈之举，在我们的程序中应该尽量避免出现循环/嵌套导入，如果多个模块确实都需要共享某些数据，可以将共享的数据集中存放到某一个地方，然后进行导入</font>**

**<font style="color:rgb(18, 18, 18);"></font>**

<h2 id="bq3bt"><font style="color:rgb(18, 18, 18);">2.5 搜索模块的路径与优先级</font></h2>
<font style="color:rgb(18, 18, 18);">模块其实分为</font>**<font style="color:#ED740C;">四个通用类别</font>**<font style="color:rgb(18, 18, 18);">，分别是：</font>

<font style="color:#DF2A3F;">1、使用纯Python代码编写的py文件</font>

<font style="color:#DF2A3F;">2、包含一系列模块的包</font>

<font style="color:#DF2A3F;">3、使用C编写并链接到Python解释器中的内置模块</font>

<font style="color:#DF2A3F;">4、使用C或C++编译的扩展模块</font>

<font style="color:#4C16B1;">在导入一个模块时，如果该模块已加载到内存中，则直接引用，否则会优先查找内置模块，然后按照从左到右的顺序依次检索sys.path中定义的路径，直到找模块对应的文件为止，否则抛出异常</font><font style="color:rgb(18, 18, 18);">。sys.path也被称为模块的搜索路径，它是一个列表类型</font>

```python
>>> sys.path
['',
'/Library/Frameworks/Python.framework/Versions/3.5/lib/python35.zip',
'/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5',
...,
'/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages'
```

<font style="color:rgb(18, 18, 18);">列表中的每个元素其实都可以当作一个目录来看：在列表中会发现有.zip或.egg结尾的文件，二者是不同形式的压缩文件，事实上Python确实支持从一个压缩文件中导入模块，我们也只需要把它们都当成目录去看即可。</font>

<font style="color:rgb(18, 18, 18);">  
</font>**<font style="color:#0C68CA;">sys.path</font>**<font style="color:rgb(18, 18, 18);">中的</font><font style="color:#74B602;">第一个路径通常为空，代表执行文件所在的路径</font><font style="color:rgb(18, 18, 18);">，</font><font style="color:#0C68CA;">所以在被导入模块与执行文件在同一目录下时肯定是可以正常导入的</font><font style="color:rgb(18, 18, 18);">，</font><font style="color:#F5D480;">而针对被导入的模块与执行文件在不同路径下的情况</font><font style="color:rgb(18, 18, 18);">，为了确保模块对应的源文件仍可以被找到，</font><font style="color:#DF2A3F;">需要将源文件foo.py所在的路径添加到sys.path中，假设foo.py所在的路径为/pythoner/projects/</font>

```python
import sys
sys.path.append(r'/pythoner/projects/') #也可以使用sys.path.insert(……)

import foo #无论foo.py在何处,我们都可以导入它了
```

补充知识：

```python
# 1、无论是import还是from...import 在导入模块时，都涉及到查找问题
优先级：
  1、内存（内置模块）
  2、按照sys.path中存放的文件夹的顺序，依次查找要导入的模块


# import sys
# 值为一个列表，存放了一系列的文件夹
# 其中第一个文件夹是当前执行文件所在的文件夹
# print(sys.path)


# import foo
# foo.say()
#
# import time
# time.sleep(10)
#
# import foo
# foo.say()


# 2、了解：sys.modules查看已经加载到内存中的模块
import sys

import foo  # foo=模块的内存地址
del foo
# print('foo' in sys.modules)
print(sys.modules)

# 3、sys.path的应用
# 如果foo.py文件与你想要执行的py文件不在同级目录的时候
# 这时候就得使用sys.path.append把foo.py对应的目录文件夹添加到环境变量中去
# 导入才能找到foo模块
import sys
sys.path.append(r'D:\py1\python\python-project\day16\aaa')
import foo
foo.say()
```

<h2 id="YrSVv"><font style="color:rgb(18, 18, 18);">2.7 编写一个规范的模块</font></h2>
<font style="color:rgb(18, 18, 18);">我们在编写py文件时，需要时刻提醒自己，该文件既是给自己用的，也有可能会被其他人使用，因而代码的可读性与易维护性显得十分重要，为此我们在编写一个模块时</font><font style="color:#4C16B1;">最好按照统一的规范去编写</font><font style="color:rgb(18, 18, 18);">，如下</font>

```python
#!/usr/bin/env python #通常只在类unix环境有效,作用是可以使用脚本名来执行，而无需直接调用解释器。

"The module is used to..." #模块的文档描述

import sys #导入模块

x=1 #定义全局变量,如果非必须,则最好使用局部变量,这样可以提高代码的易维护性,并且可以节省内存提高性能

class Foo: #定义类,并写好类的注释
    'Class Foo is used to...'
    pass

def test(): #定义函数,并写好函数的注释
    'Function test is used to…'
    pass

if __name__ == '__main__': #主程序
    test() #在被当做脚本执行时,执行此处的代码
```

