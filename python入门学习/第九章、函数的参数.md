![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1679469533792-de7ebffb-0ffd-41b2-b7d4-ccbcba44eff3.png)

<h2 id="LpKVh"><font style="color:rgb(18, 18, 18);">一 形参与实参介绍</font></h2>
```python
# 形参即在定义函数时，括号内声明的参数。形参本质就是一个变量名，用来接收外部传来的值。相当于变量名
def func(x,y):
    print(x,y)
# 实参即在调用函数时，括号内传入的值，值可以是常量、变量、表达式或三者的组合。相当于变量值
func(1,2)



注意事项：
'''
形参与实参的关系：
在调用有参函数时，实参（值）会绑定给形参（变量名）。
在Python中，变量名与值只是单纯的绑定关系，这种绑定关系只能在函数体内使用。
而对于函数来说，这种绑定关系只在函数调用时生效，在调用结束后解除。
'''
```

实参即在调用函数时，括号内传入的值，值可以是常量、变量、表达式或三者的组合:

```python
# 实参相当于值，值可以是以下形式
# 形式1: 实参是常量
func(1,2)

# 形式2: 实参是变量
a=1
b=2
func(a,b)

# 形式3: 实参是表达式
func(int('1'),2)
func(func1(1,2,), func2(2,3,) 333)

#4：实参可以是常量、变量、表达式的任意组合
a=2
my_min(1,a,10*my_min(3,4))
```

<h2 id="sUiLy"><font style="color:rgb(18, 18, 18);">二 形参与实参的具体使用</font></h2>
<h2 id="yO7xo"><font style="color:rgb(18, 18, 18);">2.1 位置参数</font></h2>
<font style="background-color:#8CCF17;">位置形参</font>：<font style="color:#DF2A3F;">在定义函数时，按照从左到右的顺序依次定义形参,称为位置形参，</font>

<font style="color:#DF2A3F;">凡是按照这种形式定义的形参都必须被传值</font>

<font style="color:#DF2A3F;">多一个值也不行，少一个也不行。</font>

```python
def func(x,y):
    print(x,y)
func(1,2)
```

<font style="background-color:#8CCF17;">位置实参</font>: <font style="color:#DF2A3F;">在调用函数时，按照从左到右的顺序依次定义实参，称为位置实参，</font>

<font style="color:#DF2A3F;">凡是按照这种形式定义的实参会按照从左到右的顺序与形参一一对应</font>

```python
def register(name,age,sex): #定义位置形参：name，age，sex，三者都必须被传值
    print('Name:%s Age:%s Sex:%s' %(name,age,sex))
register() #TypeError：缺少3个位置参数
```

<h2 id="zkI31"><font style="color:rgb(18, 18, 18);">2.2 关键字参数</font></h2>
<font style="color:#DF2A3F;">在调用函数时，实参可以是key=value的形式，称为关键字参数，</font>

凡是按照这种形式定义的实参，<font style="color:#DF2A3F;">可以完全不按照从左到右的顺序定义</font>，但仍能为指定的形参赋值

```python
def func(x,y):
    print(x,y)
func(y=1, x=2)  # 输出结果: 2 1
func(2,1)

```

<font style="background-color:#E746A4;">位置实参与关键字实参混合使用:</font>

<font style="color:#4861E0;">1、位置实参必须放在关键字实参之前</font>

<font style="color:#4861E0;">2、不同为同一个形参重复传值</font>

<h2 id="Hkzo8"><font style="color:rgb(18, 18, 18);">2.3 </font>默认参数(形参)</h2>
<font style="color:#DF2A3F;">在定义函数时，就已经为形参赋值</font>，这类形参称之为默认参数，意味着在调用阶段可以不用为其赋值

当函数有多个参数时，需要将值经常改变的参数定义成位置参数，而将值改变较少的参数定义成默认参数

```python
def func(x,y=3):
    print(x,y)
func(x=1)  # 输出结果： 1 3
func(x=1, y=4444)  # 输出结果： 1 4444




>>> def register(name,age,sex='male'): #默认sex的值为male
...     print('Name:%s Age:%s Sex:%s' %(name,age,sex))
...



# 例如编写一个注册学生信息的函数，如果大多数学生的性别都为男，那完全可以将形参gender定义成默认参数
def register(name,age,gender='男'):
    print(name,age,gender)
register('老四', 18)
register('老三', 19)
register('老二', 20)
register('老大', 21, gender='女')

# 输出结果
老四 18 男
老三 19 男
老二 20 男
老大 21 女
```

<font style="color:rgb(18, 18, 18);background-color:#E746A4;">需要注意：</font>

1. <font style="color:rgb(18, 18, 18);background-color:#2F8EF4;">默认参数必须在位置参数之后</font>
2. <font style="color:rgb(18, 18, 18);background-color:#2F8EF4;">默认参数的值仅在函数定义阶段被赋值一次</font>

```python
# 1、默认参数必须在位置参数之后
# 错误演示
def func(y=2,x):
    pass  # SyntaxError: non-default argument follows default argument
    
# 2、默认参数的值仅在'''函数定义阶段'''被赋值一次，准确的说被赋予的是值的内存地址。
# 示范1:
m=2
def func(x, y=m):  # y=>2的内存地址
    print(x,y)
m=33333333333333333
func(1)  # 输出的值: 1 2

# 示范2:
m = [11111,]

def func(x, y=m):  # y=>[111111,]的内存地址
    print(x,y)

m.append(333333)
func(1)  # 输出的值：1 [11111, 333333]

# 3、虽然默认值可以被指定为任意数据类型，但是不推荐使用可变类型。
# 函数最理想状态: 函数的调用只跟函数本身有关系，不受外界代码的影响。
def func(x,y,z, l=None):
    if l is None:
        l=[]
    l.append(x)
    l.append(y)
    l.append(z)
    print(l)

func(1,2,3)
func(4,5,6)

new_l = [111,222]
func(1,2,3,new_l)


```

<h2 id="q9fMO"><font style="color:rgb(18, 18, 18);">2.4 可变长度的参数（</font>_<font style="color:rgb(18, 18, 18);">与</font>_<font style="color:rgb(18, 18, 18);">*的用法）</font></h2>
<font style="color:#DF2A3F;">参数的长度可变指的是在调用函数时，实参的个数可以不固定</font>

而实参是用来为形参赋值的，所以对应着，针对溢出的实参必须有对应的形参来接收。

而在调用函数时，实参的定义无非是按位置或者按关键字两种形式，这就要求形参提供两种解决方案来分别处理两种形式的可变长度的参数



<h3 id="HdGEX"># 2.4.1 可变长度的<font style="color:#74B602;">位置参数</font></h3>
**I:**<font style="color:#01B2BC;"> *形参名</font>：<font style="color:#01B2BC;">用来接收溢出的位置实参，溢出的位置实参会被*保存成元组的格式然后赋值给紧跟其后的形参名</font>

<font style="color:#01B2BC;">                   *后跟的是可以是任意名字，但是规范写成args</font>



```python
def func(x,y,*z):
    print(x,y,z)
func(1,2,3,4,5,6)  # 输出结果：1 2 (3, 4, 5, 6)
```

**II:** <font style="color:#01B2BC;">*可以用在实参中，实参中带*，</font><font style="color:#DF2A3F;">先把*后的值打散成位置实参</font>

```python
def func(x,y,z):
    print(x,y,z)

func(*[11,22,33])  # ====> func(11,22,33)

l = [11,22,33]
func(*l)

```

 **III:** <font style="color:#01B2BC;">形参与实参中都带*</font>

```python
def func(x,y,*args):
    print(x,y,args)
func(1,2,3,4,5,6)  # 输出结果：1 2 (3, 4, 5, 6)
func(1,2,[3,4,5,6])  # 输出结果：1 2 ([3, 4, 5, 6],)
func(1,2,*[3,4,5,6])   # 输出结果：1 2 (3, 4, 5, 6)



def func(x,y,*args):
    print(x,y,args)
func(*'hello')  # 先把*后面打散成位置实参,输出结果: h e ('l', 'l', 'o')

```

案例1

```python
# 案例1
def my_sum(*args):
    res=0
    for item in args:
        res+=item
    return res
res=my_sum(1,2,3,4,5,6,7,8)
print(res)  # 输出结果： 36
```

<h3 id="m7Xf7"> 2.4.2 可变长度的<font style="color:#74B602;">关键字参数</font></h3>
**I:** <font style="color:#01B2BC;">**形参名： 用来接收溢出的关键字实参，**会将溢出的关键字实参保存成字典的形式，然后赋值给紧跟其后的形参名</font>

<font style="color:#01B2BC;">                      **后跟的是可以是任意名字，但是规范写成**kwargs</font>

```python
def func(x,y,**kwargs):
    print(x,y,kwargs)
func(1,y=2,a=1,b=2,c=3)  # 输出结果: 1 2 {'a': 1, 'b': 2, 'c': 3}
```

**<font style="color:#01B2BC;">II:</font>**<font style="color:#01B2BC;"> **可以用在实参中(**后跟的只能是字典)，实参中带**，</font><font style="color:#DF2A3F;">先把**后的值打散成关键字实参</font>

```python
 def func(x,y,z):
    print(x,y,z)

func(*{'x':1, 'y':2, 'z':3 })  # 输出结果：x y z
func(**{'x':1, 'y':2, 'z':3 })  #打散func(x=1,y=2,z=3) 输出结果：1 2 3

# 错误演示：
func(**{'x':1, 'y':2,})  # func(x=1,y=2) 少参报错
func(**{'x':1, 'a':2, 'z': 3})  # func(x=1,a=2, z=3) 在形参中没有定义a参数，所以报错。

```

**III:** <font style="color:#01B2BC;">形参与实参中都带**</font>

```python
def func(x,y,**kwargs):
    print(x,y,kwargs)

func(**{'x':111,'y':222, 'a':333, 'b': 444})  # 先打散保存成字典func(x=111,y=222,a=333,b=444) 输出结果:111 222 {'a': 333, 'b': 444}

```

<font style="color:#DF2A3F;">混用*与** : *args必须在**kwargs之前</font>

```python
def func(*args, **kwargs):
    print(args, kwargs)

func(1,2,3,4,5,6,7,8,a=11,b=22,c=33)  # 输出结果: (1, 2, 3, 4, 5, 6, 7, 8) {'a': 11, 'b': 22, 'c': 33}


def func(x,*args, **kwargs):
     print(x,args, kwargs)

func(1,2,3,4,5,6,7,8,a=11,b=22,c=33)  # 输出结果：1 (2, 3, 4, 5, 6, 7, 8) {'a': 11, 'b': 22, 'c': 33}


def index(x,y,z):
    print('index===>',x,y,z)  ## 输出结果: index===> 1 2 3

def wrapper(a,b,c):  # a=1 b=2 c=3
    index(a,b,c)  # index(1,2,3)

wrapper(1,2,3)  # 为wrapper传的参数是给index用的

# 注意：python中所有值的传递，传递的都不是值本身，而是值的引用，即内存地址
```

<h2 id="YStNS"><font style="color:rgb(18, 18, 18);">2.5 命名关键字参数(了解)</font></h2>
在定义函数时，*后面定义的参数，如下所示，称之为命名关键字参数。

特点：

1）、命名关键字实参必须按照key=value的形式为其传值

```python
def func(x,y,*,a,b):  # 其中 a和b 称之为命名关键字参数
    print(x,y)
    print(a,b)

# func(1,2,111,222)  # 报错：TypeError: func() takes 2 positional arguments but 4 were given
func(1,2,a=111,b=222)
# 输出结果：
1 2
111 222
```

```python
# 示例
# 如果给默认命名关键字参数赋值了，就可以用了。
def func(x,y,*,a=11111,b):  # b=222 为命名关键字参数赋了个值
    print(x,y)
    print(a,b)

func(1,2,b=2222)

# 输出结果
1 2
11111 2222
```

<h2 id="CcIus">2.6 组合使用（了解）</h2>
1）形参混用的位置顺序： 位置形参，默认形参, *args, 命名关键字形参， **kwargs

```python
def func(x,y=111,*args,z,**kwargs):
    print(x)
    print(y)
    print(args)
    print(z)
    print(kwargs)

```

2）实参混用的位置顺序：

```python
def func(x,y,z,a,b,c):
    print(x)
    print(y)
    print(z)
    print(a)
    print(b)
    print(c)


# func(111,y=222,*[333,444],**{'b':555, 'c':666})
# func(111,y=222,333,444,b=555,c=666)

func(111,*[333,444],a=222,**{'b':555,'c': 666})
# func(111,333,444,a=222,b=555,c=666)

# 碰见*或者**，首先打散，遵循原则就是位置实参在关键字实参的左边。
# 输出结果：
111
333
444
222
555
666
```

参考文章：[https://zhuanlan.zhihu.com/p/108907210](https://zhuanlan.zhihu.com/p/108907210)

