<img width="720" height="426" alt="image" src="https://github.com/user-attachments/assets/d001ea0f-d476-4e27-abed-5182b641baf4" />

<h1 id="YocXN">一、<font style="color:rgb(18, 18, 18);">面向过程与函数式</font></h1>
<font style="color:rgb(18, 18, 18);"> 面向过程“核心是“过程”二字，“过程”指的是解决问题的步骤，即先干什么再干什么......，基于面向过程开发程序就好比在设计一条流水线，是一种机械式的思维方式，这正好契合计算机的运行原理：任何程序的执行最终都需要转换成cpu的指令流水按过程调度执行，即无论采用什么语言、无论依据何种编程范式设计出的程序，最终的执行都是过程式的。</font>

![](https://cdn.nlark.com/yuque/0/2023/jpeg/25700096/1680254824486-6e99cad2-1767-4cd0-8539-04cbc143ff84.jpeg)

<font style="color:rgb(18, 18, 18);"></font><font style="color:rgb(18, 18, 18);">详细的，若程序一开始是要着手解决一个大的问题，按照过程式的思路就是把这个大的问题分解成很多个小问题或子过程去实现，然后依次调用即可，这极大地降低了程序的复杂度。举例如下：</font>

<font style="color:rgb(18, 18, 18);">写一个数据远程备份程序，分三步：本地数据打包，上传至云服务器，检测备份文件可用性</font>

```python

import os,time

# 一：基于本章所学，我们可以用函数去实现这一个个的步骤
# 1、本地数据打包
def data_backup(folder):
    print("找到备份目录: %s" %folder)
    print('正在备份...')
    zip_file='/tmp/backup_%s.zip' %time.strftime('%Y%m%d')
    print('备份成功，备份文件为: %s' %zip_file)
    return zip_file

#2、上传至云服务器
def cloud_upload(file):
    print("\nconnecting cloud storage center...")
    print("cloud storage connected")
    print("upload [%s] to cloud..." %file)
    link='https://www.xxx.com/bak/%s' %os.path.basename(file)
    print('close connection')
    return link

#3、检测备份文件可用性
def data_backup_check(link):
    print("\n下载文件: %s , 验证文件是否无损..." %link)


#二：依次调用
# 步骤一：本地数据打包
zip_file = data_backup(r"/Users/egon/欧美100G高清无码")

# 步骤二：上传至云服务器
link=cloud_upload(zip_file)

# 步骤三：检测备份文件的可用性
data_backup_check(link)

```

<h3 id="XC5Iu"><font style="color:rgb(18, 18, 18);">面向过程总结：</font></h3>
<font style="color:rgb(18, 18, 18);">1、优点</font>

<font style="color:rgb(18, 18, 18);">将复杂的问题流程化，进而简单化</font>

<font style="color:rgb(18, 18, 18);">2、缺点: </font>拓展性非常差

```python

'''
程序的可扩展性极差，因为一套流水线或者流程就是用来解决一个问题，就好比生产汽水的流水线无法生产汽车一样，即便是能，也得是大改，而且改一个组件，与其相关的组件可能都需要修改，比如我们修改了cloud_upload的逻辑，那么依赖其结果才能正常执行的data_backup_check也需要修改，这就造成了连锁反应，而且这一问题会随着程序规模的增大而变得越发的糟糕。
'''

def cloud_upload(file): # 加上异常处理，在出现异常的情况下，没有link返回
    try:
        print("\nconnecting cloud storage center...")
        print("cloud storage connected")
        print("upload [%s] to cloud..." %file)
        link='https://www.xxx.com/bak/%s' %os.path.basename(file)
        print('close connection')
        return link
    except Exception:
        print('upload error')
    finally:
        print('close connection.....')

def data_backup_check(link): # 加上对参数link的判断
    if link:
        print("\n下载文件: %s , 验证文件是否无损..." %link)
    else:
        print('\n链接不存在')
```

<font style="color:rgb(18, 18, 18);">3、应用场景</font>

面向过程的程序设计一般用于那些功能一旦实现之后就很少需要改变的场景， 如果你只是写一些简单的脚本，去做一些一次性任务，用面向过程去实现是极好的，但如果你要处理的任务是复杂的，且需要不断迭代和维护， 那还是用面向对象最为方便。

<h3 id="ZjmI7">面向过程的编程思想应用场景解析:</h3>
1、不是所有的软件都需要频繁更新   比如:编写脚本

2、即便是一个软件需要频繁更迭，也并不代表这个软件所有的部分都需要一起更迭



<h2 id="JYzUC"><font style="color:rgb(18, 18, 18);">二、 函数式</font></h2>
<font style="color:rgb(18, 18, 18);">函数式编程并非用函数编程这么简单，而是将计算机的运算视为数学意义上的运算，比起面向过程，函数式更加注重的是执行结果而非执行的过程，代表语言有：Haskell、Erlang。而python并不是一门函数式编程语言，但是仍为我们提供了很多函数式编程好的特性，如lambda，map，reduce，filter</font>

<h2 id="tr5Xb"><font style="color:rgb(18, 18, 18);">2.1 匿名函数与lambda</font></h2>
<font style="color:rgb(18, 18, 18);"> 对比使用def关键字创建的是有名字的函数，使用lambda关键字创建则是没有名字的函数，即匿名函数，语法如下</font>

lambda 参数1,参数2,...: expression

```python

# 1、def用于定义有名函数
func=函数的内存地址
def func(x,y):
    return x+y
print(func)  # <function func at 0x01BB45D0>

# 2、lambda用于定义匿名函数
print(lambda x,y:x+y)  # <function <lambda> at 0x01BB4540>

# 3、调用匿名函数
# 方式一:
res=(lambda x,y:x+y)(1,2)
print(res)  # 3
# 方式二:
func=lambda x,y:x+y
res=func(1,2)
print(res)  # 3

# 4、匿名函数用于临时调用一次的场景：更多的是将匿名函数与其他函数配合使用
# 匿名函数不用写名字，不用写return，该有的参数还是要有。
lambda x,y:x+y

```

<font style="color:rgb(18, 18, 18);">匿名函数与有名函数有相同的作用域，但是匿名意味着引用计数为0，使用一次就释放，所以匿名函数用于临时使用一次的场景，匿名函数通常与其他函数配合使用，我们以下述字典为例来介绍它</font>

```python

salaries={
    'siry':3000,
    'tom':7000,
    'lili':10000,
    'jack':2000
}

```

<font style="color:rgb(18, 18, 18);">要想取得薪水的最大值和最小值，我们可以使用内置函数max和min（为了方便开发，python解释器已经为我们定义好了一系列常用的功能，称之为内置的函数，我们只需要拿来使用即可）</font>

```python

>>> max(salaries)
'tom'
>>> min(salaries)
'jack'

```

<font style="color:rgb(18, 18, 18);">内置max和min都支持迭代器协议，工作原理都是迭代字典，取得是字典的键，因而比较的是键的最大和最小值，而我们想要的是比较值的最大值与最小值，于是做出如下改动</font>

```python

# 函数max会迭代字典salaries，每取出一个“人名”就会当做参数传给指定的匿名函数，然后将匿名函数的返回值当做比较依据，最终返回薪资最高的那个人的名字
>>> max(salaries,key=lambda k:salaries[k]) 
'lili'
# 原理同上
>>> min(salaries,key=lambda k:salaries[k])
'jack'

```

<font style="color:rgb(18, 18, 18);">同理，我们直接对字典进行排序，默认也是按照字典的键去排序的</font>

```python

>>> sorted(salaries)
['jack', 'lili', 'siry', 'tom']

```

```python

salaries={
    'siry':3000,
    'tom':7000,
    'lili':10000,
    'jack':2000
}

# 需求1：找出薪资最高的那个人
res=max([3,200,11,300,399])
print(res)  # 399
res=max(salaries)
print(res)  # tom


# 迭代出的内容       比较的值
# 'siry'              3000
# 'tom'               7000
# 'lili'              10000
# 'jack'              2000
# =============================================max的应用
# 补充：max的原理就是迭代对象，得到一个个值，并把它返回。
# key的工作原理要指定函数，函数要有一个参数，参数来自于函数迭代得到的值
salaries={
    'siry':3000,
    'tom':7000,
    'lili':10000,
    'jack':2000
}
def func(k):
    return salaries[k]


res=max(salaries,key=func)  # 返回值=func('siry')
print(res)  # lili


# 匿名函数的应用
salaries={
    'siry':3000,
    'tom':7000,
    'lili':10000,
    'jack':2000
}
res=max(salaries,key=lambda k:salaries[k])  # 返回值=func('siry')
print(res)  # lili

# 示例1
salaries={
    'siry':3000,
    'tom':7000,
    'lili':10000,
    'jack':2000
}
res=sorted(salaries)
print(res)  # ['jack', 'lili', 'siry', 'tom'],其实是按照字符串的大小去排序的。


# 示例2：======================sortrd排序的应用
# 排序是人名，比较依据是薪资

salaries={
    'siry':3000,
    'tom':7000,
    'lili':10000,
    'jack':2000
}
res=sorted(salaries,key=lambda k:salaries[k])
print(res)  # [['jack', 'siry', 'tom', 'lili'] ,按照薪资排名

```

<h2 id="fuaPn">2.2 <font style="color:rgb(18, 18, 18);">map、reduce、filter</font></h2>

```python

# 1、===================================================map的应用(了解)
l=['alex','egon','tom','jason']
new_l=[name+'_dsb' for name in l]
print(new_l)  # ['alex_dsb', 'egon_dsb', 'tom_dsb', 'jason_dsb']

# 如果数据量过大，用列表生成式就不合适了，所以采用()
l=['alex','egon','tom','jason']
new_l=(name+'_dsb' for name in l)
print(new_l)  # <generator object <genexpr> at 0x019DF300>

# map第一个参数是函数，第二个参数是可迭器对象
l=['alex','egon','tom','jason']
res=map(lambda name:name+'_dsb',l)
print(res)  # <map object at 0x020604D0>  返回是一个生成器
res.__iter__()
res.__next__()

#2、==================================================filter应用（了解）
l=['alex_dsb','egon_dsb','tom','jason']
res=[name for name in l if name.endswith('dsb')]
print(res)  # ['alex_dsb', 'egon_dsb']


# 如果数据量过大，用列表生成式就不合适了，所以采用()
l=['alex_dsb','egon_dsb','tom','jason']
res=(name for name in l if name.endswith('dsb'))
print(res)  # <generator object <genexpr> at 0x01A0F300>

# filter第一个参数是函数，第二个参数是可迭器对象
l=['alex_dsb','egon_dsb','tom','jason']
res=filter(lambda name:name.endswith('dsb'),l)
print(res)  # <filter object at 0x018B04F0>
res.__iter__()
res.__next__()

# 3、 ======================================reduce的应用（了解）
from functools import reduce
res=reduce(lambda x,y:x+y,[1,2,3],10)
print(res)  # 16

res=reduce(lambda x,y:x+y,['a','b','c'],'hello')
print(res)  # helloabc


res=reduce(lambda x,y:x+y,['a','b','c'])
print(res)  # abc

```

参考链接：[https://zhuanlan.zhihu.com/p/109125933](https://zhuanlan.zhihu.com/p/109125933)

