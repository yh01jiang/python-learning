<h2 id="e4Jsh"><font style="color:rgb(25, 27, 31);">一 元类介绍</font></h2>


<font style="color:rgb(25, 27, 31);">什么是元类呢？一切源自于一句话：python中一切皆为对象。让我们先定义一个类，然后逐步分析</font>

<font style="color:rgb(25, 27, 31);"></font>

```python
class People:

    def __init__(self,name,age):
        self.name=name
        self.age=age

    def say(self):
        print('%s:%s' %(self.name,self.age))


obj=People('egon', 38)
print(obj.__dict__)  # {'name': 'egon', 'age': 38}
print(type(obj))  # <class '__main__.People'>

print(type(People))  # <class 'type'>


print(type(int))  # <class 'type'>  默认的type就是元类

推导出
People=元类(...)

```

<font style="color:rgb(25, 27, 31);">所有的对象都是实例化或者说调用类而得到的（调用类的过程称为类的实例化），比如对象obj是调用类People得到的</font>

<font style="color:rgb(25, 27, 31);">如果一切皆为对象，那么类People本质也是一个对象，既然所有的对象都是调用类得到的，那么StanfordTeacher必然也是调用了一个类得到的，这个类称为元类</font>

**<font style="color:rgb(25, 27, 31);">于是我们可以推导出===>产生People的过程一定发生了：People=元类(...)</font>**

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1702023639190-6731fc91-0fb8-48be-a762-69c2825f4978.png)

**<font style="color:rgb(25, 27, 31);"></font>**

<h2 id="aNR78"><font style="color:rgb(25, 27, 31);">二 class关键字创建类的流程分析</font></h2>
```python
# 类的三大特征
# 1. 类名
class_name="People"

# 2. 类的父类
class_bases=(object,)

# 3. 执行类体代码拿到类的名称空间
class_dic={}
class_body="""
def __init__(self,name,age):
    self.name=name
    self.age=age

def say(self):
    print('%s:%s' %(self.name,self.age))
"""

exec(class_body, {}, class_dic)
# print(class_dic)  # {'__init__': <function __init__ at 0x1044581f0>, 'say': <function say at 0x1044f8940>}

# 4. 调用元类得到类
print(type(class_name,class_bases,class_dic))  # <class '__main__.People'>

# 调用type时会依次传入以上三个参数
People=type(class_name,class_bases,class_dic)


obj=People('egon',18)
print(obj.__dict__)  # {'name': 'egon', 'age': 18}

print(obj.name)  # egon
```

<font style="color:rgb(25, 27, 31);">综上，class关键字帮我们创建一个类应该细分为以下四个过程</font>

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1702023800444-279ed404-d69c-41f3-83b0-e9782238db4d.png)



<h2 id="Dm1OO"><font style="color:rgb(25, 27, 31);">三 自定义元类控制类StanfordTeacher的创建</font></h2>
<font style="color:rgb(25, 27, 31);">一个类没有声明自己的元类，默认他的元类就是type，除了使用内置元类type，我们也可以通过继承type来自定义元类，然后使用</font><font style="color:#DF2A3F;">metaclass关键字参数为一个类指定元类</font>

```python
class Mymeta(type):  # 只有继承了type类的才是元类
          #      空对象,People",(object),{...}
    def __init__(self,x,y,z):  # 其实x y z 就是class_name,class_bases,class_dic，只是为了好区分，就是一个变量
        print('run.....')
        print(self)
        print(x)
        print(y)
        print(z)

# 类的产生过程其实就是元类的调用过程
# People=Mymeta(class_name,class_bases,class_dic)  ====》 其实是这样的：People=Mymeta("People",(object),{...})
# 调用Mymeta（元类）发生的三件事：
# 1. 先造一个空对象==》People
# 2. 调用Mymeta类中的__init__方法，完成初始化对象的操作
# 3. 返回初始化好的对象

class People(metaclass=Mymeta):

    def __init__(self,name,age):
        self.name=name
        self.age=age

    def say(self):
        print('%s:%s' %(self.name,self.age))


# 输出：
# run.....
# <class '__main__.People'>
# People
# ()
# {'__module__': '__main__', '__qualname__': 'People', '__init__': <function People.__init__ at 0x104338a60>, 'say': <function People.say at 0x104338af0>}




# 案例
# 必须类名首字母大写
class Mymeta(type):  # 只有继承了type类的才是元类
          #      空对象,People",(object),{...}
    def __init__(self,x,y,z):  # 其实x y z 就是class_name,class_bases,class_dic，只是为了好区分，就是一个变量
        if not x.istitle():
            raise NameError('类名首字母必须大写。。。')
        # print('run.....')
        # print(self)
        # print(x)
        # print(y)
        # print(z)


class People(metaclass=Mymeta):  # metaclass关键字参数为一个类指定元类

    def __init__(self,name,age):
        self.name=name
        self.age=age

    def say(self):
        print('%s:%s' %(self.name,self.age))

# 输出
# 如果类名是people，就会主动抛出错误：
# Traceback (most recent call last):
#   File "/Users/jiangyuanhao/Desktop/project-demo/python-demo/day28/10 元类.py", line 110, in <module>
#     class people(metaclass=Mymeta):
#   File "/Users/jiangyuanhao/Desktop/project-demo/python-demo/day28/10 元类.py", line 102, in __init__
#     raise NameError('类名首字母必须大写。。。')
# NameError: 类名首字母必须大写。。。

# 如果类名是People: 就不会有报错
```

<h3 id="xvLLT">**__new__	方法**</h3>
```python
# __new__  是产生一个空对象，是早于__init__ 产生的

class Mymeta(type):  # 只有继承了type类的才是元类
          #      空对象,People",(object),{...}
    def __init__(self,x,y,z):  # 其实x y z 就是class_name,class_bases,class_dic，只是为了好区分，就是一个变量
        if not x.istitle():
            raise NameError('类名首字母必须大写。。。')
        print(y)  # y就是People的基类  # 输出 ()
        print(self.__bases__)  # (<class 'object'>,)
    # def __new__(cls,*args,**kwargs):
    #     pass


# # People=Mymeta(class_name,class_bases,class_dic)  ====》 其实是这样的：People=Mymeta("People",(object),{...})
# # 调用Mymeta(元类)发生的三件事：
# # 1. 先造一个空对象==》People===> 调用类内的__new__ 方法
# # 2. 调用Mymeta类中的__init__方法，完成初始化对象的操作
# # 3. 返回初始化好的对象

class People(metaclass=Mymeta):

    def __init__(self,name,age):
        self.name=name
        self.age=age

    def say(self):
        print('%s:%s' %(self.name,self.age))






class Mymeta(type):  # 只有继承了type类的才是元类
          #      空对象,People",(object),{...}
    def __init__(self,x,y,z):  # 其实x y z 就是class_name,class_bases,class_dic，只是为了好区分，就是一个变量
        if not x.istitle():
            raise NameError('类名首字母必须大写。。。')
        print('run222222')
        # print(y)  # y就是People的基类  # 输出 ()
        # print(self.__bases__)  # (<class 'object'>,)

        # 注意： 当前所在的类，调用类所传的参数
    def __new__(cls,*args,**kwargs):
        print('run 11111.')
        # 造Mymeta的对象
        # print('run11111...')  # run11111...
        # print(cls,args,kwargs)  # <class '__main__.Mymeta'> People () {'__module__': '__main__', '__qualname__': 'People', '__init__': <function People.__init__ at 0x102bf8af0>, 'say': <function People.say at 0x102bf8b80>}
        # return super().__new__(cls,*args,**kwargs)  # 从父类去找方式1:
        return type.__new__(cls,*args,**kwargs)       # 从父类去找方式2:
        # 会将这个对象cls,*args,**kwargs 传给__init__

# # People=Mymeta(class_name,class_bases,class_dic)  ====》 其实是这样的：People=Mymeta("People",(object),{...})
# # 调用Mymeta(元类)发生的三件事：
# # 1. 先造一个空对象==》People===> 调用类内的__new__ 方法
# # 2. 调用Mymeta类中的__init__方法，完成初始化对象的操作
# # 3. 返回初始化好的对象

class People(metaclass=Mymeta):

    def __init__(self,name,age):
        self.name=name
        self.age=age

    def say(self):
        print('%s:%s' %(self.name,self.age))



# 强调：
# 只要是调用类，那么就会依次调用：
# 1. 类内的__new__
# 2. 类内的__init__
```



**__call__	方法**

```python
# __call__  方法

# 引入
class Foo:
    def __init__(self,x,y):
        self.x=x
        self.y=y


obj=Foo(111,333)
print(obj.__dict__)
obj()  # 这样直接调用obj对象报错：TypeError: 'Foo' object is not callable，怎么解决呢？这时候就需要介入于__call__  方法解决


class Foo:
    def __init__(self,x,y):
        self.x=x
        self.y=y

    def __call__(self):
        print('====>')
        return  123


obj=Foo(111,333)
print(obj) # obj.__str__
res=obj()    # res=obj.__call__() (返回的NOne，也就是说明打印obj的返回值，其实几件事obj.__call__的返回值，例如返回123)
print(res)   # 123




# __call__ 的应用： 如果想让一个对象可以加()调用，需要在该对象的类中添加一个方法__call__

 
class Foo:
    def __init__(self,x,y):
        self.x=x
        self.y=y

                #obj 1,2,3,a=2,b=3
    def __call__(self,*args,**kwargs):
        print('====>', args, kwargs)  # ====> (1, 2, 3) {'a': 2, 'b': 3}
        return  1234567890


# 调用Foo就是在调用Foo类中的__call__方法
# 然后将Foo传给self,溢出的位置参数传给*，溢出的关键字参数传给**
# 调用Foo的返回值就是调用__call__的返回值

obj=Foo(111,333)
res=obj(1,2,3,a=2,b=3)   # res=obj.__call__()
print(res)  # 1234567890


# 总结

对象() ===> 类内的__call__
类() ====> 自定义元类的__call__
自定义元类() =====> 内置元类的__call__


#默认地，调用obj=People(111,333)会做三件事

1、产生一个空对象obj

2、调用__init__方法初始化对象obj

3、返回初始化好的obj



```

```python
# 由上例得知，调用一个对象，就是触发对象所在类中的__call__方法的执行，如果把People也当做一个对象，那么在People这个对象的类中也必然存在一个__call__方法


# 6. 自定义元类控制类的调用：===》类的对象的产生
class Mymeta(type):  # 只有继承了type类的才是元类

    def __init__(self,x,y,z):  
        print('run222222。。。。')

    def __new__(cls,*args,**kwargs):
        print('run 11111.。。。。')
        # return super().__new__(cls,*args,**kwargs)  
        return type.__new__(cls,*args,**kwargs)     


# 一 类的产生：
# People=Mymeta() ==> type.__call__===>干了三件事：
# 1. type.__call__函数内会先调用Mymeta内的__new__
# 2. type.__call__函数内会先调用Mymeta内的__init__
# 3.  type.__call__函数内返回一个初始化好的对象
class People(metaclass=Mymeta):

    def __init__(self,name,age):
        self.name=name
        self.age=age

    def say(self):
        print('%s:%s' %(self.name,self.age))






### 示例

class Mymeta(type):  # 只有继承了type类的才是元类

    def __call__(self,*args,**kwargs):

        # 1. Mymeta.__call__函数内会先调用People内的__new__
        people_obj=self.__new__(self)
        # 2. Mymeta.__call__函数内会先调用People内的__init__
        self.__init__(people_obj,*args,**kwargs)
        
        print('people对象属性： ', people_obj.__dict__)  # people对象属性：  {'name': 'egon', 'age': 18}
        people_obj.__dict__['xxxxx']=1111111
        # 3. Mymeta.__call__函数内返回一个初始化好的对象
        return people_obj
        # print(self)  # <class '__main__.People'>
        # print(args)  # ('egon', 18)
        # print(kwargs)  # {}
        # return 123456



# 一 类的产生：
# People=Mymeta() ==> type.__call__===>干了三件事：
# 1. type.__call__函数内会先调用Mymeta内的__new__
# 2. type.__call__函数内会先调用Mymeta内的__init__
# 3.  type.__call__函数内返回一个初始化好的对象
class People(metaclass=Mymeta):

    def __init__(self,name,age):
        self.name=name
        self.age=age

    def say(self):
        print('%s:%s' %(self.name,self.age))

    # 产生真正的对象
    def __new__(cls,*args,**kwargs):
        return object.__new__(cls)

# 二 类的调用
# obj=People('egon',18)  ==》Mymeta.__call__ ===》 干了三件事
# 1. Mymeta.__call__函数内会先调用People内的__new__
# 2. Mymeta.__call__函数内会先调用People内的__init__
# 3. Mymeta.__call__函数内返回一个初始化好的对象


# obj=People('egon',18)

# # print(obj) 
# print(obj.__dict__)  # {'name': 'egon', 'age': 18}

obj1=People('egon', 18)
obj2=People('egon',20)

print(obj1.__dict__)
print(obj2.__dict__)

# 输出
{'name': 'egon', 'age': 18, 'xxxxx': 1111111}
{'name': 'egon', 'age': 20, 'xxxxx': 1111111}
```

<h2 id="seMNM"><font style="color:rgb(25, 27, 31);">再看属性查找</font></h2>
<font style="color:rgb(25, 27, 31);">在学习完元类后，其实我们用class自定义的类也全都是对象（包括object类本身也是元类type的 一个实例，可以用type(object)查看），我们学习过继承的实现原理，如果把类当成对象去看，将下述继承应该说成是：对象StanfordTeacher继承对象Foo，对象Foo继承对象Bar，对象Bar继承对象object</font>

```python
class Mymeta(type): #只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类
    n=444


class Bar(object):
    n=333

class Foo(Bar):
    n=222

class StanfordTeacher(Foo,metaclass=Mymeta):
    n=111

    school='Stanford'

    def __init__(self,name,age):
        self.name=name
        self.age=age

    def say(self):
        print('%s says welcome to the Stanford to learn Python' %self.name)



# 按对象查找
obj=StanfordTeacher('egon',18)
print(obj.n)  # 查找顺序：StanfordTeacher->Foo->Bar->object 如果object没有的就找不到了
```



<font style="color:rgb(25, 27, 31);">于是属性查找应该分成两层，一层是对象层（基于c3算法的MRO）的查找</font>

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1702527617991-b5bb9979-7f28-4eba-9966-69265474150b.png)



```python
class Mymeta(type): #只有继承了type类才能称之为一个元类，否则就是一个普通的自定义类
    n=444


class Bar(object):
    n=333

class Foo(Bar):
    n=222

class StanfordTeacher(Foo,metaclass=Mymeta):
    n=111

    school='Stanford'

    def __init__(self,name,age):
        self.name=name
        self.age=age

    def say(self):
        print('%s says welcome to the Stanford to learn Python' %self.name)



# 按类的查找
# print(StanfordTeacher.n)
print(StanfordTeacher.n) #自下而上依次注释各个类中的n=xxx，然后重新运行程序，发现n的查找顺序为StanfordTeacher->Foo->Bar->object->Mymeta->type
```

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1702527686655-7f3d0a85-554f-4cd0-9af4-60f2f2cc9f2c.png)





```python
class Mymeta(type): 
    n=444
                # self指的是Mymeta对象，Mymeta的对象就是StanfordTeacher
    def __call__(self, *args, **kwargs): #self=<class '__main__.StanfordTeacher'>
        obj=self.__new__(self)  # 推荐使用这种方式   # StanfordTeacher.__new__
        # obj=object.__new__(self)  # 不推荐这种方式
        # print(self.__new__ is object.__new__) #True
        self.__init__(obj,*args,**kwargs)
        return obj


class Bar(object):
    n=333

    # def __new__(cls, *args, **kwargs):
    #     print('Bar.__new__')

class Foo(Bar):
    n=222

    # def __new__(cls, *args, **kwargs):
    #     print('Foo.__new__')

class StanfordTeacher(Foo,metaclass=Mymeta):
    n=111

    school='Stanford'

    def __init__(self,name,age):
        self.name=name
        self.age=age

    def say(self):
        print('%s says welcome to the Stanford to learn Python' %self.name)


    def __new__(cls, *args, **kwargs):
    #     print('StanfordTeacher.__new__')
        return object.__new__(cls)


obj=StanfordTeacher('lili',18) #触发StanfordTeacher的类中的__call__方法的执行，进而执行self.__new__开始查找
print(obj.__dict__)
```

<font style="color:rgb(25, 27, 31);">总结，Mymeta下的__call__里的self.__new__在StanfordTeacher、Foo、Bar里都没有找到__new__的情况下，会去找object里的__new__，而object下默认就有一个__new__，所以即便是之前的类均未实现__new__,也一定会在object中找到一个，根本不会、也根本没必要再去找元类Mymeta->type中查找__new__</font>

<font style="color:rgb(25, 27, 31);"></font>

<font style="color:rgb(25, 27, 31);"></font>

参考文章：[https://zhuanlan.zhihu.com/p/109336845](https://zhuanlan.zhihu.com/p/109336845)

