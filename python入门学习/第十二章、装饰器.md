![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1679990147743-faf8b516-421d-4fea-9543-e7758ef3f926.png)

<h2 id="Sr9pp"><font style="color:rgb(18, 18, 18);">一 装饰器介绍</font></h2>
<h2 id="zfHN0">1.1 什么是装饰器？</h2>

```python

"""
器指的是工具，可以定义成函数
    装饰指的是为其他事物添加额外的东西点缀

    合到一起的解释：
        装饰器指的定义一个函数，该函数是用来为其他函数添加额外的功能
"""

```

<h2 id="YIFbQ"><font style="color:rgb(18, 18, 18);">1.2 为何要用装饰器</font></h2>

```python

'''
开放封闭原则
        开放：指的是拓展功能是开放的
        封闭：指的是对修改源代码是封闭的
    装饰器就是在不修改被装饰对象源代码以及调用方式的前提下，未被装饰对象添加新功能。
'''




Python 3.6.8 (tags/v3.6.8:3c6b436a57, Dec 23 2018, 23:31:17) [MSC v.1916 32 bit (Intel)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> import time
>>> time.time()
1679925108.0940278
>>> time.sleep(3)
>>> start=time.time()
>>> time.sleep(3)
>>> stop=time.time()
>>> stop - start
17.41496443748474

```



<h2 id="Mup37"><font style="color:rgb(18, 18, 18);">二 装饰器的实现</font></h2>
<h3 id="Rxkxc"><font style="background-color:#FBDE28;">2.1 需求： 在不修改index函数的源代码以及调用方式前提下,为提添加代码运行时间的功能（无参装饰器）</font></h3>

```python

def index(x,y):
    time.sleep(3)
    print('index %s %s' %(x,y))

index(111,222)

```

解决方案一：

```python

# 解决方案一： 失败
# 问题：没有修改被装饰对象的调用方式，但是修改了源代码
import time
def index(x,y):
    start=time.time()
    time.sleep(3)
    print('index %s %s' %(x,y))
    stop=time.time()
    print(stop - start )

index(111,222)
# 输出结果：
index 111 222d
3.0093908309936523

```

#### 解决方案二：

```python

# 解决方案二：
# 问题：没有修改被装饰对象的调用方式，也没有修改了源代码，并且加上了新功能，但是代码冗余。
import time
def index(x,y):
    time.sleep(3)
    print('index %s %s' %(x,y))

start=time.time()
index(111,222)
stop=time.time()
print(stop - start)

```

解决方案三：

```python

# 问题：解决了方案二的代码冗余问题，但是带来一个新的问题，即函数的调用方式
import time
def index(x,y):
    time.sleep(3)
    print('index %s %s' %(x,y))
def wrapper():
    start=time.time()
    index(111,222)
    stop=time.time()
    print(stop - start)

wrapper()

```

#### 方案三的优化0：

```python

# 方案三的优化0：
import time
def index(x,y):
    time.sleep(3)
    print('index %s %s' %(x,y))
def wrapper(a,b):  # a=111,b=222
    start=time.time()
    index(a,b)  # index(111,222)
    stop=time.time()
    print(stop - start)

wrapper(333,444)

```



#### 方案三的优化1：把index的参数写活了

```python

# 方案三的优化1：把index的参数写活了
import time
def index(x,y,z):
    time.sleep(3)
    print('index %s %s %s' %(x,y,z))
def wrapper(*args,**kwargs):
    start=time.time()
    index(*args,**kwargs)
    stop=time.time()
    print(stop - start)

wrapper(333,444,555)
wrapper(3333,y=4444,z=5555)
# 输出结果：
index 333 444 555
3.0126049518585205
index 3333 4444 5555
3.0091922283172607

```

方案三的优化2：在优化1的基础上，把被装饰对象写活了，原来只能装饰index

```python

# 方案三的优化2：在优化1的基础上，把被装饰对象写活了，原来只能装饰index
import time
def index(x,y,z):
    time.sleep(3)
    print('index %s %s %s' %(x,y,z))
print(index)  # <function index at 0x023345D0>
def outter(func):
    # func=index的内存地址
    def wrapper(*args,**kwargs):
        start=time.time()
        func(*args,**kwargs)  # index内存地址()
        stop=time.time()
        print(stop - start)
    return wrapper  # 其实就是为了扔到全局，因为当初wrapper是全局，现在缩进了函数内。

index=outter(index)  # f=outter(index的内存地址)---》后续会有语法糖的介绍
print(index)  # <function outter.<locals>.wrapper at 0x01D0B660>
# f=当初那个wrapper函数的内存地址
index(11,22,33)
index(x=1,y=2,z=3)

```

#### 方案三的优化3：将wrapper做的跟被装饰对象一模一样，以假乱真。

```python

# 方案三的优化3：将wrapper做的跟被装饰对象一模一样，以假乱真。
import time
def index(x,y,z):
    time.sleep(3)
    print('index %s %s %s' %(x,y,z))

def home(name):
    time.sleep(2)
    print('welcome %s to  home page' %name)
    return 123  # 3.假设原函数有返回值

def outter(func):
    # func=index的内存地址
    def wrapper(*args,**kwargs):  # 接收任意参数
        start=time.time()
        res=func(*args,**kwargs)  # 将home的返回值伪装成wrapper的返回值，# 1. 调用原函数并保存返回值
        stop=time.time()
        print(stop - start)  
        return res                # 2. 返回原函数的返回值
    return wrapper  # 其实就是为了扔到全局，因为当初wrapper是全局，现在缩进了函数内。
# 偷梁换柱：home这个名字指向的wrapper函数的内存地址
home=outter(home)
res=home('egon')  # res=wrapper('egon')
print('返回值==》',res)  # 返回值==》 123

```

<img width="734" height="195" alt="image" src="https://github.com/user-attachments/assets/0e47b32d-5221-4025-bb2a-717dcf470d62" />

'''
1. res = func(*args, **kwargs)

调用原函数：执行被装饰的原函数 index。
保存返回值：将 index() 的返回值（例如 100）赋值给变量 res。
(若不保存返回值，原函数的输出结果会丢失！)

2. return res

返回原函数的结果：确保装饰后的 index() 的返回值与原函数一致。
(若省略这一步，index() 将返回 None！)

'''



#### 解决方案四：如何在方案三的基础上不改变函数的调用方式

```python

# 解决方案四：如何在方案三的基础上不改变函数的调用方式
#

"""
语法糖的定义

"""
import time
# 装饰器
def timmer(func):            
    # func=index的内存地址
    def wrapper(*args,**kwargs):  # 接收任意参数
        start=time.time()
        res=func(*args,**kwargs)  # 1. 调用原函数并保存返回值
        stop=time.time()
        print(stop - start)
        return res  # 2. 返回原函数的返回值
    return wrapper


# 在被装饰对象正上方的单独一行写@装饰器名字
@timmer  # index=timmer(index)
def index(x,y,z):
    time.sleep(3)
    print('index %s %s %s' %(x,y,z))

@timmer  # home=timmer(home)
def home(name):
    time.sleep(2)
    print('welcome %s to  home page' %name)
    return 123

# 调用函数
index(x=1,y=2,z=3)
home('egon')

```

<h2 id="Uzq5B">2.2总结：无参装饰器的模板</h2>

```python

def outter(func):
    def wrapper(*args,**kwargs):
        1、调用原函数
        2、为其增加新功能
        res=func(*args,**kwargs)
        return res
    return wrapper


# 简单示例
def timmer(func):
    def wrapper(*args, **kwargs):
        res = func(*args, **kwargs)
        return res
    return wrapper

def index():
    print('from index')

index()


### 逐行解析

1. 装饰器定义
def timmer(func):            # 接收被装饰的函数（如 index 或 home）
    def wrapper(*args, **kwargs):  # 接收任意参数（兼容原函数参数）
        start = time.time()        # 记录开始时间
        res = func(*args, **kwargs)  # 调用原函数并保存返回值（关键点！）
        stop = time.time()         # 记录结束时间
        print(stop - start)        # 打印耗时
        return res                 # 返回原函数的返回值（维持原行为）
    return wrapper                 # 返回包装后的函数


2. 使用装饰器

@timmer  # 等价于 index = timmer(index)
def index(x, y, z):
    time.sleep(3)
    print('index %s %s %s' % (x, y, z))

@timmer  # 等价于 home = timmer(home)
def home(name):
    time.sleep(2)
    print('welcome %s to home page' % name)
    return 123  # 原函数有返回值


3. 调用被装饰的函数
index(x=1, y=2, z=3)  # 保持原调用方式（关键字参数）
home('egon')          # 保持原调用方式（位置参数）





```
解释

<img width="873" height="759" alt="image" src="https://github.com/user-attachments/assets/2eaed93e-abab-4516-94ab-754977ae3a11" />

<img width="554" height="371" alt="image" src="https://github.com/user-attachments/assets/94a3a34e-1803-4b83-b5d9-fea793ed25db" />




'''
### @timmer  # 等价于 home = timmer(home) 解释下

###### 原文
@timmer  # 等价于 index = timmer(index)
def index(x, y, z):
    # ... 原函数逻辑 ...

###### 等价于：
def index(x, y, z):  # 1. 定义原函数
    # ... 原函数逻辑 ...

index = timmer(index)  # 2. 手动装饰：把原函数传递给装饰器，覆盖原函数名


### 1）关键步骤解析
### 1.原始函数定义
定义 index 函数时，它指向自己的代码块（内存地址为 0x1000）。

### 2.应用装饰器
#### 通过 @timmer 或手动执行 index = timmer(index)，实际发生以下操作：

* 调用装饰器函数：将原函数 index 作为参数传给 timmer(func)。
* 返回包装函数：timmer 返回内部函数 wrapper（内存地址为 0x2000）。
* 覆盖原函数名：将变量 index 重新赋值为 wrapper 函数。


'''

<img width="686" height="171" alt="image" src="https://github.com/user-attachments/assets/fd3b81a3-746f-44ee-ab92-541d1f81038f" />



示例1===打印运行代码的时间的装饰器

```python

# 示例1===打印运行代码的时间的装饰器
def timmer(func):
    # func=index的内存地址
    def wrapper(*args,**kwargs):
        start=time.time()
        time.sleep(2)
        res=func(*args,**kwargs)
        stop=time.time()
        print(stop - start)
        return res
    return wrapper

@timmer
def index():
    print('from index')

index()

# 输出结果：
from index
2.012852191925049

```

示例2===认证功能的装饰器

```python

# 示例2===认证功能的装饰器
def auth(func):
    # func=index的内存地址
    def wrapper(*args,**kwargs):
        #         1、调用原函数
        #         2、为其增加新功能
        name=input('your name>>>: ').strip()
        password=input('your password>>>: ').strip()
        if name == 'egon' and password == '123':
            res=func(*args,**kwargs)
            return res
        else:
            print('账号密码输入错误')
    return wrapper

@auth
def index():
    print('from index')

index()

```

<h2 id="puHcl">2.3 wraps装饰器补充</h2>
**<font style="color:#DF2A3F;">偷梁换柱：即将原函数名指向的内存地址偷梁换柱成wrapper函数，所以应该将wrapper做的跟原函数一样才行。</font>**

**<font style="color:#DF2A3F;">关键伪装：参数、返回值、属性</font>**

```python

# 示例1====手动将原函数的属性赋值给wrapper函数
def outter(func):
    def wrapper(*args,**kwargs):
        res=func(*args,**kwargs)  # res=index(1,2)
        return res
    # 一、手动将原函数的属性赋值给wrapper函数
    # 1、函数wrapper.__name__ = 原函数.__name__
    # 2、函数wrapper.__doc__ = 原函数.__doc__
    wrapper.__name__ = func.__name__
    wrapper.__doc__ = func.__doc__
    return wrapper

@outter  # index=outter(index)
def index(x,y):
    """这是主页功能"""
    print(x,y)

print(index.__name__)
print(index.__doc__)

help() 看的就是函数文档注释信息
print(help(index))

index(1,2)  # wrapper(1,2)






# 示例2===自动将原函数的属性赋值给wrapper函数

from functools import wraps
def outter(func):
    # 二、自动将原函数的属性赋值给wrapper函数
    @wraps(func)
    def wrapper(*args,**kwargs):
        res=func(*args,**kwargs)  # res=index(1,2)
        return res
    # 手动将原函数的属性赋值给wrapper函数
    # 1、函数wrapper.__name__ = 原函数.__name__
    # 2、函数wrapper.__doc__ = 原函数.__doc__
    # wrapper.__name__ = func.__name__
    # wrapper.__doc__ = func.__doc__
    return wrapper

@outter  # index=outter(index)
def index(x,y):
    """这是主页功能"""
    print(x,y)

print(index.__name__)
print(index.__doc__)

index(1,2)  # wrapper(1,2)






```

<h2 id="IJ3Sk">2.4 有参装饰器的实现</h2>

```python

# 由于语法糖@的限制，outter函数只能有一个参数，并且该参数只用来接收被装饰对象的内存地址。
def outter(func):
    # func = 函数的内存地址
    def wrapper(*args,**kwargs):
        res=func(*args,**kwargs)  # res=index(1,2)
        return res
    return wrapper

@outter  # index=outter(index) index ==》wrapper
def index(x,y):
    print(x,y)

index(1,2)  # wrapper(1,2)

# 重点：偷梁换柱之后
index的参数什么样子，wrapper的参数就应该什么样子
index的返回值什么样子，wrapper的返回值就应该什么样子
index的属性什么样子，wrapper的属性就应该什么样子==》 from functools import wraps


# # 示例1：直接在auth后面传参，不使用语法糖（山炮玩法）
def auth(func,db_type):
    # func=index的内存地址
    def wrapper(*args,**kwargs):
        name=input('your name>>>: ').strip()
        password=input('your password>>>: ').strip()
        if db_type == 'file':
            if name == 'egon' and password == '123':
                print('基于文件的验证')
                res=func(*args,**kwargs)
                return res
            else:
                print('账号密码输入错误')
        elif db_type == 'mysql':
            print('基于mysql的验证')
        elif db_type == 'ldap':
            print('基于ldap的验证')
        else:
            print('不支持的db_type')
    return wrapper

# @auth  # 账号密码的来源是文件
def index(x,y):
    print('index==> %s:%s' %(x,y))

# @auth  # 账号密码的来源是数据库
def home(name):
    print('home==>%s' %name)

# @auth  # 账号密码的来源是ldap
def transfer():
    print('transfer')

index=auth(index, 'file')
home=auth(home, 'mysql')
transfer=auth(transfer, 'ldap')

index(1,2)
home('egon')
transfer()


# 示例2：山炮2玩法
def auth(db_type):
    def deco(func):
        def wrapper(*args,**kwargs):
            name=input('your name>>>: ').strip()
            password=input('your password>>>: ').strip()
            if db_type == 'file':
                if name == 'egon' and password == '123':
                    print('基于文件的验证')
                    res=func(*args,**kwargs)
                    return res
                else:
                    print('账号密码输入错误')
            elif db_type == 'mysql':
                print('基于mysql的验证')
            elif db_type == 'ldap':
                print('基于ldap的验证')
            else:
                print('不支持的db_type')
        return wrapper
    return deco
deco=auth(db_type='file')

@deco  # 账号密码的来源是文件
def index(x,y):
    print('index==> %s:%s' %(x,y))

deco=auth(db_type='mysql')
@deco  # 账号密码的来源是数据库
def home(name):
    print('home==>%s' %name)

deco=auth(db_type='ldap')
@deco  # 账号密码的来源是ldap
def transfer():
    print('transfer')


index(1,2)
home('egon')
transfer()


# 示例3：最终答案展示语法糖：有参函数装饰器
def auth(db_type):
    def deco(func):
        def wrapper(*args,**kwargs):
            name=input('your name>>>: ').strip()
            password=input('your password>>>: ').strip()
            if db_type == 'file':
                if name == 'egon' and password == '123':
                    print('基于文件的验证')
                    res=func(*args,**kwargs)
                    return res
                else:
                    print('账号密码输入错误')
            elif db_type == 'mysql':
                print('基于mysql的验证')
            elif db_type == 'ldap':
                print('基于ldap的验证')
            else:
                print('不支持的db_type')
        return wrapper
    return deco

@auth(db_type='file')  # @deco # index=deco(index) # index=wrapper
def index(x,y):
    print('index==> %s:%s' %(x,y))

@auth(db_type='mysql')  # @deco # home=deco(home) # home=wrapper
def home(name):
    print('home==>%s' %name)

@auth(db_type='ldap')  # @deco # transfer=deco(transfer) # transfer=wrapper
def transfer():
    print('transfer')


index(1,2)
home('egon')
transfer()




```

<h2 id="zHmfh">2.5  有参装饰器模板</h2>

```python

# 有参装饰器模板
def 有参装饰器(x,y,z):   # 外层：接收装饰器参数
    def outter(func):   # 中层：接收被装饰函数
        def wrapper(*args,**kwargs):  # 内层：包裹原函数
            res=func(*args,**kwargs)
            return res
        return wrapper
    return outter



@有参装饰器(1,y=2,z=3)   # 等价于 被装饰对象 = 有参装饰器(1,2,3)(被装饰对象)
def 被装饰对象():
    pass

```

参考链接：[https://zhuanlan.zhihu.com/p/109078881](https://zhuanlan.zhihu.com/p/109078881)



<h2 id="Sy5Sf">2.6 叠加多个装饰器的分析(了解)</h2>

```python

def deco1(func1):
    def wrapper1(*args,**kwargs):
        print('正在运行===>deco1.wrapper1')
        res1=func1(*args,**kwargs)
        return res1
    return wrapper1

def deco2(func2):
    def wrapper2(*args,**kwargs):
        print('正在运行===>deco2.wrapper2')
        res2=func2(*args,**kwargs)
        return res2
    return wrapper2

def deco3(x):
    def outter3(func3):
        def wrapper3(*args,**kwargs):
            print('正在运行===>deco3.outter3.wrapper3')
            res3=func3(*args,**kwargs)
            return res3
        return wrapper3
    return outter3

# 加载顺序自上而下（了解）
@deco1       # index=deco1(wrapper2的内存地址)        ===> index=wrapper1的内存地址
@deco2       # index=deco2(wrapper3的内存地址)        ===> index=wrapper2的内存地址
@deco3(111)  # ===>@outter3===> index=outter(index) ===> index=wrapper3的内存地址

def index(x,y):
    print('from index %s:%s' %(x,y))

# 执行顺序：自上而下的，即wrapper1--》wrapper2---》wrapper3
index(1,2)


# 输出结果：
正在运行===>deco1.wrapper1
正在运行===>deco2.wrapper2
正在运行===>deco3.outter3.wrapper3
from index 1:2

```







![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1680078935695-e9fe3b24-b7a2-4424-a0b1-839b224adb97.png)

<h2 id="h0Vo6">2.7 温故知新</h2>

```python

# 有参装饰器
from functools import wraps
def deco(x,y,z):
    def outter(func):
        @wraps(func)
        def wrapper(*args,**kwargs):
            res=func(*args,**kwargs)
            return res
        return wrapper
    return outter

#分析执行过程:
@deco(1,2,3) ==> @outter ==> 原函数=outter(被装饰的函数)

```


