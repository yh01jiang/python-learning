<img width="720" height="470" alt="image" src="https://github.com/user-attachments/assets/7734375a-0588-4208-81b9-f5b1ce9d790f" />

<h1 id="vBwwD"><font style="color:rgb(18, 18, 18);">一 函数对象</font></h1>
<font style="color:rgb(18, 18, 18);">函数对象指的是函数可以被当做’数据’来处理，具体可以分为四个方面的使用。</font>

```python

# 精髓： 可以吧函数当成变量使用
# func=内存地址
def func():
    print('From func')

# 1、可以赋值
f=func
print(f,func)  # 输出结果：<function func at 0x018845D0> <function func at 0x018845D0>
f()  # 输出结果：From func

# 2、可以把函数当做参数传给另外一个函数
def foo(x):  # x=func的内存地址
    print(x)  # 输出结果：<function func at 0x020C45D0>
    x()  # 输出结果：From func

foo(func)  # foo(func的内存地址)

# 3、可以把函数当做另外一个函数的返回值
def foo(x): # x=func的内存地址
    return x # return func的内存地址

res=foo(func)  # foo(func的内存地址)
print(res)  # res=func的内存地址 # 输出结果：<function func at 0x01A445D0>

res()  # 输出结果：From func

# 4、可以当做容器类型的一个元素
# 1) 示例1
l=[func,]
print(l)  # 输出结果：[<function func at 0x020745D0>]
l[0]()  # 输出结果: From func

# 2） 示例2
dic={'k1': func}
print(dic)  # 输出结果：{'k1': <function func at 0x019145D0>}
dic['k1']()  # 输出结果: From func

```

"""
def f1():
    x = 333333333333333        # 步骤2：在f1的局部作用域定义变量x
    def f2():
        print('函数f2：', x)    # 步骤5：通过闭包访问外层x的值
    return f2                   # 步骤3：返回内部函数f2对象

f = f1()                        # 步骤1：调用f1() → 返回f2函数对象 → 赋值给f
print(f)                        # 步骤4：输出f的内存地址（对应函数对象f2）
f()                             # 步骤6：调用f()即调用f2()


<function f1.<locals>.f2 at 0x...>  # f2函数对象的内存地址
函数f2： 333333333333333            # 通过闭包保留的x值



### 闭包的形成条件
内部函数引用外部变量：f2 内部引用了 f1 的局部变量 x。
外部函数返回内部函数：f1 返回 f2，使得 f2 在 f1 执行结束后仍可被调用。

"""

基于函数对象的案例

```python

def login():
    print('登录成功')

def transfer():
    print('转账成功')

def check_balance():
    print('查询余额')

def withdraw():
    print('提现')

def register():
    print('注册功能')

func_dic={
    '0': None,
    '1':login,
    '2':transfer,
    '3':check_balance,
    '4': withdraw,
    '5': register
}


while True:
    print("""
    0 退出
    1 登录
    2 转账
    3 查询余额
    4 提现
    5 注册功能
    """)

    choice = input('请输入命令编号>>>: ').strip()
    if not choice.isdigit():
        print('请输入纯数字的命令编号，傻逼')
        continue
    if choice == '0':
        break

    if choice in func_dic:
        func_dic[choice]()
    else:
        print('输入的命令编号不存在')

```

#### 基于函数对象的案例======优化版

```python

# 使用函数对象解决：

def login():
    print('登录成功')

def transfer():
    print('转账成功')

def check_balance():
    print('查询余额')

def withdraw():
    print('提现')

def register():
    print('注册功能')

func_dic={
    # 如果严谨一点，只有读需求，可以改成元组。
    '0': ['退出',None],
    '1': ['登录', login],
    '2': ['转账',transfer],
    '3': ['查询余额', check_balance],
    '4': ['提现',withdraw],
    '5': ['注册',register]
}


while True:
   for k in func_dic:
       print(k,func_dic[k][0])

   choice = input('请输入命令编号>>>: ').strip()
   if not choice.isdigit():
        print('请输入纯数字的命令编号，傻逼')
        continue
   if choice == '0':
        break

   if choice in func_dic:
        func_dic[choice][1]()
   else:
        print('输入的命令编号不存在')

```



<h1 id="wI6AT">二、函数嵌套</h1>
<h2 id="ht8ew">1、函数的嵌套调用： 在调用一个函数的过程中又调用其他函数</h2>

```python

def max2(x,y):
    if x > y:
        return x
    else:
        return y

def max4(a,b,c,d):
    # 第一步：比较a，b得到res1
    res1=max2(a,b)
    # 第二步 比较res1，c得到res2
    res2=max2(res1,c)
    # 第三步 比较res2，d得到res3
    res3=max2(res2,d)
    return res3

res=max4(1,2,3,4)
print(res)  # 输出结果： 4

```

<h2 id="COqDJ">2、 函数的嵌套定义： 在函数内定义函数</h2>

```python

# def f1():
#     def f2():
#         pass


# 圆形
# 求周长：2*pi*radius
def circle(radius,action=0):
    from math import pi
    def perimiter(radius):
        return 2*pi*radius
    # 求面积: pi*(radius**2)
    def area(radius):
        return pi*(radius**2)
    if action == 0:
        return perimiter(radius)
        elif action == 1:
        elif action == 1:
        return area(radius)

res=circle(10,action=1)
print(res)

```

<h1 id="JHkrg">三、闭包函数</h1>

```python

'''
# 一、大前提：
# 闭包函数=名称空间与作用域+函数嵌套+函数对象
#           核心点： 名字的查找关系是以函数定义阶段为准的。
'''


背景：出于种种原因，我们有时候需要在函数外部得到函数内的局部变量

闭包：在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包。


```


<h2 id="uu3cV">3.1 <font style="color:rgb(18, 18, 18);">闭与包</font></h2>
"<font style="background-color:#FBDE28;">闭"函数指的是该函数的内嵌函数。</font>

<font style="background-color:#FBDE28;">"包"函数指的是该函数包含对外层函数作用域名字的引用（不是对全局作用域）</font>

<font style="background-color:#FBDE28;">闭包函数: 名称空间与作用域的应用+函数嵌套</font>

```python

# 示例1
def f1():
    x = 333333333
    def f2():
        print(x)  # 输出结果： 33333333
    f2()

f1()

# 示例2
def f1():
    x = 333333333
    def f2():
        print(x)  # 输出结果： 33333333
    f2()

x=11111
def bar():
    x=44444
    f1()

def foo():
    x=22222
    bar()
foo()

# 输出结果： 333333333

# 闭包函数：函数对象
def f1():
    x = 333333333333333
    def f2():
        print('函数f2：',x)
    return f2

f=f1()
print(f)  # 输出结果：<function f1.<locals>.f2 at 0x02351FA8>
f()  # 输出结果：函数f2： 333333333333333

x=4444
f()  # 输出结果：函数f2： 333333333333333

def foo():
    x=5555
    f()  # 输出结果：函数f2： 333333333333333
foo()

```



<h2 id="H3BqP">3.2 闭包函数的应用场景</h2>
![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1679643208002-e1db8c69-6889-469b-85bc-577aad31b78f.png)

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1679643375629-731a9591-260d-4f89-a35f-bbb5cf5dfc51.png)

<font style="color:#DF2A3F;">方式1：直接把函数体需要的参数定义成形参</font>

```python

def f2(x):
    print(x)
f2(1)
f2(2)
f2(3)

# 输出结果
1
2
3

```

<font style="color:#DF2A3F;">方式2：利用名称空间与作用域的方法，闭包给它</font>

```python

def f1():
    x = 666666
    def f2():
        print(x)
    return f2

# 这里赋值的变量随便定义都是可以的。
f2=f1()
print(f2)  # 输出结果：<function f1.<locals>.f2 at 0x015C4540>
f2()  #输出结果： 666666

# 基于上面优化===不写死
def f1(x):
    def f2():
        print(x)
    return f2

# 这里赋值的变量随便定义都是可以的。
f2=f1(999999)
print(f2)  # 输出结果：<function f1.<locals>.f2 at 0x015C4540>
f2()  #输出结果： 666666


# 案例1====通过传参的形式解决
import requests
def get(url):
    res=requests.get(url)
    print(res.text)
get('https://www.baidu.com')
get('https://www.cnblogs.com/linhaifeng')
get('https://zhuanlan.zhihu.com./p/109056932')


# 案例2====闭包函数解决
import requests
def outter(url):
    # url='https://www.baidu.com'
    def get():
        res=requests.get(url)
        print(res.text)
    return get

baidu=outter('https://www.baidu.com')
baidu()


cnblogs=outter('https://www.cnblogs.com/linhaifeng')
cnblogs()

zhihu=outter('https://zhuanlan.zhihu.com./p/109056932')
zhihu()

```



<h1 id="wP0Ma">匿名函数</h1>
<font style="color:rgb(31, 41, 55);background-color:rgb(249, 250, 251);">当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。</font>

<font style="color:rgb(31, 41, 55);background-color:rgb(249, 250, 251);">在Python中，对匿名函数提供了有限支持。还是以</font>`map()`<font style="color:rgb(31, 41, 55);background-color:rgb(249, 250, 251);">函数为例，计算f(x)=x</font><sup><font style="color:rgb(31, 41, 55);background-color:rgb(249, 250, 251);">2</font></sup><font style="color:rgb(31, 41, 55);background-color:rgb(249, 250, 251);">时，除了定义一个</font>`f(x)`<font style="color:rgb(31, 41, 55);background-color:rgb(249, 250, 251);">的函数外，还可以直接传入匿名函数</font>

```python

>>> list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
[1, 4, 9, 16, 25, 36, 49, 64, 81]

```

<font style="color:rgb(31, 41, 55);background-color:rgb(249, 250, 251);">通过对比可以看出，匿名函数</font>`lambda x: x * x`<font style="color:rgb(31, 41, 55);background-color:rgb(249, 250, 251);">实际上就是：</font>

```python

def f(x):
    return x * x

```

<font style="color:rgb(31, 41, 55);background-color:rgb(249, 250, 251);">关键字</font>`lambda`<font style="color:rgb(31, 41, 55);background-color:rgb(249, 250, 251);">表示匿名函数，冒号前面的</font>`x`<font style="color:rgb(31, 41, 55);background-color:rgb(249, 250, 251);">表示函数参数。</font>

<font style="color:rgb(31, 41, 55);background-color:rgb(249, 250, 251);">匿名函数有个限制，就是只能有一个表达式，不用写</font>`return`<font style="color:rgb(31, 41, 55);background-color:rgb(249, 250, 251);">，返回值就是该表达式的结果。</font>

<font style="color:rgb(31, 41, 55);background-color:rgb(249, 250, 251);">用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：</font>

<font style="color:rgb(31, 41, 55);background-color:rgb(249, 250, 251);"></font>

```bash

>>> f = lambda x: x * x
>>> f
<function <lambda> at 0x101c6ef28>
>>> f(5)
25

```

<font style="color:rgb(31, 41, 55);background-color:rgb(249, 250, 251);">同样，也可以把匿名函数作为返回值返回，比如：</font>

```python

def build(x, y):
    return lambda: x * x + y * y

```

<h3 id="1ce039c9"><font style="color:rgb(31, 41, 55);background-color:rgb(249, 250, 251);">练习</font></h3>
<font style="color:rgb(31, 41, 55);background-color:rgb(249, 250, 251);">请用匿名函数改造下面的代码：</font>

```python

def is_odd(n):
    return n % 2 == 1

L = list(filter(is_odd, range(1, 20)))

print(L)


# 改造匿名函数
L = list(filter(lambda n:n % 2 == 1, range(1, 20)))
print(L)

```

<h3 id="5db9fd7c"><font style="color:rgb(31, 41, 55);background-color:rgb(249, 250, 251);">小结</font></h3>
<font style="color:rgb(31, 41, 55);background-color:rgb(249, 250, 251);">Python对匿名函数的支持有限，只有一些简单的情况下可以使用匿名函数。</font>

<font style="color:rgb(31, 41, 55);background-color:rgb(249, 250, 251);">  
</font>

