```python
### 1. 数据类型的内置方法###
    必须通过对应的数据类型点的方式才可以调用（不同的数据类型可以调用的内置方法不一样）
    eg: 'jason'.strip()
    
### 2. python的内置方法
    不需要借助任何的数据类型 直接可以使用的方法
    eg： str() int()
```

<h1 id="HYOLS">一 、 类型转换（int类型）</h1>
```python
# 纯数字的字符串转化成int
res = int('100')
print(res, type(res))

100 <class 'int'>



# 10进制转化为二进制
print(bin(100)) # 0b代表二进制

0b1100100
# 10进制转化为八进制
print(oct(100))    # 0o代表八进制

0o144
# 10进制转化为十六进制
print(hex(100))    # 0x代表16进制

0x64

# 把二进制转换为其他进制
# 把二进制转换为10进制
print(int('0b1100100', 2))
# 二进制转化为8进制
print(int('0o144', 8))
# 二进制转化为16进制
print(int('0x64', 16))

100
100
100
```

<h1 id="aqo0Z">二、 float类型</h1>
```python
salary = 3.13
print(salary, type(salary))

3.13 <class 'float'>


# 类型转换
# 字符串有小数点转化为float

res = float('3.13')
print(res, type(res))

3.13 <class 'float'>
```

<h1 id="p0UiX">三、 字符串</h1>
<h2 id="jDajj">1. 定义</h2>
```bash
# 定义：在单引号\双引号\三引号内包含一串字符
name1 = 'jason'  # 本质:name = str('任意形式内容')
name2 = "lili"  # 本质:name = str("任意形式内容")
name3 = """ricky"""  # 本质:name = str("""任意形式内容""")
```

<h2 id="XoPEK">2. 类型转换</h2>
```python
# 数据类型转换：str()可以将任意数据类型转换成字符串类型，例如 
>>> type(str([1,2,3])) # list->str
<class 'str'>
>>> type(str({"name":"jason","age":18})) # dict->str
<class 'str'>
>>> type(str((1,2,3)))  # tuple->str
<class 'str'>
>>> type(str({1,2,3,4})) # set->str
<class 'str'>
```

<h2 id="F6l2m">3. 使用</h2>
<h3 id="xaEUG"><font style="color:rgb(0, 0, 0);">3.1 优先掌握的操作</font></h3>
```python
>>> str1 = 'hello python!'
 
# 1.按索引取值(正向取，反向取)：
# 1.1 正向取(从左往右)
>>> str1[6]
p
# 1.2 反向取(负号表示从右往左)
>>> str1[-4]
h
# 1.3 对于str来说，只能按照索引取值，不能改
>>> str1[0]='H' # 报错TypeError
 
# 2.切片(顾头不顾尾，步长)----->从一个大字符串中，拷贝出一个子字符串
# 2.1 顾头不顾尾：取出索引为0到8的所有字符
>>> str1[0:9]  
hello pyt
# 2.2 步长：0:9:2,第三个参数2代表步长，会从0开始，每次累加一个2即可，所以会取出索引0、2、4、6、8的字符
>>> str1[0:9:2]  
hlopt 
# 2.3 反向切片
>>> str1[::-1]  # -1表示从右往左依次取值
!nohtyp olleh
 
# 3.长度len
# 3.1 获取字符串的长度，即字符的个数，但凡存在于引号内的都算作字符)
>>> len(str1) # 空格也算字符
13
 
# 4.成员运算 in 和 not in    
# 4.1 int:判断hello 是否在 str1里面
>>> 'hello' in str1  
True
# 4.2 not in:判断tony 是否不在 str1里面
>>> 'tony' not in str1 
True
 
# 5.strip移除字符串首尾指定的字符(默认移除空格)
# 5.1 括号内不指定字符，默认移除首尾空白字符(空格、\n、\t)
>>> str1 = '  life is short!  '
>>> str1.strip()  
life is short!
 
# 5.2 括号内指定字符，移除首尾指定的字符
>>> str2 = '**tony**'  
>>> str2.strip('*')  
tony
 
# 6.切分split---->把一个字符串按照某种分隔符进行切分，得到一个列表
# 6.1 括号内不指定字符，默认以空格作为切分符号
>>> str3='hello world'
>>> str3.split()
['hello', 'world']
# 6.2 括号内指定分隔字符，则按照括号内指定的字符切割字符串
>>> str4 = '127.0.0.1'
>>> str4.split('.')  
['127', '0', '0', '1']  # 注意:split切割得到的结果是列表数据类型
# 6.3 指定分隔次数
>>> info = 'egon:18:male'
>>> res = info.split(':', 1) # 1代表一次
>>> (res)
['egon', '18:male']
>>>
注意：split ：从左往右
rsplit： 从右往左

# 7.循环
>>> str5 = '今天你好吗？'
>>> for line in str5:  # 依次取出字符串中每一个字符
...     print(line)
...
今
天
你
好
吗
？
```

<h3 id="OXemC">案例</h3>
```python
# 需求：用户登录三次，校验用户密码


# 1. 定义类似于数据库的数据
source_data = 'barry|123'
# 8. 添加一个计数器
count = 1
# 5. 添加循环
while True:
    # 9. 判断当前尝试的次数
    if count == 4:
        choice = input('您已经尝试三次了 是否继续(y/n)>>>:').strip()
        if choice == 'y':
            count = 1
        else:
            print('欢迎下次光临')
            break
    # 2. 获取用户输入的用户名以及密码
    username = input('username>>>:').strip()
    if len(username) == 0:
        print('用户名不能为空')
        continue
    password = input('password>>>:').strip()
    if len(password) == 0:
        print('密码不能为空')
        continue
    # 3. 切割原始数据得到用户名和密码比对,细节就是字符串处理后就是列表，这里就牵扯到解压赋值
    real_name, real_pwd = source_data.split('|')  # real_name, real_pwd = ['barry', '123'] #解压赋值
    # 4. 校验用户输入的用户名以及密码
    if username == real_name and password == real_pwd:
        print('用户登录成功')
        # 6. 添加内层循环
        while True:
            cmd = input('请输入您的指令>>>:').strip()
            # 7. 添加一个结束条件
            if cmd == 'q':
                break
            print('正在执行您的命令:%s' % cmd)
    else:
        print('用户名或者密码错误')
        # 10. 没尝试一次加1
        count += 1
```

<h3 id="iXM3M">3.2 需要掌握的操作</h3>
<h4 id="PG1VP">3.2.1. strip lstrip rstrip </h4>
```python
# 移除字符串首尾的指定字符 可以选择方向
# lstrip ：左边
# rstrip： 右边

str1 = '$$$barry$$$'
print(str1.rstrip('$'))   # 只移除右边的指定字符
print(str1.lstrip('$'))   # 只移除左边的指定字符
print(str1.strip('$'))    # 移除左右两边的指定字符
### 输出 ###
$$$barry
barry$$$
barry

```

<h4 id="UoVRo">**<font style="color:rgb(0, 0, 0);">3.2.2 lower(),upper()</font>**</h4>
```python
>>> str2 = 'Barry123'
 
>>> str2.lower()  # 将英文字符串全部变小写
barry123

>>> str2.upper()  # 将英文字符串全部变大写
BARRY123


print(str2.islower())  # 判断字符换中所有的英文字母是否是纯小写 结果是布尔值
print(str2.isupper())  # 判断字符换中所有的英文字母是否是纯大写 结果是布尔值


### 验证码不分区大小写案例
# 图片验证码 ：一串数字、大写字母  小写字母

code = 'BaRry6'
print('这是发回给用户的图片验证码:%s' % code)
user_code = input('请输入验证码>>>:').strip()
if code.lower() == user_code.lower():  # 验证码忽略大小写
    print('验证码输入正确')
```

<h4 id="fd9nq">**<font style="color:rgb(0, 0, 0);">3.2.3 .startswith,endswith</font>**</h4>
```python
>>> str3 = 'tony jam'
 
# startswith()判断字符串是否以括号内指定的字符开头，结果为布尔值True或False
>>> str3.startswith('t') 
True
>>> str3.startswith('j')
False
# endswith()判断字符串是否以括号内指定的字符结尾，结果为布尔值True或False
>>> str3.endswith('jam')
True
>>> str3.endswith('tony')  
False
```

**<font style="color:rgb(0, 0, 0);">3.2. 4.格式化输出之format</font>**

<font style="color:rgb(0, 0, 0);">之前我们使用%s来做字符串的格式化输出操作，在传值时，必须严格按照位置与%s一一对应，而字符串的内置方法format则提供了一种不依赖位置的传值方式</font>

<font style="color:rgb(0, 0, 0);">案例：</font>

```python
# format括号内在传参数时完全可以打乱顺序，但仍然能指名道姓地为指定的参数传值，name=‘tony’就是传给{name}
>>> str4 = 'my name is {name}, my age is {age}!'.format(age=18,name='tony')
>>> str4  
'my name is tony, my age is 18!'
 
>>> str4 = 'my name is {name}{name}{name}, my age is {name}!'.format(name='tony', age=18)
>>> str4  
'my name is tonytonytony, my age is tony!'
```

<font style="color:rgb(0, 0, 0);">format的其他使用方式</font>

```python
# 类似于%s的用法，传入的值会按照位置与{}一一对应
>>> str4 = 'my name is {}, my age is {}!'.format('tony', 18)
>>> str4 
my name is tony, my age is 18!
```

```python
# 把format传入的多个值当作一个列表，然后用{索引}取值
>>> str4 = 'my name is {0}, my age is {1}!'.format('tony', 18)
>>> str4
my name is tony, my age is 18!
 
>>> str4 = 'my name is {1}, my age is {0}!'.format('tony', 18)
>>> str4  
my name is 18, my age is tony!
 
>>> str4 = 'my name is {1}, my age is {1}!'.format('tony', 18)
>>> str4  
my name is 18, my age is 18!
```

```python
# 比较推荐的办法（重点）
name = 'jason'
age = 18
print(f'my name is {name} my age is {age}')  # 注意f不能少
```

<h4 id="OJnq1"><font style="color:rgb(0, 0, 0);">3.2. 5.split,rsplit </font></h4>
```python
# split会按照从左到右的顺序对字符串进行切分，可以指定切割次数
>>> str5='C:/a/b/c/d.txt'
>>> str5.split('/',1)
['C:', 'a/b/c/d.txt']  
 
# rsplit刚好与split相反，从右往左切割，可以指定切割次数
>>> str5='a|b|c'
>>> str5.rsplit('|',1)
['a|b', 'c']
```

**<font style="color:rgb(0, 0, 0);">3.2.6.join</font>**<font style="color:rgb(0, 0, 0);"> </font>

```python
# 从可迭代对象中取出多个字符串，然后按照指定的分隔符进行拼接，拼接的结果为字符串
>>> '%'.join('hello') # 从字符串'hello'中取出多个字符串，然后按照%作为分隔符号进行拼接
'h%e%l%l%o'
>>> '|'.join(['tony','18','read'])  # 从列表中取出多个字符串，然后按照*作为分隔符号进行拼接
'tony|18|read'



s1 = '三月不努力'
s2 = '老大徒伤悲'
print(s1 + s2)  # 三月不努力老大徒伤悲
print(s1 * 3)  # 三月不努力三月不努力三月不努力
print('|'.join(s1))  # 三|月|不|努|力
print('$'.join(['jason', 'kevin', 'tony']))  # jason$kevin$ton




l1 = [11, 'jason', 'kevin']
print('|'.join(l1))
#注意: jason的元素必须都是字符串才可以，否则报错。

```

**<font style="color:rgb(0, 0, 0);">3.2.7.replace</font>**

```python
# 用新的字符替换字符串中旧的字符
>>> str7 = 'my name is tony, my age is 18!'  # 将tony的年龄由18岁改成73岁
>>> str7 = str7.replace('18', '73')  # 语法:replace('旧内容', '新内容')
>>> str7
my name is tony, my age is 73!
 
# 可以指定修改的个数
>>> str7 = 'my name is tony, my age is 18!'
>>> str7 = str7.replace('my', 'MY',1) # 只把一个my改为MY
>>> str7
'MY name is tony, my age is 18!'
```

**<font style="color:rgb(0, 0, 0);">3.2. 8.isdigit --判断字符串是不是纯数字</font>**

```python
s7 = 'jason123'
print(s7.isdigit())  # False
print('123'.isdigit())  # True
print('123.21'.isdigit())  # False


### 简单案例### 
score = input('sorce>>>:')
if score.isdigit():
    score = int(score)
else:
    print('你他妈的能不能好好输入')
```

<h4 id="d70UT"><font style="color:rgb(0, 0, 0);">3.2.9 了解操作</font></h4>
```python
# 1.find,rfind,index,rindex,count
# 1.1 find：从指定范围内查找子字符串的起始索引，找得到则返回数字1，找不到则返回-1
>>> msg='tony say hello'
>>> msg.find('o',1,3)  # 在索引为1和2(顾头不顾尾)的字符中查找字符o的索引
1  
# 1.2 index:同find,但在找不到时会报错
>>> msg.index('e',2,4) # 报错ValueError
# 1.3 rfind与rindex：略
# 1.4 count:统计字符串在大字符串中出现的次数
>>> msg = "hello everyone"
>>> msg.count('e')  # 统计字符串e出现的次数
4
>>> msg.count('e',1,6)  # 字符串e在索引1~5范围内出现的次数
1
 
# 2.center,ljust,rjust,zfill
>>> name='tony'
>>> name.center(30,'-')  # 总宽度为30，字符串居中显示，不够用-填充
-------------tony-------------
>>> name.ljust(30,'*')  # 总宽度为30，字符串左对齐显示，不够用*填充
tony**************************
>>> name.rjust(30,'*')  # 总宽度为30，字符串右对齐显示，不够用*填充
**************************tony
>>> name.zfill(50)  # 总宽度为50，字符串右对齐显示，不够用0填充
0000000000000000000000000000000000000000000000tony
 
# 3.expandtabs
>>> name = 'tony\thello'  # \t表示制表符(tab键)
>>> name
tony    hello
>>> name.expandtabs(1)  # 修改\t制表符代表的空格数
tony hello
 
# 4.captalize,swapcase,title ===可能会用
# 4.1 captalize：首字母大写
>>> message = 'hello everyone nice to meet you!'
>>> message.capitalize()
Hello everyone nice to meet you!  
# 4.2 swapcase：大小写翻转
>>> message1 = 'Hi girl, I want make friends with you!'
>>> message1.swapcase()  
hI GIRL, i WANT MAKE FRIENDS WITH YOU!  
#4.3 title：每个单词的首字母大写
>>> msg = 'dear my friend i miss you very much'
>>> msg.title()
Dear My Friend I Miss You Very Much 
 
# 5.is数字系列
#在python3中
num1 = b'4' #bytes
num2 = u'4' #unicode,python3中无需加u就是unicode
num3 = '四' #中文数字
num4 = 'Ⅳ' #罗马数字
 
#isdigt:bytes,unicode
>>> num1.isdigit()
True
>>> num2.isdigit()
True
>>> num3.isdigit()
False
>>> num4.isdigit() 
False
 
#isdecimal:uncicode(bytes类型无isdecimal方法)
>>> num2.isdecimal() 
True
>>> num3.isdecimal() 
False
>>> num4.isdecimal() 
False
 
#isnumberic:unicode,中文数字,罗马数字(bytes类型无isnumberic方法)
>>> num2.isnumeric() 
True
>>> num3.isnumeric() 
True
>>> num4.isnumeric() 
True
 
# 三者不能判断浮点数
>>> num5 = '4.3'
>>> num5.isdigit()
False
>>> num5.isdecimal()
False
>>> num5.isnumeric()
False
 
'''
总结:
    最常用的是isdigit,可以判断bytes和unicode类型,这也是最常见的数字应用场景
    如果要判断中文数字或罗马数字,则需要用到isnumeric。
'''
 
# 6.is其他==基本不用
>>> name = 'tony123'
>>> name.isalnum() #字符串中既可以包含数字也可以包含字母
True
>>> name.isalpha() #字符串中只包含字母
False
>>> name.isidentifier()
True
>>> name.islower()  # 字符串是否是纯小写
True
>>> name.isupper()  # 字符串是否是纯大写
False
>>> name.isspace()  # 字符串是否全是空格
False
>>> name.istitle()  # 字符串中的单词首字母是否都是大写
False


## 7.特殊符号
print('ja\tson\nke\avim')
ja	son
kevim

"""如果想取消他们的特殊含义，可以在字符串的其那面加一个字母r"""
print(r'ja\tson\nke\avim')  # ja\tson\nke\avim
\n: 换行
\t: 制表符
```

<h1 id="rulo8">四、列表</h1>
<h2 id="blNT0">4.1 定义</h2>
```python
# 定义：在[]内,用逗号分隔开多个任意数据类型的值
l1 = [1,'a',[1,2]]  # 本质:l1 = list([1,'a',[1,2]])

```

<h2 id="ovH1C">4.3 类型</h2>
```python
"""但凡能被for循环遍历的数据类型都可以传给list()转换成列表类型，list()会跟for循环一样遍历出数据类型中包含的每一个元素然后放到列表中"""

>>> list('wdad') # 结果：['w', 'd', 'a', 'd'] 
>>> list([1,2,3]) # 结果：[1, 2, 3]
>>> list({"name":"jason","age":18}) #结果：['name', 'age']
>>> list((1,2,3)) # 结果：[1, 2, 3] 
>>> list({1,2,3,4}) # 结果：[1, 2, 3, 4]
```



```python
"""
list可以转换支持for循环的数据类型
    可以被for循环的数据类型
        字符串 列表 字典 元祖 集合
        # 不支持for循环：整形 浮点型 布尔值
"""

# 列表无论是添加元素，其实都是索引指向的值在改变，如下图所示
```

<h2 id="oQYnw"><font style="color:rgb(0, 0, 0);">4.4 使用</font></h2>
<h3 id="k5MnP"><font style="color:rgb(0, 0, 0);">优先掌握的操作</font></h3>
```python
# 1.按索引存取值(正向存取+反向存取)：即可存也可以取  
# 1.1 正向取(从左往右)
>>> my_friends=['tony','jason','tom',4,5]
>>> my_friends[0]  
tony
# 1.2 反向取(负号表示从右往左)
>>> my_friends[-1]  
5
# 1.3 对于list来说，既可以按照索引取值，又可以按照索引修改指定位置的值，但如果索引不存在则报错
>>> my_friends = ['tony','jack','jason',4,5]
>>> my_friends[1] = 'martthow'
>>> my_friends
['tony', 'martthow', 'jason', 4, 5]
 
# 2.切片(顾头不顾尾，步长)
# 2.1 顾头不顾尾：取出索引为0到3的元素
>>> my_friends[0:4] 
['tony', 'jason', 'tom', 4]
# 2.2 步长：0:4:2,第三个参数2代表步长，会从0开始，每次累加一个2即可，所以会取出索引0、2的元素
>>> my_friends[0:4:2]  
['tony', 'tom']
 
# 3.长度
>>> len(my_friends)
5
 
# 4.成员运算in和not in
>>> 'tony' in my_friends
True
>>> 'xxx' not in my_friends
True
 
# 5.添加
# 5.1 append()列表尾部追加'单个元素'元素,
# 无论你给我的是啥，我只把你当做单个元素
>>> l1 = ['a','b','c']
>>> l1.append('d')
>>> l1
['a', 'b', 'c', 'd']


>>> l1 = ['a','b','c']
>>> l1.append('[11,22,33]')
>>> (l1)
    ['a', 'b', 'c', '[11,22,33]']
    
# 5.2 extend()一次性在列表尾部添加多个元素,合并多个元素

>>> l1.extend(['a','b','c'])
>>> l1
['a', 'b', 'c', 'd', 'a', 'b', 'c']

l1 = ['a','b','c']
l1.extend([11, 22, 33, 44, 55])
print(l1)
['a', 'b', 'c', 11, 22, 33, 44, 55]

# extend可以看成是for循环加上append
l1 = ['a','b','c']
for i in [11, 22, 33, 44, 55]:
    l1.append(i)
print(l1)
    
# 加+等于号也可以使用，加号效率不高
l1 = ['a','b','c']
l1 += [11, 22, 33, 44, 55]
print(l1)
    ['a', 'b', 'c', 11, 22, 33, 44, 55]
    
# 5.3 insert()在指定位置插入'单个元素'元素
>>> l1.insert(0,"first")  # 0表示按索引位置插值
>>> l1
['first', 'a', 'b', 'c', 'alisa', 'a', 'b', 'c']

>>> l1 = ['a','b','c']
>>> l1.insert(1, [11, 22, 33])
>>> (l1)
['a', [11, 22, 33], 'b', 'c']

 
# 6.删除
# 6.1 del
>>> l = [11,22,33,44]
>>> del l[2]  # 删除索引为2的元素
>>> l
[11,22,44]
 
# 6.2 pop()默认删除列表最后一个元素，并将删除的值返回，括号内可以通过加索引值来指定删除元素
>>> l = [11,22,33,22,44]
>>> res=l.pop()
>>> res
44
>>> res=l.pop(1)  # 还可以指定索引值弹出
>>> res
22

l = [11, 22, 33, 44]
print(l.pop())  # 44 发现还没有死
print(l)
44 
[11, 22, 33] # 发现少了44，这就是尾部默认弹出
 
# 6.3 remove()括号内指名道姓表示要删除哪个元素，没有返回值
# 指明道姓的直接删除元素
>>> l = [11,22,33,22,44]
>>> res=l.remove(22) # 从左往右查找第一个括号内需要删除的元素
>>> print(res)
None
 
l = [11, 22, 33, 44]
l.remove(22)
print(l)
[11, 33, 44]

# 7.reverse()颠倒列表内元素顺序
>>> l = [11,22,33,44]
>>> l.reverse() 
>>> l
[44,33,22,11]
 
# 8.sort()给列表内所有元素排序
# 8.1 排序时列表元素之间必须是相同数据类型，不可混搭，否则报错
>>> l = [11,22,3,42,7,55]
>>> l.sort()
>>> l 
[3, 7, 11, 22, 42, 55]  # 默认从小到大排序
>>> l = [11,22,3,42,7,55]
>>> l.sort(reverse=True)  # reverse用来指定是否跌倒排序，默认为False
>>> l 
[55, 42, 22, 11, 7, 3]

# 翻转
s2 = [22, 44, 11, 55, 99, 66]
s2.reverse()
print(s2)  # [66, 99, 55, 11, 44, 22]

# 8.2 了解知识：
# 我们常用的数字类型直接比较大小，但其实，字符串、列表等都可以比较大小，原理相同：都是依次比较对应位置的元素的大小，如果分出大小，则无需比较下一个元素，比如
>>> l1=[1,2,3]
>>> l2=[2,]
>>> l2 > l1
True
# 字符之间的大小取决于它们在ASCII表中的先后顺序，越往后越大
>>> s1='abc'
>>> s2='az'
>>> s2 > s1 # s1与s2的第一个字符没有分出胜负，但第二个字符'z'>'b',所以s2>s1成立
True
# 所以我们也可以对下面这个列表排序
>>> l = ['A','z','adjk','hello','hea']
>>> l.sort()
>>> l
['A', 'adjk', 'hea', 'hello','z']
 
# 9.循环
# 循环遍历my_friends列表里面的值
for line in my_friends:
    print(line) 
'tony'
'jack'
'jason'
4
5

# 10.修改列表
name_list = ['jason', 'barry', 'tony']
name_list[0] = 'jasonDSB'
print(name_list)
['jasonDSB', 'barry', 'tony']


# 11比较
# 列表在做比较的时候 其实比的是对应索引位置上的元素
s1 = [11, 22, 33]
s2 = [1, 2, 3, 4, 5, 6, 7,]
print(s1 > s2)  # True

s1 = ['A', 'B', 'C']  # A对应的数值就是65
s2 = ['a']            # a对应的数值就是97
print(s1 > s2)        # false



# 12。获取索引值
s2 = [22, 44, 11, 55, 99, 66]
print(s2.index(99))  # 4

# 13. 统计列表中某个元素出现的次数
l1 = [11, 22, 33, 44, 33, 22, 33, 11, 22, 33, 11, 22]
print(l1.count(11))  # 3


# 14. 清空列表
l1 = [11, 22, 33, 44, 33, 22, 33, 11, 22, 33, 11, 22]
l1.clear()
print(l1)
```

![](https://cdn.nlark.com/yuque/0/2022/png/25700096/1662481168216-b67eef65-a686-4885-be98-46802dded749.png)



<h2 id="FbGps">可变类型与不可变类型</h2>
```python
可变类型：值改变，内存地址不变，修改的是本身（list）
不可变类型：值改变，内存地址肯定变 修改过程产生了新的值

# 列表
l2  = [1, 2, 3]
l2.extend([11, 22, 33, 44, 55])  # 本身直接修改了 没有产生新的结果
print(l2.extend([11, 22, 33, 44, 55]))  # None
print(l2)  # [1, 2, 3, 11, 22, 33, 44, 55]

# 字符串
l1 = '$$$jason$$$'
l1.strip('$')  # 字符串调用内置方法，其实就是产生了一个新的结果。本身并没有修改 是产生了新的结果
print(l1.strip('$'))  # jason
print(l1)  # $$$jason$$$


## 如何查看变量的内存地址--内存地址变不变，指的就是指向内存地址的那条线，而不是后面那条线
s2 = [1, 2, 3]
print(id(s2))  # 25454872
s2.append(111111) 
print(id(s2))  # 25454872



s1 = '  jason  '
print(id(s1))
s1.strip()
res = s1.strip()
print(res)
print(s1, id(s1))


31648888
jason
  jason   31648888
```

![](https://cdn.nlark.com/yuque/0/2022/png/25700096/1662557724630-1a9e7c29-578f-4073-b39a-2c9ac973b1d3.png)

<font style="background-color:#FADB14;">我们说的变与不变其实就是这个s1变量与后面那几个值的绑定关系变不变而已。</font>

<font style="background-color:#FADB14;">如果这个线没变，但是后面的值改变了，name就说明踏实一个可变类型。</font>

![](https://cdn.nlark.com/yuque/0/2022/png/25700096/1662558565739-acb0f872-3234-41e8-bcca-9f6b9e6c678c.png)





总结：

<font style="color:rgb(119, 119, 119);background-color:#01B2BC;">1.可变数据类型：list（列表）、dict（字典）</font>

<font style="color:rgb(51, 51, 51);background-color:#01B2BC;">2.不可变数据类型：数值类型（int、float、bool）、string（字符串）、tuple（元组）</font>

**<font style="color:rgb(51, 51, 51);background-color:#01B2BC;">3.可变数据类型更改值后，内存地址不发生改变；不可变数据类型更改值后，内存地址发生改变</font>**

  
 参考链接：[https://cloud.tencent.com/developer/article/1597867](https://cloud.tencent.com/developer/article/1597867)

<h1 id="yoyBV">五、队列、堆栈</h1>
```python
# 1. 队列
    先进先出   ###实际用队列比较多


        ## 示例---> 队列
        new_list = []
        # 先进
        new_list.append(111)
        new_list.append(222)
        new_list.append(333)
        # 先出
        for i in new_list:
            print(i)
         
        或者
        print(new_list.pop(0))
        print(new_list.pop(0))
        print(new_list.pop(0))
        
        111
        222
        333
    

# 2. 堆栈
    先进后出
        # 堆栈
        new_list = []
        # 先进
        new_list.append(111)
        new_list.append(222)
        new_list.append(333)
        print(new_list.pop())
        print(new_list.pop())
        print(new_list.pop())
    
        333
        222
        111
```

<h2 id="sEBWO">案例</h2>
```python
# 利用列表编写一个用户注册、登录程序
#       提示：循环
#       要求：成功一次即可 无需考虑用户冲突等情况

# 1. 先定义一个用于存储用户数据的列表
data_list = []
# 循环打印程序的功能，供用户选择
while True:
    # 打印程序中所有的编号
    print("""
    1.注册
    2.登录
    3.查看用户
    """)
    # 4. 获取用户想要执行的功能编号
    choice = input('请输入功能编号>>>:').strip()
    # 5. 判断用户想要执行的功能
    if choice == '1':
        print('注册功能')
        # 6. 获取用户的用户名和密码
        username = input('username>>>:').strip()
        password = input('password>>>:').strip()
        # 6.1 判断用户名不能冲突
        for user in data_list:  # 'jason|123'  'tony|123'
            # 6.2 如果考虑密码是用户名  用户名是其他
            if username == user.split('|')[0]:
                print('用户名已存在')
                break
        else:

            # 7. 将用户名和密码拼接到一起
            user_data = f'{username}|{password}'  # 'barry|123'
            # 8.添加到列表中
            data_list.append(user_data)
            # 9.提示用户注册成功
            print(f'{username}注册成功')


    elif choice == '2':
        # 10. 获取用户名和密码
        username = input('username>>>:').strip()
        password = input('password>>>:').strip()
        # 11. 两种思路： 思路1：先比对用户名，在比对密码  思路2：直接拼接比对整体结果
        user_data1 = f'{username}|{password}'
        # 循环比对
        for data in data_list:
            if user_data1 == data:
                print('登录成功')
                break
        else:
            print('用户名或者密码错误')



    elif choice == '3':
        print(data_list)
    else:
        print('你能不能好好输入')

```



<h4 id="gu6ES">案例</h4>
```python
# 3. 不使用count 统计列表种指定的元素出现的次数
l1 = [11, 22, 33, 44, 11, 22, 33, 44, 11, 11, 22, 22, 33, 44, 11, 11, 44, 44, 33, 33, 22, 11, 11]
# 获取用户想要统计的元素
target = input('请输入你想要统计的元素>>>:').strip()
if target.isdigit():
    target = int(target)
    # 定义一个计数器
    count = 0
    # 循环判断元素是否相等
    for i in l1:
        if target == i:
            # 计数器自增1
             count += 1
    # 判断元素出现了几次
    print(f'{target}出现了{count}次')
```

<h1 id="jQazL">六、字典</h1>
<h2 id="wgJxK"><font style="color:rgb(0, 0, 0);">定义方式</font></h2>
```python
# 定义：在{}内用逗号分隔开多元素，每一个元素都是key:value的形式，其中value可以是任意类型，而key则必须是不可变类型，详见第八小节，通常key应该是str类型，因为str类型会对value有描述性的功能
# k是不可变类型 ===整形 浮点型 字符串
        print({1: 1, 2: 2})
        print({1: 1, 2: 2.2})
        print({1.32: 1, 2: 2.2})
info={'name':'tony','age':18,'sex':'male'} #本质info=dict({....})
# 也可以这么定义字典
info=dict(name='tony',age=18,sex='male') # info={'age': 18, 'sex': 'male', 'name': 'tony'}
```

<h2 id="xnZa6"><font style="color:rgb(0, 0, 0);">类型转换</font></h2>
```python
# 转换1: 
>>> info=dict([['name','tony'],('age',18)])
>>> info
{'age': 18, 'name': 'tony'}

info=dict([['name','tony'],['age',18]])
print(info)
 
# 转换2：fromkeys会从元组中取出每个值当做key，然后与None组成key:value放到字典中
>>> {}.fromkeys(('name','age','sex'),None)  
{'age': None, 'sex': None, 'name': None}
```

<h2 id="GZbch"><font style="color:rgb(0, 0, 0);">使用===字典也是可变类型</font></h2>
<h3 id="vjBx6"><font style="color:rgb(0, 0, 0);">优先掌握的操作 </font></h3>
```python
# 1、按key存取值：可存可取
# 1.1 取
>>> dic = {
...     'name': 'xxx',
...     'age': 18,
...     'hobbies': ['play game', 'basketball']
... }
>>> dic['name']
'xxx'
>>> dic['hobbies'][1]
'basketball'
# 1.2 对于赋值操作，如果key原先不存在于字典，则会新增key:value
>>> dic['gender'] = 'male'  
>>> dic
{'name': 'tony', 'age': 18, 'hobbies': ['play game', 'basketball'],'gender':'male'}
# 1.3 对于赋值操作，如果key原先存在于字典，则会修改对应value的值
>>> dic['name'] = 'tony'
>>> dic
{'name': 'tony', 'age': 18, 'hobbies': ['play game', 'basketball']}
 
# 2、长度len
>>> len(dic) 
3
 
# 3、成员运算in和not in
>>> 'name' in dic  # 判断某个值是否是字典的key
True
 
# 4、删除键值对

del d1['name']
print(d1)



>>> dic.pop('name')  # 通过指定字典的key来删除字典的键值对
>>> dic
{'age': 18, 'hobbies': ['play game', 'basketball']}
 
# 5、键keys()，值values()，键值对items()
>>> dic = {'age': 18, 'hobbies': ['play game', 'basketball'], 'name': 'xxx'}
# 获取字典所有的key
>>> dic.keys()  
dict_keys(['name', 'age', 'hobbies'])
# 获取字典所有的value
>>> dic.values()
dict_values(['xxx', 18, ['play game', 'basketball']])
# 获取字典所有的键值对
>>> dic.items()
dict_items([('name', 'xxx'), ('age', 18), ('hobbies', ['play game', 'basketball'])])
 
# 6、循环
# 6.1 默认遍历的是字典的key
>>> for key in dic:
...     print(key)
... 
age
hobbies
name
# 6.2 只遍历key
>>> for key in dic.keys():
...     print(key)
... 
age
hobbies
name
# 6.3 只遍历value
>>> for key in dic.values():
...     print(key)
... 
18
['play game', 'basketball']
xxx
# 6.4 遍历key与value
>>> for key in dic.items():
...     print(key)
... 
('age', 18)
('hobbies', ['play game', 'basketball'])
('name', 'xxx')


    print(d1.keys())
    print(d1.values())
    print(d1.items())

    for i in d1.values():
        print(i)
     
    
    dict_keys(['name', 'age', 'hobbies'])
    dict_values(['jason', 18, ['play game', 'basketball']])
    dict_items([('name', 'jason'), ('age', 18), ('hobbies', ['play game', 'basketball'])])
    jason
    18
    ['play game', 'basketball']


# 注意在python2中所有只返回一个列表
```

<h3 id="l0qOJ"><font style="color:rgb(0, 0, 0);">需要掌握的操作</font></h3>
**<font style="color:rgb(0, 0, 0);">1.get()</font>**

```python
>>> dic= {'k1':'jason','k2':'Tony','k3':'JY'}
>>> dic.get('k1')
'jason'  # key存在，则获取key对应的value值
>>> res=dic.get('xxx') # key不存在，不会报错而是默认返回None
>>> print(res)
None  
>>> res=dic.get('xxx',666) # key不存在时，可以设置默认返回的值
>>> print(res)
666 
# ps:字典取值建议使用get方法


#print(d1.get('name'))   # jason 键存在
#print(d1.get('xxx'))   # None 键不存在不会报错 而是返回none
# print(d1.get('xxx', '这个键不存在'))  # 第二个参数不写默认就会返回None，写了则返回写了的
# print(d1.get('name', '这个键不存在'))  #如果键存在，则不需要使用到第二个参数
```

**<font style="color:rgb(0, 0, 0);">2.pop()</font>**

```python
>>> dic= {'k1':'jason','k2':'Tony','k3':'JY'}
>>> v = dic.pop('k2')  # 删除指定的key对应的键值对,并返回值
>>> dic
{'k1': 'jason', 'kk2': 'JY'}
>>> v
'Tony'
```

**<font style="color:rgb(0, 0, 0);">3.update()</font>**<font style="color:rgb(0, 0, 0);"> </font>

```python
# 用新字典更新旧字典，有则修改，无则添加
>>> dic= {'k1':'jason','k2':'Tony','k3':'JY'}
>>> dic.update({'k1':'JN','k4':'xxx'})
>>> dic
{'k1': 'JN', 'k3': 'JY', 'k2': 'Tony', 'k4': 'xxx'}
```

**<font style="color:rgb(0, 0, 0);">4.fromkeys()</font>**

```python
>>> dic = dict.fromkeys(['k1','k2','k3'],[])
>>> dic
{'k1': [], 'k2': [], 'k3': []}
```

**<font style="color:rgb(0, 0, 0);">5.setdefault()</font>**

```python
# key不存在则新增键值对，并将新增的value返回
>>> dic={'k1':111,'k2':222}
>>> res=dic.setdefault('k3',333)
>>> res
333
>>> dic # 字典中新增了键值对
{'k1': 111, 'k3': 333, 'k2': 222}
 
# key存在则不做任何修改，并返回已存在key对应的value值
>>> dic={'k1':111,'k2':222}
>>> res=dic.setdefault('k1',666)
>>> res
111
>>> dic # 字典不变
{'k1': 111, 'k2': 222}
```

<h1 id="PzkW9">七、元组</h1>
<h2 id="hOHqL">类型转换</h2>
```python
# 可以看成不可变的列表
# 支持for循环的数据类型都可以转换成元组

>> t1 = ("tom","jack",[1,2])
>>> t1[0]='TOM' # 报错：TypeError
>>> t1.append('lili') # 报错：TypeError
# 元组内的元素无法修改，指的是元组内索引指向的内存地址不能被修改
>>> t1 = ("tom","jack",[1,2])
>>> id(t1[0]),id(t1[1]),id(t1[2])
(4327403152, 4327403072, 4327422472)
>>> t1[2][0]=111 # 如果元组中存在可变类型，是可以修改，但是修改后的内存地址不变
>>> t1
('tom', 'jack', [111, 2])
>>> id(t1[0]),id(t1[1]),id(t1[2]) # 查看id仍然不变
(4327403152, 4327403072, 4327422472)



t = (11, 22, 33, 44)

# print(tuple(11.11))  # 报错
print(tuple([11,22,33,44]))
print(tuple({'name': 'jason'}))
print(tuple({11,22,33,44}))
# print(tuple(True))  # 报错
```

<h2 id="ATQnl">元组特性</h2>
```python
t1 = (11, 22, 33, 44)
print(type(t1))
    <class 'tuple'>
    
    
t2 = (11)
print(type(t2))
    <class 'int'> 
    
    
# 当元组内只有一个元素时候，不能只写这一个元素，一定要加上逗号

t2 = (11,)
print(type(t2))
    <class 'tuple'>
    
    
# 一般情况下 我们会习惯性的将所有可以存储多个数据的类型的数据 
# 如果内部只有一个元素，也会加逗号
```

![](https://cdn.nlark.com/yuque/0/2022/png/25700096/1663164602280-06189941-a5a6-48b5-af43-4b5475c0a019.png)

```python
t1 = (11, 22, 33, 44, 55, 66)
# 1.索引取值
print(t1[0])
# 2. 切片
print(t1[1:4])
print(t1[-4:-1])
#3. 间隔
print(t1[1:4:2])
#4.统计
print(len(t1))
# 5.成员运算
print((11 in t1))  # True
# 6. 统计某个元素出现的次数
print(t1.count(22))
# 7.元组内元素不能"修改":元组内各个索引值指向的内存地址不能修改
t1[0] = 111
"""
笔试题
    tt = (11, 22, 33, [11, 22])
    tt[-1].append('heiheihei')
    问执行之后的结果是
    A:报错 B：正常添加 C： 不变   正确答案是B
"""


tt = (11, 22, 33, [11, 22])
print(id(tt[-1]))
tt[-1].append('heiheihei')
print(id(tt[-1]))
print(tt)

    26962160
    26962160
    (11, 22, 33, [11, 22, 'heiheihei'])
```

<h4 id="WZdxd">分析图如下</h4>
![](https://cdn.nlark.com/yuque/0/2022/png/25700096/1663164894945-842a88dc-1651-4e3a-8f08-69a840f028d5.png)

<h1 id="EnrlH">八、集合</h1>
```python
### 1.类型转换

# print(set(11))  # 报错
# print(set(11.11))  # 报错
print(set('jason'))
print(set([11, 22, 33, 44]))
print(set({'name': 'jason'}))
print(set((11, 22, 33)))
# print(set(True))  # 报错
#集合内的元素只能是不可变类型

# 但凡能被for循环的遍历的数据类型（强调：遍历出的每一个值都必须为不可变类型）都可以传给set()转换成集合类型
>>> s = set([1,2,3,4])
>>> s1 = set((1,2,3,4))
>>> s2 = set({'name':'jason',})
>>> s3 = set('oscar')
>>> s,s1,s2,s3
{1, 2, 3, 4} {1, 2, 3, 4} {'name'} {'e', 'o', 'g', 'n'}


### 2. 两大特性
    1.去重
        集合内不能出现重复的元素（自带去重属性）
        如果出现了会被集合自动去重
    2. 关系运算
        判断两个群体内的差异

    
#集合只有在去重和关系运算中使用，甚至有时候也不用
```

<h2 id="ayYlN"><font style="color:rgb(0, 0, 0);">使用</font></h2>
<h3 id="M8wPJ"><font style="color:rgb(0, 0, 0);">关系运算</font></h3>
<font style="color:rgb(0, 0, 0);">我们定义两个集合friends与friends2来分别存放两个人的好友名字，然后以这两个集合为例讲解集合的关系运算</font>

```python
"""
一.关系运算
　　有如下两个集合，pythons是报名python课程的学员名字集合，linuxs是报名linux课程的学员名字集合
　　pythons={'jason','egon','kevin','ricky','gangdan','biubiu'}
　　linuxs={'kermit','tony','gangdan'}
　　1. 求出即报名python又报名linux课程的学员名字集合
　　2. 求出所有报名的学生名字集合
　　3. 求出只报名python课程的学员名字
　　4. 求出没有同时这两门课程的学员名字集合
"""
# 求出即报名python又报名linux课程的学员名字集合
>>> pythons & linuxs
# 求出所有报名的学生名字集合
>>> pythons | linuxs
# 求出只报名python课程的学员名字
>>> pythons - linuxs
# 求出没有同时这两门课程的学员名字集合
>>> pythons ^ linuxs
```

```python
>>> friends1 = {"zero","kevin","jason","oscar"} # 用户1的好友们 
>>> friends2 = {"Jy","ricky","jason","oscar"}   # 用户2的好友们
 
两个集合的关系如下图所示
```

<font style="color:rgb(0, 0, 0);">两个集合的关系如下图所示</font>

```python
# 1.合集(|)：求两个用户所有的好友（重复好友只留一个）
>>> friends1 | friends2
{'kevin', 'ricky', 'zero', 'jason', 'Jy', 'oscar'}
 
# 2.交集(&)：求两个用户的共同好友
>>> friends1 & friends2
{'jason', 'oscar'}
 
# 3.差集(-)：
>>> friends1 - friends2 # 求用户1独有的好友
{'kevin', 'zero'}
>>> friends2 - friends1 # 求用户2独有的好友
{'ricky', 'Jy'}
 
# 4.对称差集(^) # 求两个用户独有的好友们（即去掉共有的好友）
>>> friends1 ^ friends2
{'kevin', 'zero', 'ricky', 'Jy'}
 
# 5.值是否相等(==)
>>> friends1 == friends2
False
 
# 6.父集：一个集合是否包含另外一个集合
# 6.1 包含则返回True
>>> {1,2,3} > {1,2}
True
>>> {1,2,3} >= {1,2}
True
# 6.2 不存在包含关系，则返回True
>>> {1,2,3} > {1,3,4,5}
False
>>> {1,2,3} >= {1,3,4,5}
False
 
 
# 7.子集
>>> {1,2} < {1,2,3}
True
>>> {1,2} <= {1,2,3}
True
```

<h3 id="BSuUc"><font style="color:rgb(0, 0, 0);">去重</font></h3>
<font style="color:rgb(0, 0, 0);">集合去重复有局限性</font>

```python
# 1. 只能针对不可变类型
# 2. 集合本身是无序的，去重之后无法保留原来的顺序
 

```

<font style="color:rgb(0, 0, 0);">示例如下</font>

```python
>>> l=['a','b',1,'a','a']
>>> s=set(l)
>>> s # 将列表转成了集合
{'b', 'a', 1}
>>> l_new=list(s) # 再将集合转回列表
>>> l_new
['b', 'a', 1] # 去除了重复，但是打乱了顺序
 
# 针对不可变类型，并且保证顺序则需要我们自己写代码实现，例如
l=[
    {'name':'lili','age':18,'sex':'male'},
    {'name':'jack','age':73,'sex':'male'},
    {'name':'tom','age':20,'sex':'female'},
    {'name':'lili','age':18,'sex':'male'},
    {'name':'lili','age':18,'sex':'male'},
]
 
new_l=[]
 
for dic in l:
    if dic not in new_l:
        new_l.append(dic)
 
print(new_l)
# 结果：既去除了重复，又保证了顺序，而且是针对不可变类型的去重
[
    {'age': 18, 'sex': 'male', 'name': 'lili'}, 
    {'age': 73, 'sex': 'male', 'name': 'jack'}, 
    {'age': 20, 'sex': 'female', 'name': 'tom'}
```

<h3 id="uVAqa"><font style="color:rgb(0, 0, 0);">其他操作</font></h3>
```python
# 1.长度
>>> s={'a','b','c'}
>>> len(s)
3
 
# 2.成员运算
>>> 'c' in s
True
 
# 3.循环
>>> for item in s:
...     print(item)
... 
c
a
b
```

```python
>>> l=['a','b',1,'a','a']
>>> s=set(l)
>>> s # 将列表转成了集合
{'b', 'a', 1}
>>> l_new=list(s) # 再将集合转回列表
>>> l_new
['b', 'a', 1] # 去除了重复，但是打乱了顺序
 
# 针对不可变类型，并且保证顺序则需要我们自己写代码实现，例如
l=[
    {'name':'lili','age':18,'sex':'male'},
    {'name':'jack','age':73,'sex':'male'},
    {'name':'tom','age':20,'sex':'female'},
    {'name':'lili','age':18,'sex':'male'},
    {'name':'lili','age':18,'sex':'male'},
]
 
new_l=[]
 
for dic in l:
    if dic not in new_l:
        new_l.append(dic)
 
print(new_l)
# 结果：既去除了重复，又保证了顺序，而且是针对不可变类型的去重
[
    {'age': 18, 'sex': 'male', 'name': 'lili'}, 
    {'age': 73, 'sex': 'male', 'name': 'jack'}, 
    {'age': 20, 'sex': 'female', 'name': 'tom'}
]
```

<h5 id="YW2lk">练习题</h5>
```python
# 1.合集(|)：求两个用户所有的好友（重复好友只留一个）
>>> friends1 | friends2
{'kevin', 'ricky', 'zero', 'jason', 'Jy', 'oscar'}
 
# 2.交集(&)：求两个用户的共同好友
>>> friends1 & friends2
{'jason', 'oscar'}
 
# 3.差集(-)：
>>> friends1 - friends2 # 求用户1独有的好友
{'kevin', 'zero'}
>>> friends2 - friends1 # 求用户2独有的好友
{'ricky', 'Jy'}
 
# 4.对称差集(^) # 求两个用户独有的好友们（即去掉共有的好友）
>>> friends1 ^ friends2
{'kevin', 'zero', 'ricky', 'Jy'}
 
# 5.值是否相等(==)
>>> friends1 == friends2
False
 
# 6.父集：一个集合是否包含另外一个集合
# 6.1 包含则返回True
>>> {1,2,3} > {1,2}
True
>>> {1,2,3} >= {1,2}
True
# 6.2 不存在包含关系，则返回True
>>> {1,2,3} > {1,3,4,5}
False
>>> {1,2,3} >= {1,3,4,5}
False
 
 
# 7.子集
>>> {1,2} < {1,2,3}
True
>>> {1,2} <= {1,2,3}
True
```

```python
>>> l=['a','b',1,'a','a']
>>> s=set(l)
>>> s # 将列表转成了集合
{'b', 'a', 1}
>>> l_new=list(s) # 再将集合转回列表
>>> l_new
['b', 'a', 1] # 去除了重复，但是打乱了顺序
 
# 针对不可变类型，并且保证顺序则需要我们自己写代码实现，例如
l=[
    {'name':'lili','age':18,'sex':'male'},
    {'name':'jack','age':73,'sex':'male'},
    {'name':'tom','age':20,'sex':'female'},
    {'name':'lili','age':18,'sex':'male'},
    {'name':'lili','age':18,'sex':'male'},
]
 
new_l=[]
 
for dic in l:
    if dic not in new_l:
        new_l.append(dic)
 
print(new_l)
# 结果：既去除了重复，又保证了顺序，而且是针对不可变类型的去重
[
    {'age': 18, 'sex': 'male', 'name': 'lili'}, 
    {'age': 73, 'sex': 'male', 'name': 'jack'}, 
    {'age': 20, 'sex': 'female', 'name': 'tom'}
]
```

