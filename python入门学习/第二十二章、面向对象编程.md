

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1682414239662-4c5d27c7-e204-439d-bd04-60927241c304.png)

<h1 id="n2f1A">一、什么是对象？</h1>
```python

'''
面向过程：
    过程的核心思想就是将程序流程化
    核心是"过程"两字，过程就是流水线，用来分步骤解决问题的



面向对象： 
    核心是"对象"二字
    对象的终极奥义就是将程序"整合"
    对象是"容器",用来盛放数据与功能。

python这门语言到底提供了什么语法允许我们将数据与功能很好的整合到一起???


类: 也是"容器"，该容器用来存放同类对象所共有的数据与功能

'''

```

<font style="color:rgb(18, 18, 18);">所有的程序都是由”数据”与“功能“组成，因而编写程序的本质就是定义出一系列的数据，然后定义出一系列的功能来对数据进行操作。在学习”对象“之前，程序中的数据与功能是分离开的，如下</font>



```python

# 程序=数据 + 功能

# 学生的容器=学生的数据+ 学生的功能
# 课程的容器=课程的数据 + 课程的功能 


# 学生数据


# 学生的功能
def tell_stu_info(stu_obj):
    print('名字：%s 年龄： %d 性别： %s' %(
        stu_obj['stu_name'], 
        stu_obj['stu_age'], 
        stu_obj['stu_gender']
    ))


def set_info(stu_obj,x,y,z):
    stu_obj['stu_name']=x
    stu_obj['stu_age']=y
    stu_obj['stu_gender']=z


# 基于整合的思想进行简单整合到容器，这样就可以删除上面定义的学生的数据变量，但是功能不能删除，所以这样还是不够优秀。
stu_obj={
    'stu_school': 'oldboy'
    'stu_name':'egon', 
    'stu_age':18, 
    'stu_gender':'male', 
    'tell_stu_info':tell_stu_info, 
    'set_info':set_info
}



stu1_obj={
    'stu_school': 'oldboy'
    'stu_name':'lili', 
    'stu_age':18, 
    'stu_gender':'female', 
    'tell_stu_info':tell_stu_info, 
    'set_info':set_info
}

```

<font style="color:rgb(18, 18, 18);">在学习了“对象”之后，我们就有了一个容器，该容器可以盛放数据与功能，所以我们可以说：对象是把数据与功能整合到一起的产物，或者说”对象“就是一个盛放数据与功能的容器/箱子/盒子。</font>

<font style="color:rgb(18, 18, 18);">如果把”数据“比喻为”睫毛膏“、”眼影“、”唇彩“等化妆所需要的原材料；把”功能“比喻为眼线笔、眉笔等化妆所需要的工具，那么”对象“就是一个彩妆盒，彩妆盒可以把”原材料“与”工具“都装到一起</font>

![](https://cdn.nlark.com/yuque/0/2023/webp/25700096/1682414366637-accd0f47-859c-4576-9be9-77990a536d00.webp)

<font style="color:rgb(18, 18, 18);">如果我们把”化妆“比喻为要执行的业务逻辑，此时只需要拿来一样东西即可，那就是彩妆盒，因为彩妆盒里整合了化妆所需的所有原材料与功能，这比起你分别拿来原材料与功能才能执行，要方便的多。</font>

<font style="color:rgb(18, 18, 18);">  
</font><font style="color:rgb(18, 18, 18);"> 在了解了对象的基本概念之后，理解面向对象的编程方式就相对简单很多了，面向对象编程就是要造出一个个的对象，把原本分散开的相关数据与功能整合到一个个的对象里，这么做既方便使用，也可以提高程序的解耦合程度，进而提升了程序的可扩展性（需要强调的是，软件质量属性包含很多方面，面向对象解决的仅仅只是扩展性问题）</font>

![](https://cdn.nlark.com/yuque/0/2023/webp/25700096/1682414392232-524e4aca-0acb-4e61-9950-5095d0065032.webp)

<h2 id="M2G62"><font style="color:rgb(18, 18, 18);">二 类与对象</font></h2>
<font style="color:rgb(18, 18, 18);">类即类别/种类，是面向对象分析和设计的基石，如果多个对象有相似的数据与功能，那么该多个对象就属于同一种类。有了类的好处是：我们可以把同一类对象相同的数据与功能存放到类里，而无需每个对象都重复存一份，这样每个对象里只需存自己独有的数据即可，极大地节省了空间。</font><font style="color:#DF2A3F;">所以，如果说对象是用来存放数据与功能的容器，那么类则是用来存放多个对象相同的数据与功能的容器。</font>

![](https://cdn.nlark.com/yuque/0/2023/webp/25700096/1682414407046-19f3d4a8-ddb0-434e-bfad-2401373208e3.webp)

<font style="color:#DF2A3F;">综上所述，虽然我们是先介绍对象后介绍类，但是需要强调的是：在程序中，必须要事先定义类，然后再调用类产生对象（调用类拿到的返回值就是对象）</font><font style="color:rgb(18, 18, 18);">。产生对象的类与对象之间存在关联，这种关联指的是：对象可以访问到类中共有的数据与功能，所以类中的内容仍然是属于对象的，类只不过是一种节省空间、减少代码冗余的机制，面向对象编程最终的核心仍然是去使用对象。</font>

<font style="color:rgb(18, 18, 18);">在了解了类与对象这两大核心概念之后，我们就可以来介绍一下面向对象编程啦</font>

<font style="color:rgb(18, 18, 18);background-color:#FBDE28;">类体代码在定义阶段就执行了，就产生了类体的名称空间。</font>

<font style="color:rgb(18, 18, 18);background-color:#FBDE28;">类中最常见是变量和函数的定义</font>

<font style="color:rgb(18, 18, 18);"></font>

<h2 id="rcCMJ"><font style="color:rgb(18, 18, 18);">三 面向对象编程</font></h2>
+ <font style="color:rgb(18, 18, 18);">1、类的定义与实例化</font>
    - 调用类的过程又称之为实例化,发生了三件事？

<font style="background-color:#74B602;"> 1）先产生了一个空对象</font>

<font style="background-color:#74B602;"> 2） python会自动调用类中的__init__方法将空对象以及调用类时括号内传入的参数一同传给__init__方法</font>

<font style="background-color:#74B602;"> 3) 返回初始化完的对象</font>

+ <font style="color:rgb(18, 18, 18);">2、属性访问</font>
    - <font style="color:rgb(18, 18, 18);">在类中定义的名字，都是类的属性，细说的话，</font><font style="color:#DF2A3F;">类有两种属性：数据属性和函数属性</font><font style="color:rgb(18, 18, 18);">，可以通过__dict__访问属性的值，比如Student.__dict__[‘school’]，但Python提供了专门的属性访问语法</font>

```python

# I、属性访问的原理

# 1）访问数据属性
print(Student.stu_school)  # Student.__dict__['stu_school']

# 2） 访问函数属性
print(Student.set_info)  # Student.__dict__['set_info']

```



<font style="color:rgb(18, 18, 18);background-color:#FBDE28;">至此，我们造出了三个对象与一个类，对象存放各自独有的数据，类中存放对象们共有的内容</font>

![](https://cdn.nlark.com/yuque/0/2023/webp/25700096/1682414928960-825a5f3b-c428-4633-8fd8-94ee804278fa.webp)

<h2 id="dnh1v"><font style="color:rgb(18, 18, 18);">3.1 类的定义与实例化</font></h2>

```python

# 一、先定义类（提取公共属性和功能）,类名建议使用驼峰体

# 类是对象相似数据与功能的集合体，所以类中最常见的是变量与函数的定义，但是类体其实是可以包含任意其他代码的
# 注意： 类体代码是再类定义阶段就会立即执行，会产生类的名称空间

# 类的命名应该使用“驼峰体”
class Student:  
    # 1、变量的定义
    stu_school='oldboy'

    # 2、功能的定义
    def tell_stu_info(stu_obj):
        print('名字：%s 年龄： %d 性别： %s' %(
            stu_obj['stu_name'], #stu1_obj.__dict__['stu_name']
            stu_obj['stu_age'], 
            stu_obj['stu_gender']
        ))


    def set_info(stu_obj,x,y,z):
        stu_obj['stu_name']=x
        stu_obj['stu_age']=y
        stu_obj['stu_gender']=z

    # print('=============>')

# Student.__dict__查看类中盛放的东西
print(Student.__dict__)
print(Student.__dict__['stu_school'])
print(Student.__dict__['set_info'])


# I、属性访问的原理

# 1）访问数据属性
print(Student.stu_school)  # 等同于Student.__dict__['stu_school']

# 2） 访问函数属性
print(Student.set_info)  # 等同于Student.__dict__['set_info']



# 二、再调用类产生对象

stu1_obj=Student()  # 用这个类造一个对象
stu2_obj=Student()
stu3_obj=Student()

# 刚开始造了一个对象，里面是空的
# print(stu1_obj.__dict__)
# print(stu2_obj.__dict__)
# print(stu3_obj.__dict__)


# 三、为对象定制自己独有的属性

# 问题一：代码重复
# 问题二： 属性的查找顺序

stu1_obj.stu_name='egon'    #等同于stu1_obj.__dict__['stu_name']='egon'
stu1_obj.stu_age=20         #等同于stu1_obj.__dict__['stu_age']=20
stu1_obj.stu_gender='male'  #等同于stu1_obj.__dict__['stu_gender']='male'
print(stu1_obj.__dict__)


stu2_obj.stu_name='lili'    
stu2_obj.stu_age=30        
stu2_obj.stu_gender='female'  
print(stu2_obj.__dict__)


stu3_obj.stu_name='tom'    
stu3_obj.stu_age=40        
stu3_obj.stu_gender='male'  
print(stu3_obj.__dict__)

```

**<font style="background-color:#5C8D07;">解决问题一：</font>**

解决方案一：但是这样的效果还不是很好

```python

def init(obj,x,y,z):
    obj.stu_name=x   
    obj.stu_age=y        
    obj.stu_gender=z 


init(stu1_obj, 'egon', 20, 'male')
init(stu2_obj, 'lili', 30, 'female')
init(stu3_obj, 'tom', 40, 'male')

print(stu1_obj.__dict__)

```



解决方案二：彻底解决 

```python

# 一、先定义类（提取公共属性和功能）,类名建议使用驼峰体

class Student:
    # 1、变量的定义
    stu_school='oldboy'

    # __init__在类调用阶段自动触发
    # 空对象, 'egon', 20, 'male'
    def __init__(obj,x,y,z):
        obj.stu_name=x   # 空对象.stu_name='egon'
        obj.stu_age=y    # 空对象.stu_age=20
        obj.stu_gender=z # 空对象.stu_gender='male'

    # 2、功能的定义
    def tell_stu_info(stu_obj):
        print('名字：%s 年龄： %d 性别： %s' %(
            stu_obj['stu_name'], 
            stu_obj['stu_age'], 
            stu_obj['stu_gender']
        ))


    def set_info(stu_obj,x,y,z):
        stu_obj['stu_name']=x
        stu_obj['stu_age']=y
        stu_obj['stu_gender']=z




# 二、再调用类产生对象

# 调用类的过程又称之为实例化,发生了三件事？
# 1）先产生了一个空对象（这个空对象是看不见的，python底层自己实现的）
# 2） python会自动调用类中的__init__方法将空对象以及调用类时括号内传入的参数一同传给__init__方法
# 3) 返回初始化完的对象

stu1_obj=Student('egon', 20, 'male')  # 只要你调用类了，就会自动把空对象传进去，Student.__init__(空对象, 'egon', 20, 'male')，你只需要在括号内传入其他参数即可
stu2_obj=Student('lili', 30, 'female')
stu3_obj=Student('tom', 40, 'male')

print(stu1_obj.__dict__)
print(stu2_obj.__dict__)
print(stu3_obj.__dict__)





```

<h3 id="kGE5m">总结__init__方法</h3>

```python

# 1、会在调用类时自动触发执行，用来为对象初始化自己独有的数据
# 2、__init__内应该存放的是为对象初始化属性的功能，但是是可以存放任意其他代码，想要在类调用时就立刻执行的代码都可以放到该方法内
# 3、__init__方法必须返回None，不能返回别的值
# 4 但是没有必要在__init__方法中书写return None

```

<h2 id="PSiwD"><font style="color:rgb(18, 18, 18);">3.2 属性访问</font></h2>
<h3 id="ZPfCJ"><font style="color:rgb(18, 18, 18);">3.2.1 类属性与对象属性</font></h3>
<font style="color:rgb(18, 18, 18);">在类中定义的名字，都是类的属性，细说的话，类有两种属性：数据属性和函数属性，可以通过__dict__访问属性的值，比如Student.__dict__[‘school’]，但Python提供了专门的属性访问语法</font>

```python

>>> Student.school # 访问数据属性，等同于Student.__dict__['school']
'清华大学'
>>> Student.choose # 访问函数属性，等同于Student.__dict__['choose']
<function Student.choose at 0x1018a2950>
# 除了查看属性外，我们还可以使用Student.attrib=value(修改或新增属性),用del Student.attrib删除属性。

```

<font style="color:rgb(18, 18, 18);">操作对象的属性也是一样</font>

```python

>>> stu1.name # 查看，等同于obj1.__dict__[‘name']
'李建刚'
>>> stu1.course=’python’ # 新增，等同于obj1.__dict__[‘course']='python'
>>> stu1.age=38 # 修改，等同于obj1.__dict__[‘age']=38
>>> del obj1.course # 删除，等同于del obj1.__dict__['course']

```

<h3 id="OWgp1"><font style="color:rgb(18, 18, 18);">3.2.2 属性查找顺序与绑定方法</font></h3>
<font style="color:rgb(18, 18, 18);">对象的名称空间里只存放着对象独有的属性，而对象们相似的属性是存放于类中的。对象在访问属性时，会优先从对象本身的__dict__中查找，未找到，则去类的__dict__中查找</font>

```python


class Student:
    # 1、变量的定义
    stu_school='oldboy'
    count=0

    # __init__在类调用阶段自动触发
    # 空对象, 'egon', 20, 'male'
    def __init__(self,x,y,z):
        Student.count+=1  # 每实例化一次加1
        self.stu_name=x   # 空对象.stu_name='egon'
        self.stu_age=y    # 空对象.stu_age=20
        self.stu_gender=z # 空对象.stu_gender='male'

    # 2、功能的定义
    def tell_stu_info(self):
        print('名字：%s 年龄： %d 性别： %s' %(
            self.stu_name, 
            self.stu_age, 
            self.stu_gender
        ))


    def set_info(self,x,y,z):
        self.stu_name=x
        self.stu_age=y
        self.stu_gender=z

    # obj 用来接收绑定方法调用时自动传入那个对象，标准是self
    # 但凡在类中定义的函数，就必须有一个固定的参数self
    def choose(self,x):
        print('正在选课')
        self.course=x




stu1_obj=Student('egon', 20, 'male')  # 只要你调用类了，就会自动把空对象传进去，Student.__init__(空对象, 'egon', 20, 'male')，你只需要在括号内传入其他参数即可
stu2_obj=Student('lili', 30, 'female')
stu3_obj=Student('tom', 40, 'male')

# 实例化一次就加1
print(stu1_obj.count) # 3
print(stu2_obj.count) # 3
print(stu3_obj.count) # 3

# # # 属性查找，先从对象里面查找，再从类里面查找
print(stu1_obj.stu_name) # egon
print(stu1_obj.stu_age)  # 20
print(stu1_obj.stu_gender) # male
print(stu1_obj.stu_school)  # oldboy


# 类中存放的是对象共有的数据与功能
# 一、类可以访问: 
# 1、类的数据属性
# 2、类的函数属性
print(Student.stu_school)
print(Student.tell_stu_info)
print(Student.set_info)
# 输出
# oldboy
# <function Student.tell_stu_info at 0x104a8caf0>
# <function Student.set_info at 0x104a8cb80>

# # 二、但其实类中的东西是给对象使用的
# # 1、类的数据属性是共享给所有对象使用的，大家访问的地址都一样

print(id(Student.stu_school))
print(id(stu1_obj.stu_school))
print(id(stu2_obj.stu_school))
print(id(stu3_obj.stu_school))

# 输出：
# 4369059952
# 4369059952
# 4369059952
# 4369059952

# 修改类中的值，所有对象的值都会发生改变
Student.stu_school='OLDBOY'  
print(Student.stu_school)
print(stu1_obj.stu_school)
print(stu2_obj.stu_school)
print(stu3_obj.stu_school)

# 输出
# OLDBOY
# OLDBOY
# OLDBOY
# OLDBOY

# 修改某一个对象的值，只有指定的对象值发生改变，其余对象以及类不发生改变。
stu1_obj.stu_school='OLDBOY' 
print(Student.stu_school)
print(stu1_obj.stu_school)
print(stu2_obj.stu_school)
print(stu3_obj.stu_school)
# 输出
# OLDBOY
# OLDBOY
# OLDBOY
# OLDBOY

# 2、类的函数属性是绑定给对象使用的,而且是绑定给对象的，虽然所有对象指向的都是相同的功能，但是绑定到不同的对象就是不同的绑定方法，内存地址各不相同
# 其实类调用自己的函数也是可以使用的，严格按照函数的规则进行使用。函数有几个参数，调用就需要几个参数
print(Student.tell_stu_info)
print(Student.set_info)

#输出
# <function Student.tell_stu_info at 0x100a70c10>
# <function Student.set_info at 0x100a70ca0>

Student.tell_stu_info(stu1_obj)
Student.tell_stu_info(stu2_obj)
Student.tell_stu_info(stu3_obj)

# 输出
# 名字：egon 年龄： 20 性别： male
# 名字：lili 年龄： 30 性别： female
# 名字：tom 年龄： 40 性别： male

Student.set_info(stu1_obj, 'EGON', 21, 'female')
Student.tell_stu_info(stu1_obj) # 名字：EGON 年龄： 21 性别： female

# 绑定方法的特殊之处：谁来调用绑定方法就会将谁当做第一个参数自动传入
print(Student.tell_stu_info)
print(stu1_obj.tell_stu_info)
print(stu2_obj.tell_stu_info)
print(stu3_obj.tell_stu_info)

#输出：
# <function Student.tell_stu_info at 0x104cd09d0>
# <bound method Student.tell_stu_info of <__main__.Student object at 0x104cdcf40>>
# <bound method Student.tell_stu_info of <__main__.Student object at 0x104cdce80>>
# <bound method Student.tell_stu_info of <__main__.Student object at 0x104cdcd60>>


stu1_obj.tell_stu_info() # 等同于tell_stu_info(stu1_obj)
stu2_obj.tell_stu_info() # 等同于tell_stu_info(stu2_obj)
stu3_obj.tell_stu_info() # 等同于tell_stu_info(stu3_obj)

Student.tell_stu_info(stu1_obj) # 名字：egon 年龄： 20 性别： male
# 输出：
名字：egon 年龄： 20 性别： male
名字：lili 年龄： 30 性别： female
名字：tom 年龄： 40 性别： male

# 注意：绑定到对象方法的这种自动传值的特征，决定了在类中定义的函数都要默认写一个参数self，self可以是任意名字，但命名为self是约定俗成的。
stu1_obj.choose('python全栈开发')
print(stu1_obj.course)

stu2_obj.choose('linux运维')
print(stu2_obj.course)

stu3_obj.choose('高级架构师')
print(stu3_obj.course)

# 输出：
正在选课
python全栈开发
正在选课
linux运维
正在选课
高级架构师




```

参考链接：[https://zhuanlan.zhihu.com/p/109292504](https://zhuanlan.zhihu.com/p/109292504)





<h3 id="Yjo0x">作业</h3>

```python

# 整合--》解耦合-->方便扩展

class School:
    school_name="OLDBOY"
    
    def __init__(self,nickname,addr):
        self.nickname=nickname
        self.addr=addr
        self.classes=[]

    # 关联班级
    def related_class(self,class_name):
        # self.classes.append(班级名字)
        self.classes.append(class_name)

    def tell_class(self):
        for class_name in self.classes:
            print('%s %s' %(self.nickname,class_name))

# 1. 创建校区
school_obj1=School('老男孩魔都校区', '上海')
school_obj2=School('老男孩帝都校区', '北京')

# 2. 为学校开设班级

#上海校区开设python 脱产14 15 期
school_obj1.related_class('脱产14期')
school_obj1.related_class('脱产15期')
# print(school_obj1.classes)
# 北京校区开设脱产29期
school_obj2.related_class('脱产29期')
# print(school_obj2.classes)


# for class_name in school_obj1.classes:
#     print('%s %s' %(school_obj1.nickname,class_name))

# for class_name in school_obj2.classes:
#     print('%s %s' %(school_obj2.nickname,class_name))

# 3. 查看每个校区开设的班级

school_obj1.tell_class()
school_obj2.tell_class()



# print(school_obj1.school_name)
# print(school_obj1.nickname)
# print(school_obj1.addr)

```

