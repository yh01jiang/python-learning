![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1701843928802-faee4c92-3aec-42d8-8331-5f5736d48bde.png)

<h2 id="L0VyC"><font style="color:rgb(18, 18, 18);">一 继承介绍</font></h2>
<font style="color:rgb(18, 18, 18);">继承是一种创建新类的方式，在Python中，新建的类可以继承一个或多个父类，新建的类可称为子类或派生类，父类又可称为基类或超类</font>

```python
class Parent1():
    x = 111

class Parent2():
    pass

class Sub1(Parent1):  # 单继承
    pass

class Sub2(Parent1,Parent2):  # 多继承
    pass


# 通过类的内置属性__bases__可以查看类继承的所有父类
print(Sub1.__bases__)
print(Sub2.__bases__)
print(Sub1.x)

# 输出：
# (<class '__main__.Parent1'>,)
# (<class '__main__.Parent1'>, <class '__main__.Parent2'>)
# 111


# ps1: 在python2中有新式类与经典类之分
# 新式类： 继承了object类中子类，以及该类的子类子子类
# 经典类：没有继承object类中子类，以及该类的子类子子类
```

<font style="color:rgb(18, 18, 18);">在Python2中有经典类与新式类之分，没有显式地继承object类的类，以及该类的子类，都是经典类，显式地继承object的类，以及该类的子类，都是新式类。</font><font style="color:#DF2A3F;">而在Python3中，即使没有显式地继承object，也会默认继承该类</font><font style="color:rgb(18, 18, 18);">，如下</font>

```python
🍔在"Python2"中
class Default(object):  # 新式类
    pass

class Animal:  # 经典类
    pass

🍔"Python2"中"print"语法
print Default.__bases__  # (<class 'object'>,)
print Animal.__bases__   # ()



🍔在"Python3"中
class Default:  # 默认继承"object"
    pass

print(Default.__bases__)  # (<class 'object'>,)

```



<h2 id="PLtmv"><font style="color:rgb(18, 18, 18);">二 继承与抽象</font></h2>
<font style="color:rgb(18, 18, 18);">要找出类与类之间的继承关系，需要先抽象，再继承。抽象即总结相似之处，总结对象之间的相似之处得到类，总结类与类之间的相似之处就可以得到父类，如下图所示</font>

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1701143379914-cf5d5110-8c73-4939-bea4-27fa753906b1.png)

<font style="color:rgb(18, 18, 18);">基于抽象的结果，我们就找到了继承关系</font>

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1701143392949-b7f4df06-d59a-44a3-90ae-e905d41ae5d2.png)



```python
# 2.为何要有继承： 用来解决类与类之间的冗余问题

# 3. 如何实现继承

# 示范1
class Student():
    school = "OLDBOY"

    def __init__(self,name,age,sex):
        self.name=name
        self.age=age
        self.sex=sex

    def choose_course(self):
        print('学生 %s 正在选课' %self.name)
    
class Teacher():
    school = "OLDBOY"

    def __init__(self,name,age,sex,salary,level):
        self.name=name
        self.age=age
        self.sex=sex
        self.salary=salary
        self.level=level

    def course(self):
        print('老师 %s 老师正在给学生打分' %self.name)

# 示范2: 基于继承类与类之间存在冗余问题

class OldboyPeople():
    school = "OLDBOY"
 
    def __init__(self,name,age,sex):
        self.name=name
        self.age=age
        self.sex=sex

    def score(self):
        print('我只是为了测试父类的函数，通过类.函数的方法去调用')


class Student(OldboyPeople):
    # 可以删掉了
    # school = "OLDBOY"

    # def __init__(self,name,age,sex):
    #     self.name=name
    #     self.age=age
    #     self.sex=sex

    def choose_course(self):
        print('学生 %s 正在选课' %self.name)
    
class Teacher(OldboyPeople):
    # school = "OLDBOY"

    def __init__(self,name,age,sex,salary,level):
        # 这三行就是父类的init方法，删除掉，在这里调用父类的init方法
        # self.name=name
        # self.age=age
        # self.sex=sex
        # 指名道姓去跟OldboyPeople 要__init__方法，类.__init__ 就没有自动传值的说法，有几个参数传几个参数
        OldboyPeople.__init__(self,name,age,sex)
        self.salary=salary
        self.level=level

    def course(self):
        OldboyPeople.score(self)  # 同理使用类.函数()  去调用父类的方法
        print('老师 %s 老师正在给学生打分' %self.name)


#实例化
stu_obj=Student('lili',18,'male')
print(stu_obj.__dict__)  # {'name': 'lili', 'age': 18, 'sex': 'male'}
print(stu_obj.school)  # OLDBOY
stu_obj.choose_course()  # 学生 lili 正在选课


teac_obj=Teacher('egon',18, 'female',3000,10)
print(teac_obj.__dict__)
print(teac_obj.school)
teac_obj.course()

# 输出：
# {'name': 'egon', 'age': 18, 'sex': 'female', 'salary': 3000, 'level': 10}
# OLDBOY
# 我只是为了测试父类的函数，通过类.函数的方法去调用
# 老师 egon 老师正在给学生打分

# 派生的三种：
# 把父类的东西拿过来，重名
# 造一个父类没有的
# 把父类的东西拿过来，自己改一改
# 存在重名的就以自己为准
```

<h2 id="QJYIN"><font style="color:rgb(18, 18, 18);">三 属性查找</font></h2>
<font style="color:rgb(18, 18, 18);">有了继承关系，对象在查找属性时，先从对象自己的__dict__中找，如果没有则去子类中找，然后再去父类中找……</font>

```python

class Foo():
    def f1(self):
        print('我是在Foo.f1')
    
    def f2(self):
        print('我是在Foo.f2')

class Bar(Foo):
    def f1(self):
        print('我是在Bar.f1')

obj=Bar()

obj.f2()  # 我是在Foo.f2
obj.f1()  # 我是在Bar.f1

'''
解释:
obj.f2()会在父类Foo中找到f2，先打印Foo.f2,然后执行到self.f1(),即obj.f1()，
#仍会按照：对象本身->类Bar->父类Foo的顺序依次找下去，在类Bar中找到f1，因而打印结果为Bar.f1

'''

# 父类如果不想让子类覆盖自己的方法，可以采用双下划线开头的方式将方法设置为私有的

class Foo():
    def __f1(self):  # 变形为_Foo__f1
        print('我是在Foo.f1')
    
    def f2(self):
        print('我是在Foo.f2')
        #  通过开放该接口就可以访问到名字属性（隐藏）
        self.__f1()  # 变形为self._Foo__f1,因而只会调用自己所在的类中的方法
class Bar(Foo):
    def __f1(self):  # # 变形为_Bar__f1
        print('我是在Bar.f1')


obj2=Bar()
obj2.f2()  #在父类中找到f2方法，进而调用._Foo__f1()方法，同样是在父类中找到该方法


print(Bar._Bar__f1)

# 输出
# 我是在Foo.f2
# 我是在Foo.f1
# <function Bar.__f1 at 0x102fcca60>

```

<h2 id="XyrKV"><font style="color:rgb(18, 18, 18);">四 继承的实现原理</font></h2>
<h4 id="HOReO"><font style="color:rgb(79, 79, 79);">1.新式类</font></h4>
+ <font style="color:rgba(0, 0, 0, 0.75);">继承了</font><font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">object</font><font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgba(0, 0, 0, 0.75);">的类以及该类的子类, 都是新式类 (Python3中统一都是新式类)</font>
+ <font style="color:rgba(0, 0, 0, 0.75);">在 </font>**<font style="color:rgba(0, 0, 0, 0.75);">Python3</font>**<font style="color:rgba(0, 0, 0, 0.75);"> 中如果一个类没有继承任何类, 则</font>**<font style="color:rgba(0, 0, 0, 0.75);">默认会继承</font>**<font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">object</font><font style="color:rgba(0, 0, 0, 0.75);"> 类, 也就是</font>**<font style="color:rgba(0, 0, 0, 0.75);">Python3中所有的类</font>**<font style="color:rgba(0, 0, 0, 0.75);">都是</font>**<font style="color:rgba(0, 0, 0, 0.75);">新式类</font>**

<h4 id="mCPPY"><font style="color:rgb(79, 79, 79);">2.经典类</font></h4>
+ <font style="color:rgba(0, 0, 0, 0.75);">没有继承</font><font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">object</font><font style="color:rgba(0, 0, 0, 0.75);"> </font><font style="color:rgba(0, 0, 0, 0.75);">的类以及该类的子类, 都是经典类 (只有Python2中才区分新式类和经典类)</font>
+ <font style="color:rgba(0, 0, 0, 0.75);">在 </font>**<font style="color:rgba(0, 0, 0, 0.75);">Python2</font>**<font style="color:rgba(0, 0, 0, 0.75);"> 中如果一个类没有继承任何类, 它</font>**<font style="color:rgba(0, 0, 0, 0.75);">不会继承</font>**<font style="color:rgb(199, 37, 78);background-color:rgb(249, 242, 244);">object</font><font style="color:rgba(0, 0, 0, 0.75);"> 类, 所以</font>**<font style="color:rgba(0, 0, 0, 0.75);">Python2 中才有经典类</font>**



<font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">上面说到Python支持多继承, 但新式类与经典类的属性查找顺序是不一样的</font>

<font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">java语言中，它不支持多继承，只支持继承一个父类</font>

<font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">python语言，支持多继承，比如 A(B,C,D)</font>

<h3 id="qTVDc"><font style="color:rgb(18, 18, 18);">4.1 菱形问题</font></h3>
<font style="color:rgb(18, 18, 18);">大多数面向对象语言都不支持多继承，而在Python中，一个子类是可以同时继承多个父类的，这固然可以带来一个子类可以对多个不同父类加以重用的好处，但也有可能引发著名的</font><font style="color:rgb(18, 18, 18);"> </font>[Diamond problem](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Diamond_problem)<font style="color:rgb(18, 18, 18);">菱形问题(或称钻石问题，有时候也被称为“死亡钻石”)，菱形其实就是对下面这种继承结构的形象比喻</font>

<font style="color:rgb(18, 18, 18);">  
</font>![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1701178411478-260c69db-45f9-4b87-ba85-a11b81c1ac76.png)

```python
A类在顶部，B类和C类分别位于其下方，D类在底部将两者连接在一起形成菱形。
```

<font style="color:rgb(18, 18, 18);">这种继承结构下导致的问题称之为菱形问题：如果A中有一个方法，B和/或C都重写了该方法，而D没有重写它，那么D继承的是哪个版本的方法：B的还是C的？如下所示</font>

```python
class A(object):
    def test(self):
        print('from A')


class B(A):
    def test(self):
        print('from B')


class C(A):
    def test(self):
        print('from C')


class D(B,C):
    pass


obj = D()
obj.test() # 结果为：from B
```

<font style="color:rgb(18, 18, 18);">要想搞明白obj.test()是如何找到方法test的，需要了解python的继承实现原理</font>

<h3 id="IFq4R"><font style="color:rgb(18, 18, 18);">4.2 继承原理</font></h3>
<font style="color:rgb(18, 18, 18);">python到底是如何实现继承的呢？ 对于你定义的每一个类，Python都会计算出一个方法解析顺序(MRO)列表，该MRO列表就是一个简单的所有基类的线性顺序列表，如下</font>

```python
>>> D.mro() # 新式类内置了mro方法可以查看线性列表的内容，经典类没有该内置该方法
[<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]

```

python会在MRO列表上从左到右开始查找基类,直到找到第一个匹配这个属性的类为止。 而这个MRO列表的构造是通过一个C3线性化算法来实现的。我们不去深究这个算法的数学原理,它实际上就是合并所有父类的MRO列表并遵循如下三条准则:

```plain
1.子类会先于父类被检查
2.多个父类会根据它们在列表中的顺序被检查
3.如果对下一个类存在两个合法的选择,选择第一个父类

# 说白了就是从左到右的顺序去查找
```

<font style="color:rgb(18, 18, 18);">所以obj.test()的查找顺序是，先从对象obj本身的属性里找方法test，没有找到，则参照属性查找的发起者(即obj)所处类D的MRO列表来依次检索，首先在类D中未找到，然后再B中找到方法test</font>

<font style="color:rgb(18, 18, 18);">ps：</font>

```plain
1.由对象发起的属性查找，会从对象自身的属性里检索，没有则会按照对象的类.mro()规定的顺序依次找下去，
2.由类发起的属性查找，会按照当前类.mro()规定的顺序依次找下去，
```

<h3 id="Omz54"><font style="color:rgb(18, 18, 18);">4.3 深度优先和广度优先</font></h3>
<font style="color:rgb(18, 18, 18);">参照下述代码，</font><font style="color:#DF2A3F;">多继承结构为非菱形结构</font><font style="color:rgb(18, 18, 18);">，此时，会按照先找B这一条分支，然后再找C这一条分支，最后找D这一条分支的顺序直到找到我们想要的属性  
</font>

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1701180770884-a05931db-a36e-4a0f-be9c-5e03fb618994.png)

+ <font style="color:rgb(77, 77, 77);">非菱形结构下, 经典类与新式类的属性</font>**<font style="color:rgb(77, 77, 77);">查找顺序是一样的</font>**

```python
class E:
    def test(self):
        print('from E')


class F:
    def test(self):
        print('from F')


class B(E):
    def test(self):
        print('from B')


class C(F):
    def test(self):
        print('from C')


class D:
    def test(self):
        print('from D')


class A(B, C, D):
    # def test(self):
    #     print('from A')
    pass


print(A.mro())
'''
[<class '__main__.A'>, <class '__main__.B'>, <class '__main__.E'>, <class '__main__.C'>, <class '__main__.F'>, <class '__main__.D'>, <class 'object'>]
'''

obj = A()
obj.test() # 结果为：from B
# 可依次注释上述类中的方法test来进行验证
```

<font style="color:rgb(18, 18, 18);">如果</font><font style="color:#DF2A3F;">继承关系为菱形结构</font><font style="color:rgb(18, 18, 18);">，那么经典类与新式类会有不同MRO，分别对应属性的两种查找方式：</font><font style="color:rgb(18, 18, 18);background-color:#FBDE28;">深度优先和广度优先</font>

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1701180818291-2f6708d4-ceb9-406c-a4d3-10d950bcbc70.png)

+ <font style="color:#DF2A3F;">经典类：从左到右选路, 一条路走到黑</font>

```python
class G: # 在python2中，未继承object的类及其子类，都是经典类
    def test(self):
        print('from G')

class E(G):
    def test(self):
        print('from E')

class F(G):
    def test(self):
        print('from F')

class B(E):
    def test(self):
        print('from B')

class C(F):
    def test(self):
        print('from C')

class D(G):
    def test(self):
        print('from D')

class A(B,C,D):
    # def test(self):
    #     print('from A')
    pass

obj = A()
obj.test() # 如上图，查找顺序为:obj->A->B->E->G->C->F->D->object
# 可依次注释上述类中的方法test来进行验证,注意请在python2.x中进行测试
```

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1701180887597-a3bcce65-e46c-4944-a33e-426418c65b4d.png)

<font style="color:#DF2A3F;">新式类：</font>

+ <font style="color:#DF2A3F;">不找多个类最后继承的同一个类，直接去找下一个父类</font>
+ <font style="color:#DF2A3F;background-color:rgb(249, 242, 244);">__mro__</font><font style="color:#DF2A3F;"> : 只有新式类才有的属性, 可查看属性查找的顺序</font>

```python
class G(object):
    def test(self):
        print('from G')

class E(G):
    def test(self):
        print('from E')

class F(G):
    def test(self):
        print('from F')

class B(E):
    def test(self):
        print('from B')

class C(F):
    def test(self):
        print('from C')

class D(G):
    def test(self):
        print('from D')

class A(B,C,D):
    # def test(self):
    #     print('from A')
    pass

obj = A()
obj.test() # 如上图，查找顺序为:obj->A->B->E->C->F->D->G->object
# 可依次注释上述类中的方法test来进行验证\
print(A.__mro__)
# (<class '__main__.A'>, <class '__main__.B'>, <class '__main__.E'>, <class '__main__.C'>, <class '__main__.F'>, <class '__main__.D'>, <class '__main__.G'>, <class 'object'>)

```

<font style="color:#DF2A3F;">总结：经典类：一条路干到黑</font>

<font style="color:#DF2A3F;">新式类： 广度的查找</font>



<h3 id="QCT0o"><font style="color:rgb(18, 18, 18);">4.4 Pyton Mixins机制</font></h3>
<font style="color:rgb(18, 18, 18);">一个子类可以同时继承多个父类，这样的设计常被人诟病，一来它有可能导致可恶的菱形问题，二来在人的世界观里继承应该是个”is-a”关系。 比如轿车类之所以可以继承交通工具类，是因为基于人的世界观，我们可以说：轿车是一个(“is-a”)交通工具，而在人的世界观里，一个物品不可能是多种不同的东西，因此多重继承在人的世界观里是说不通的，它仅仅只是代码层面的逻辑。不过有没有这种情况，一个类的确是需要继承多个类呢？</font>

<font style="color:rgb(18, 18, 18);">答案是有，我们还是拿交通工具来举例子:</font>

<font style="color:rgb(18, 18, 18);">民航飞机、直升飞机、轿车都是一个（is-a）交通工具，前两者都有一个功能是飞行fly，但是轿车没有，所以如下所示我们把飞行功能放到交通工具这个父类中是不合理的</font>

<font style="color:rgb(18, 18, 18);"></font>

```python
class Vehicle:  # 交通工具
    pass

class CivilAircraft(Vehicle):  # 民航飞机
    pass


class Helicopter(Vehicle):  # 直升飞机
    pass


class Car(Vehicle):  # 汽车并不会飞，但按照上述继承关系，汽车也能飞了
    pass
```

<font style="color:rgb(18, 18, 18);"> 但是如果民航飞机和直升机都各自写自己的飞行fly方法，又违背了代码尽可能重用的原则（如果以后飞行工具越来越多，那会重复代码将会越来越多）。</font>

<font style="color:rgb(18, 18, 18);">Python语言可没有接口功能，但Python提供了Mixins机制，简单来说Mixins机制指的是子类混合(mixin)不同类的功能，而这些类采用统一的命名规范（例如Mixin后缀），以此标识这些类只是用来混合功能的，并不是用来标识子类的从属"is-a"关系的，所以Mixins机制本质仍是多继承，但同样遵守”is-a”关系，如下</font>

```python
class Vehicle:  # 交通工具
    pass


class FlyableMixin:  # 在Flyable后面加入Mixin，就是明确告诉这个类是Mixin类，是作为功能添加到子类中，而不是作为父类。说白了就是一个功能类。
    def fly(self):
        '''
        飞行功能相应的代码        
        '''
        print("I am flying")


class CivilAircraft(FlyableMixin, Vehicle):  # 民航飞机
    pass


class Helicopter(FlyableMixin, Vehicle):  # 直升飞机
    pass


class Car(Vehicle):  # 汽车
    pass

# ps: 采用某种规范（如命名规范）来解决具体的问题是python惯用的套路
```

<font style="color:rgb(18, 18, 18);">可以看到，上面的CivilAircraft、Helicopter类实现了多继承，不过它继承的第一个类我们起名为FlyableMixin，而不是Flyable，这个并不影响功能，但是会告诉后来读代码的人，这个类是一个Mixin类，表示混入(mix-in)，这种命名方式就是用来明确地告诉别人（python语言惯用的手法），这个类是作为功能添加到子类中，而不是作为父类，</font>

<font style="color:#DF2A3F;">使用Mixin类实现多重继承要非常小心</font>

+ <font style="color:rgb(18, 18, 18);">首先它必须表示某一种功能，而不是某个物品，python 对于mixin类的命名方式一般以 Mixin, able, ible 为后缀</font>
+ <font style="color:rgb(18, 18, 18);">其次它必须责任单一，如果有多个功能，那就写多个Mixin类，一个类可以继承多个Mixin，为了保证遵循继承的“is-a”原则，只能继承一个标识其归属含义的父类</font>
+ <font style="color:rgb(18, 18, 18);">然后，它不依赖于子类的实现</font>
+ <font style="color:rgb(18, 18, 18);">最后，子类即便没有继承这个Mixin类，也照样可以工作，就是缺少了某个功能。（比如飞机照样可以载客，就是不能飞了）</font>

<font style="color:rgb(18, 18, 18);">  
</font>

<h2 id="A7Svd"><font style="color:rgb(18, 18, 18);">五 派生与方法重用</font></h2>
<font style="color:rgb(18, 18, 18);">子类可以派生出自己新的属性，在进行属性查找时，子类中的属性名会优先于父类被查找，例如每个老师还有职称这一属性，我们就需要在Teacher类中定义该类自己的__init__覆盖父类的</font>

```python



#1. 在子类派生的方法中如何重用父类的功能
# 方式1: 指名道姓的调用某一个类下的函数==》不依赖于继承关系
class OldboyPeople():
    school = "OLDBOY"
 
    def __init__(self,name,age,sex):
        self.name=name
        self.age=age
        self.sex=sex

    def f1(self):
        print('%s say hello'  %(self.name))



    
class Teacher(OldboyPeople):

    def __init__(self,name,age,sex,salary,level):
        OldboyPeople.__init__(self,name,age,sex)
        self.salary=salary
        self.level=level


obj=Teacher('egon',18,'male',3000,10)
print(obj.__dict__)

# 输出：
# {'name': 'egon', 'age': 18, 'sex': 'male', 'salary': 3000, 'level': 10}

# 方式2: super()调用父类提供给自己的方法===》严格依赖继承关系
#         调用super()会得到一个特殊的对象，该对象专门用来引用父类的属性，且严格按照发起属性查找类的那个MRO,去当前类的父类去找
class OldboyPeople():
    school = "OLDBOY"
 
    def __init__(self,name,age,sex):
        self.name=name
        self.age=age
        self.sex=sex

    def f1(self):
        print('%s say hello'  %(self.name))



    
class Teacher(OldboyPeople):

    def __init__(self,name,age,sex,salary,level):
        # 这是在python2 中的写法
        # super(Teacher,self).__init__(name,age,sex)  # 调用的是方法，自动传入对象
        # python3 中的方法
        super().__init__(name,age,sex)
        self.salary=salary
        self.level=level

print(Teacher.mro())

tea_obj=Teacher('egon',18,'male',3000,10)
print(tea_obj.__dict__)

# 输出
# [<class '__main__.Teacher'>, <class '__main__.OldboyPeople'>, <class 'object'>]
# {'name': 'egon', 'age': 18, 'sex': 'male', 'salary': 3000, 'level': 10}
```

<font style="color:rgb(18, 18, 18);">这两种方式的区别是：方式一是跟继承没有关系的，而方式二的super()是依赖于继承的，并且即使没有直接继承关系，super()仍然会按照MRO继续往后查找</font>

```python
#A没有继承B
class A:
    def test(self):
        super().test()

class B:
    def test(self):
        print('from B')

class C(A,B):
    pass

C.mro() # 在代码层面A并不是B的子类，但从MRO列表来看，属性查找时，就是按照顺序C->A->B->object，B就相当于A的“父类”
# [<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>,<class ‘object'>]
obj=C()
obj.test() # 属性查找的发起者是类C的对象obj，所以中途发生的属性查找都是参照C.mro()
# 输出
# from B
```

<font style="color:rgb(18, 18, 18);">obj.test()首先找到A下的test方法，执行super().test()会基于MRO列表(以C.mro()为准)当前所处的位置继续往后查找()，然后在B中找到了test方法并执行。</font>

<font style="color:rgb(18, 18, 18);">关于在子类中重用父类功能的这两种方式，使用任何一种都可以，但是在最新的代码中还是推荐使用super()</font>

<font style="color:rgb(18, 18, 18);"></font>

<font style="color:rgb(18, 18, 18);"></font>

<h2 id="TDwaU"><font style="color:rgb(18, 18, 18);">六 组合</font></h2>
<font style="color:rgb(18, 18, 18);">在一个类中以另外一个类的对象作为数据属性，称为类的组合。组合与继承都是用来解决代码的重用性问题。不同的是：继承是一种“是”的关系，比如老师是人、学生是人，当类之间有很多相同的之处，应该使用继承；而组合则是一种“有”的关系，比如老师有生日，老师有多门课程，当类之间有显著不同，并且较小的类是较大的类所需要的组件时，应该使用组合，如下示例</font>

```python
class Course:
    def __init__(self,name,period,price):
        self.name=name
        self.period=period
        self.price=price
    def tell_info(self):
        print('<%s %s %s>' %(self.name,self.period,self.price))

class Date:
    def __init__(self,year,mon,day):
        self.year=year
        self.mon=mon
        self.day=day
    def tell_birth(self):
       print('<%s-%s-%s>' %(self.year,self.mon,self.day))

class People:
    school='清华大学'
    def __init__(self,name,sex,age):
        self.name=name
        self.sex=sex
        self.age=age

#Teacher类基于继承来重用People的代码，基于组合来重用Date类和Course类的代码
class Teacher(People): #老师是人
    def __init__(self,name,sex,age,title,year,mon,day):
        super().__init__(name,age,sex)
        self.birth=Date(year,mon,day) #老师有生日
        self.courses=[] #老师有课程，可以在实例化后，往该列表中添加Course类的对象
    def teach(self):
        print('%s is teaching' %self.name)


python=Course('python','3mons',3000.0)
linux=Course('linux','5mons',5000.0)
teacher1=Teacher('lili','female',28,'博士生导师',1990,3,23)

# teacher1有两门课程
teacher1.courses.append(python)
teacher1.courses.append(linux)

# 重用Date类的功能
teacher1.birth.tell_birth()

# 重用Course类的功能
for obj in teacher1.courses: 
    obj.tell_info()
```

<font style="color:rgb(18, 18, 18);">此时对象teacher1集对象独有的属性、Teacher类中的内容、Course类中的内容于一身（都可以访问到），是一个高度整合的产物</font>



[https://zhuanlan.zhihu.com/p/109331525](https://zhuanlan.zhihu.com/p/109331525)

