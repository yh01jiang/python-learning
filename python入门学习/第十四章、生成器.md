<img width="720" height="388" alt="image" src="https://github.com/user-attachments/assets/0615cfbf-ceaa-42ae-985d-7a0d5359f44f" />

<h2 id="w9ABO"><font style="color:rgb(18, 18, 18);">一 、生成器与yield</font></h2>
<h2 id="I9Rn5">1. 如何得到自定义的迭代器：</h2>
在函数内一旦存在yield关键字，调用函数并不会执行函数体代码，会返回一个生成器对象，生成器即自定义的迭代器。





```python

def func():
    print('第一次运行')
    yield 1
    print('第二次运行')
    yield 2
    print('第三次运行')
    yield 3
    print('第四次运行')

# 注意：如果函数内没有yield，则会直接运行函数体代码。
g=func()
print(g)  # 输出结果：generator object func at 0x01B654E0>
# 生成器就是迭代器
g.__iter__()
g.__next__()

# 会触发函数体代码的运行，然后遇到yield停下来，将yield后面的值当做本次调用的结果。
#

# 照猫画虎理解
print('aaa'.__len__())
print(len('aaa'))  # 'aaa'.__len__()

next(g)  # g.__next__()
iter(可迭代对象)  # 可迭代对象.__iter__()


```

 #### 应用案例

```python

def my_range(start,stop,step=1):
    while start < stop:
        yield start
        start+=step

g=my_range(1,5,2)
print(next(g))
print(next(g))
# 输出结果：
1
3


# 直接可以随便取值
for i in my_range(1,9,2):
    print(i)

# 输出结果：
1
3
5
7

# 有了yield关键字，我们就有了一种自定义迭代器的实现方式。
# yield可以用于返回值，但不同于return，函数一旦遇到return就结束了，
# 而yield可以保存函数的运行状态挂起函数，用来返回多次值

```

<h2 id="t9stq"><font style="color:rgb(18, 18, 18);">二 yield表达式应用</font></h2>
<font style="color:rgb(18, 18, 18);">在函数内可以采用表达式形式的yield</font>

```python

# yield表达式（了解）
# x=yield 返回值
# 示例1
def dog(name):
    print('道哥%s准备吃东西拉...' %name)
    while True:
        x = yield None
        print('道哥%s吃了 %s' %(name,x))

g=dog('alex')
res=next(g)

next(g)
next(g)

# 输出结果：
道哥alex准备吃东西拉...
道哥alex吃了 None
道哥alex吃了 None

```

<font style="color:rgb(18, 18, 18);">可以拿到函数的生成器对象持续为函数体send值，如下</font>

```python

示例2
def dog(name):
    print('道哥%s准备吃东西拉...' %name)
    while True:
        # x拿到的是yield接收到的值
        x = yield None  # x = '一根骨头'
        print('道哥%s吃了 %s' %(name,x))

g=dog('alex')
g.send(None)  # 等同于next(g)，初始化。
g.send('一根骨头')  # '一根骨头' 把值给yield，然后yield赋值给x

g.send('肉包子')
g.send('一坨屎')
g.send(['111','aaa'])
g.close()
g.send('1111')  # 关闭之后无法取值。
# 输出结果；
道哥alex准备吃东西拉...
道哥alex吃了 一根骨头
道哥alex吃了 肉包子
道哥alex吃了 一坨屎


# 针对表达式形式的yield，生成器对象必须事先被初始化一次，让函数挂起在food=yield的位置，等待调用g.send()方法为函数体传值，g.send(None)等同于next(g)。

```

<font style="color:rgb(18, 18, 18);">针对表达式形式的yield，生成器对象必须事先被初始化一次，让函数挂起在food=yield的位置，等待调用g.send()方法为函数体传值，g.send(None)等同于next(g)。</font>

<font style="color:rgb(18, 18, 18);">我们可以编写装饰器来完成为所有表达式形式yield对应生成器的初始化操作，如下</font>

```python

def init(func):
    def wrapper(*args,**kwargs):
        g=func(*args,**kwargs)
        next(g)
        return g
    return wrapper

@init
def eater():
    print('Ready to eat')
    while True:
        food=yield
        print('get the food: %s, and start to eat' %food)

```

<font style="color:rgb(18, 18, 18);">表达式形式的yield也可以用于返回多次值，即</font><font style="color:rgb(18, 18, 18);background-color:rgb(246, 246, 246);">变量名=yield 值</font><font style="color:rgb(18, 18, 18);">的形式，如下</font>

```python

# 讨论yield的返回值
def dog(name):
    food_list=[]
    print('道哥%s准备吃东西拉...' %name)
    while True:
        # x拿到的是yield接收到的值
        x = yield food_list  # x = '一根骨头'
        print('道哥%s吃了 %s' %(name,x))
        food_list.append(x)

g=dog('alex')
res=g.send(None)  # 等同于next(g)，初始化。
print(res)
# 输出结果：
道哥alex准备吃东西拉...
[]
res=g.send('一根骨头')  # '一根骨头' 把值给yield，然后yield赋值给x
print(res)
# 输出结果：
道哥alex吃了 一根骨头
['一根骨头']

res=g.send('肉包子')
print(res)
# 输出结果：
道哥alex吃了 肉包子
['一根骨头', '肉包子']

def func():
    print('start.......')
    x=yield 1111  # x = 'bbbbb'
    print('哈哈哈哈')
    print('哈哈哈哈')
    print('哈哈哈哈')
    print('哈哈哈哈')
    yield 2222

g=func()
res=next(g)
print(res)
# 输出结果：
start.......
1111
res=g.send('bbbbbb')
print(res)
# 输出结果：
哈哈哈哈
哈哈哈哈
哈哈哈哈
哈哈哈哈
2222

```

<h2 id="HIwi4"><font style="color:rgb(18, 18, 18);">三 、三元表达式、列表生成式、生成器表达式</font></h2>
<h2 id="O18jP"><font style="color:rgb(18, 18, 18);">3.1 三元表达式</font></h2>
<font style="color:rgb(18, 18, 18);">三元表达式是python为我们提供的一种简化代码的解决方案，语法如下</font>

res = 条件成立时返回的值 if 条件 else 条件不成立时返回的值

```python

# 针对以下需求
def func(x,y):
    if x > y:
        return x
    else:
        return y

res=func(1,2)
print(res)

# 三元表达式
# 语法格式： 条件成立时返回的值 if 条件 else 条件不成立时要返回的值
x=1
y=2


# 一行代码解决问题
res=x if x > y else y
print(res)
# 输出结果： 2

res=11111 if 'egon' == 'egon' else 22222
print(res)
# 输出结果： 11111

```

<h2 id="pX1Dj"><font style="color:rgb(18, 18, 18);">3.2 列表生成式</font></h2>
<font style="color:rgb(18, 18, 18);">列表生成式是python为我们提供的一种简化代码的解决方案，用来快速生成列表，</font>

```python

l=['alex_dsb','jason_dsb','tom_dsb','barry_dsb','egon']
new_l=[]
for name in l:
    if name.endswith('dsb'):
        new_l.append(name)

print(new_l)  # 输出结果:['alex_dsb', 'jason_dsb', 'tom_dsb', 'barry_dsb']


l=['alex_dsb','jason_dsb','tom_dsb','barry_dsb','egon']
new_l=[]
#语法解释：返回值 for循环    if 判断为真，返回前面的name
new_l=[name for name in l if name.endswith('dsb')]
print(new_l)  # 输出结果:['alex_dsb', 'jason_dsb', 'tom_dsb', 'barry_dsb']


# 所有的小写字母变成大写
l=['alex_dsb','jason_dsb','tom_dsb','barry_dsb','egon']
new_l=[]
new_l=[name.upper() for name in l]
print(new_l)  # 输出结果：['ALEX_DSB', 'JASON_DSB', 'TOM_DSB', 'BARRY_DSB', 'EGON']


# 把所有名字去掉后缀_dsb
l=['alex_dsb','jason_dsb','tom_dsb','barry_dsb','egon']
new_l=[]
new_l=[name.replace('_dsb', '') for name in l]
print(new_l)  # 输出结果：['alex', 'jason', 'tom', 'barry', 'egon']

```

<h2 id="INS4P">3.2 字典生成式</h2>

```python

keys=['name','age','gender']
dic={key:None for key in keys}
print(dic)   # 输出结果：{'name': None, 'age': None, 'gender': None}

items=[('name','egon'),('age',18),('gender','male')]
res={k:v for k,v in items if k != 'gender'}
print(res)  # 输出结果：{'name': 'egon', 'age': 18}

```

<h2 id="nffzd">3.3 集合生成式</h2>

```python

keys=['name','age','gender']
dic={key for key in keys}
print(dic)   # 输出结果：{'gender', 'age', 'name'}

```

<h2 id="AyOuF">3.4 生成器表达式</h2>

```python

g=(i for i in range(10) if i > 3)
# 强调：此时g内部一个值也没有
print(g)  #输出结果：<generator object <genexpr> at 0x01E5F300>
print(next(g))
print(next(g))
print(next(g))
print(next(g))
print(next(g))
print(next(g))

# 方式1：
with open('a.txt',mode='rt',encoding='utf-8') as f:
    res=0
    for line in f:
        res+=len(line)
    print(res)

# 方式2：
with open('a.txt',mode='rt',encoding='utf-8') as f:

   # size_of_line=[len(line) for line in f]
   # print(size_of_line)
   # res=sum(size_of_line)
   # print(res)

   res=sum([len(line) for line in f])
   print(res)

# 方式3：效率最高
with open('a.txt',mode='rt',encoding='utf-8') as f:
    # res=sum((len(line) for line in f))
    # 可以简写成如下格式
    res=sum(len(line) for line in f)
    print(res)

```

参考链接：[https://zhuanlan.zhihu.com/p/109084444](https://zhuanlan.zhihu.com/p/109084444)

