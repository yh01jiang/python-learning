<h1 id="nV9Wm">![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1680595958266-827937f7-e725-4273-ac12-ed36e9ebf90b.png)</h1>
<h1 id="hRaYG"><font style="color:rgb(18, 18, 18);">一 、函数递归调用介绍</font></h1>
<font style="color:rgb(18, 18, 18);">函数不仅可以嵌套定义，还可以嵌套调用，</font><font style="color:#DF2A3F;">即在调用一个函数的过程中，函数内部又调用另一个函数，而函数的递归调用指的是在调用一个函数的过程中又直接或间接地调用该函数本身</font>

补充： 函数的嵌套定义用在了装饰器上

```python
# 1、直接调用本身
def f1():
    print('是我是我是我还是我')
    f1()

f1()

# 2、间接调用本身
def f1():
    print('===>f1')
    f2()

def f2():
    print('====>f2')
    f1()

f1()

# 3、一段代码循环运行的方案有两种
# 方式一：while、for循环
while True:
    print(111)
    print(222)
    print(333)


# 方式二、递归的本质就是循环
def func():
    print(111)
    print(222)
    print(333)
    func()

func()

```

<font style="color:#DF2A3F;">直接调用图：</font>

![](https://cdn.nlark.com/yuque/0/2023/webp/25700096/1680168458480-ffd1c46e-84ba-44eb-90a3-0c1b504ccd3c.webp)

<font style="color:#DF2A3F;">间接调用图：</font>

![](https://cdn.nlark.com/yuque/0/2023/webp/25700096/1680168484553-a244d722-1ed9-490d-bc84-6186b8d89edb.webp)

<font style="color:rgb(18, 18, 18);">从上图可以看出，</font><font style="color:#DF2A3F;">两种情况下的递归调用都是一个无限循环的过程</font><font style="color:rgb(18, 18, 18);">，但在python对函数的递归调用的深度做了限制，因而并不会像大家所想的那样进入无限循环，会抛出异常，要避免出现这种情况，就必须让递归调用在满足某个特定条件下终止。</font>

<font style="color:#DF2A3F;">提示：</font>

```python
#1. 可以使用sys.getrecursionlimit()去查看递归深度，默认值为1000，虽然可以使用
sys.setrecursionlimit()去设定该值，但仍受限于主机操作系统栈大小的限制

#2. python不是一门函数式编程语言，无法对递归进行尾递归优化。
```

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1680168810319-3a336f57-0ff0-493b-b036-1a7b682f8087.png)

<h2 id="CCj0a">需要强调的一点是</h2>
```python
# 递归调用不应该无限的调用下去，必须在满足某种条件下结束递归调用。
# 1、基于递归
def func(n):
    if n == 10:
        return
    print(n)
    n+=1
    func(n)

func(0)

# 输出结果：
0
1
2
3
4
5
6
7
8
9



# 2、基于循环
n=0
while n <10:
    print(n)
    n+=1
# 输出结果：
0
1
2
3
4
5
6
7
8
9

```

<h2 id="KQvBM"><font style="color:rgb(18, 18, 18);">二 、回溯与递推</font></h2>
```python
# 回溯： 一层一层调用下去
# 递推：满足某种结束条件，结束递归调用，然后一层一层返回
age(5)=age(4)+10
age(4)=age(3)+10
age(3)=age(2)+10
age(2)=age(1)+10
age(1)=18


def age(n):
    if n == 1:
        return 18
    return age(n-1) + 10

res=age(5)
print(res)  # 输出结果：58


```

<font style="color:rgb(18, 18, 18);">下面我们用一个浅显的例子，为了让读者阐释递归的原理和使用：</font>

<font style="color:rgb(18, 18, 18);">例4.5</font>

<font style="color:rgb(18, 18, 18);">某公司四个员工坐在一起，问第四个人薪水，他说比第三个人多1000，问第三个人薪水，第他说比第二个人多1000，问第二个人薪水，他说比第一个人多1000，最后第一人说自己每月5000，请问第四个人的薪水是多少？</font>

<font style="color:rgb(18, 18, 18);">思路解析：</font>

<font style="color:rgb(18, 18, 18);">要知道第四个人的月薪，就必须知道第三个人的，第三个人的又取决于第二个人的，第二个人的又取决于第一个人的，而且每一个员工都比前一个多一千，数学表达式即：</font>

```python
salary(4)=salary(3)+1000 
salary(3)=salary(2)+1000 
salary(2)=salary(1)+1000 
salary(1)=5000
总结为： 
salary(n)=salary(n-1)+1000 (n>1) 
salary(1)=5000 (n=1) 
```

<font style="color:rgb(18, 18, 18);">很明显这是一个递归的过程，可以将该过程分为两个阶段：回溯和递推。</font>

<font style="color:rgb(18, 18, 18);">在回溯阶段，要求第n个员工的薪水，需要回溯得到(n-1)个员工的薪水，以此类推，直到得到第一个员工的薪水，此时，salary(1)已知，因而不必再向前回溯了。然后进入递推阶段：从第一个员工的薪水可以推算出第二个员工的薪水(6000)，从第二个员工的薪水可以推算出第三个员工的薪水(7000)，以此类推，一直推算出第第四个员工的薪水(8000)为止，递归结束。需要注意的一点是，递归一定要有一个结束条件，这里n=1就是结束条件。</font>

![](https://cdn.nlark.com/yuque/0/2023/webp/25700096/1680168604746-dbcda809-db47-4ee8-837b-10a677064d79.webp)

<font style="color:rgb(18, 18, 18);">代码实现：</font>

```python
def salary(n):
    if n==1:
        return 5000
    return salary(n-1)+1000

s=salary(4)
print(s)
```

<font style="color:rgb(18, 18, 18);">执行结果：</font>

```python
8000
```

<font style="color:rgb(18, 18, 18);">程序分析：</font>

<font style="color:rgb(18, 18, 18);">在未满足n\=\=1的条件时，一直进行递归调用，即一直回溯，见图4.3的左半部分。而在满足n\=\=1的条件时，终止递归调用，即结束回溯，从而进入递推阶段，依次推导直到得到最终的结果。</font>

<font style="color:rgb(18, 18, 18);">递归本质就是在做重复的事情，所以理论上递归可以解决的问题循环也都可以解决，只不过在某些情况下，使用递归会更容易实现，比如有一个嵌套多层的列表，要求打印出所有的元素，代码实现如下</font>

```python
items=[[1,2],3,[4,[5,[6,7]]]]
def foo(items):
    for i in items:
        if isinstance(i,list): #满足未遍历完items以及if判断成立的条件时，一直进行递归调用
            foo(i) 
        else:
            print(i,end=' ')

foo(items) #打印结果1 2 3 4 5 6 7
```

<font style="color:rgb(18, 18, 18);">使用递归，我们只需要分析出要重复执行的代码逻辑，然后提取进入下一次递归调用的条件或者说递归结束的条件即可，代码实现起来简洁清晰</font>

<h1 id="CDBgV">三、递归的应用案例</h1>
```python
l=[1,2,[2,3,[4,[5,[6,[7,[88,[99,100,111,]]]]]]]]
def f1(list1):
    for x in list1:
        if type(x) is list:
            # 如果是列表，应该再循环、再判断，即重新运行本身的代码。
            f1(x)
        else:
            print(x)

f1(l)

# 输出结果：
1
2
2
3
4
5
6
7
88
99
100
111

```

参考链接：[https://zhuanlan.zhihu.com/p/109119148](https://zhuanlan.zhihu.com/p/109119148)

