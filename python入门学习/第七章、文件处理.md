![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1679298835221-c11e37f5-4156-4a26-a17c-98de0f40e1c8.png)



<h1 id="hZJ1z">一、引入</h1>
<font style="color:rgb(18, 18, 18);">应用程序运行过程中产生的数据最先都是存放于内存中的，若想永久保存下来，必须要保存于硬盘中。应用程序若想操作硬件必须通过操作系统，而文件就是操作系统提供给应用程序来操作硬盘的虚拟概念，用户或应用程序对文件的操作，就是向操作系统发起调用，然后由操作系统完成对硬盘的具体操作。</font>

<h2 id="tACno"><font style="color:rgb(18, 18, 18);">二 文件操作的基本流程</font></h2>
<h2 id="uHO14"><font style="color:rgb(18, 18, 18);">2.1 基本流程</font></h2>
<font style="color:rgb(18, 18, 18);">有了文件的概念，我们无需再去考虑操作硬盘的细节，只需要关注操作文件的流程：</font>

```python
# 1. 打开文件，由应用程序向操作系统发起系统调用open(...)，操作系统打开该文件，对应一块硬盘空间，并返回一个文件对象赋值给一个变量f
f=open('a.txt','r',encoding='utf-8') #默认打开模式就为r

# 2. 调用文件对象下的读/写方法，会被操作系统转换为读/写硬盘的操作
data=f.read()

# 3. 向操作系统发起关闭文件的请求，回收系统资源
f.close()
```

![](https://cdn.nlark.com/yuque/0/2023/webp/25700096/1679299042276-cc4e99eb-6680-45c1-98d3-644a2e70219e.webp)

<h2 id="B55b1"><font style="color:rgb(18, 18, 18);">2.2 资源回收与with上下文管理</font></h2>
<font style="color:rgb(18, 18, 18);">打开一个文件包含两部分资源：应用程序的变量f和操作系统打开的文件。在操作完毕一个文件时，必须把与该文件的这两部分资源全部回收，回收方法为：</font>

```python
1、f.close() #回收操作系统打开的文件资源
2、del f #回收应用程序级的变量
```

<font style="color:rgb(18, 18, 18);">其中</font><font style="color:#DF2A3F;">del f一定要发生在f.close()之后</font><font style="color:rgb(18, 18, 18);">，否则就会导致操作系统打开的文件无法关闭，白白占用资源， 而python自动的垃圾回收机制决定了我们无需考虑del f，这就要求我们，在操作完毕文件后，一定要记住f.close()，虽然我们如此强调，但是大多数读者还是会不由自主地忘记f.close()，考虑到这一点，python提供了with关键字来帮我们管理上下文</font>

```python
# 1、在执行完子代码块后，with 会自动执行f.close()
with open('a.txt','w') as f:
    pass  # 在python3中可以使用...替代pass

# 2、可用用with同时打开多个文件，用逗号分隔开即可
with open('a.txt','r') as read_f,open('b.txt','w') as write_f:  
    data = read_f.read()
    write_f.write(data)

with open('a.txt',mode='rt',encoding='utf-8') as f1,\
        open('b.txt',mode='rt',encoding='utf-8') as f2:
    res1=f1.read()
    res2=f2.read()
    print(res1)
    print(res2)
    print(type(res1))
```

<h2 id="d0RzQ"><font style="color:rgb(18, 18, 18);">2.3 指定操作文本文件的字符编码</font></h2>
```python
f = open(...)是由操作系统打开文件，如果打开的是文本文件，会涉及到字符编码问题，如果没有为open指定编码，那么打开文本文件的默认编码很明显是操作系统说了算了，操作系统会用自己的默认编码去打开文件，在windows下是gbk，在linux下是utf-8。
这就用到了上节课讲的字符编码的知识：若要保证不乱码，文件以什么方式存的，就要以什么方式打开。
f = open('a.txt','r',encoding='utf-8')


# 没有指定encoding参数操作就会使用自己默认的编码
# linux默认是utf-8
# mac默认是utf-8
with open('c.txt', mode='rt',encoding='utf-8') as f:
    res=f.read()  # t模式会将f.read()读出的结果解码成unicode
    print(res,type(res))



# 内存： utf-8格式的二进制 ======解码=====》unicode
# 硬盘：（c.txt内容： utf-8格式的二进制）

# 1.打开文件
# windows中路径分隔符
open('C:\a\b\c\d.txt')  # \有转义的意思，所以不可取。
# 解决方法1
open(r'C:\a\b\c\d.txt')
#解决方案2
open('C:/a/b/c/d.txt')
#linux中路径分隔符
open('/a/b/c/d.txt')
f=open(r'aaa/a.txt',mode='rt',encoding='utf-8')  # f的值是一种变量，占用的是应用程序的内存空间
print(f)

# 2、操作文件：读写文件,应用程序对文件的读写请求都是在操作系统发送
# 系统调用，然后由操作系统控制硬盘吧输入读入内存、或者写入硬盘。
res=f.read()
print(res)
f.close()  # 回收操作系统的资源
# print(f)
# f.read()  # 变量f存在，但是不能读了
# del f  # 回收应用程序资源,通常不需要做。
```

<h2 id="HhQMM"><font style="color:rgb(18, 18, 18);">三 文件的操作模式</font></h2>
<h2 id="XuOiK"><font style="color:rgb(18, 18, 18);">3.1 控制文件读写操作的模式</font></h2>
```python
r(默认的)：只读
w：只写
a：只追加写
```

<h3 id="dLLDs"><font style="color:rgb(18, 18, 18);">3.1.1 案例一：r 模式的使用</font></h3>
```python
# r只读模式: 在文件不存在时则报错,文件存在文件内指针直接跳到文件开头
 with open('a.txt',mode='r',encoding='utf-8') as f:
     res=f.read() # 会将文件的内容由硬盘全部读入内存，赋值给res

# 小练习：实现用户认证功能
 inp_name=input('请输入你的名字: ').strip()
 inp_pwd=input('请输入你的密码: ').strip()
 with open(r'db.txt',mode='r',encoding='utf-8') as f:
     for line in f:
         # 把用户输入的名字与密码与读出内容做比对(解压赋值)
         u,p=line.strip('\n').split(':')
         if inp_name == u and inp_pwd == p:
             print('登录成功')
             break
     else:
         print('账号名或者密码错误')
```

<h3 id="JPRUl"><font style="color:rgb(18, 18, 18);">3.1.2 案例二：w 模式的使用</font></h3>
```python
# 2、w：只写模式，当文件不存在时，会创建空文件。当文件存在时候，w就会清空文件，指针位于开始位置
with open('d.txt', mode='wt', encoding='utf-8') as f:
   f.read()  # 只写模式下，报错不可读
   f.write('我擦泪\n')  # 先清空再覆盖,加上\n,按住方向右键可以跑到下一行，相当于加了一个换行符。

# 强调1
# 在以w模式打开文件，没有关闭的情况下，连续写入，新写的内容总是跟在旧内容之后。
with open('d.txt', mode='wt', encoding='utf-8') as f:
    f.write('我擦泪1\n')
    f.write('我擦泪2\n')
    f.write('我擦泪3\n')

# 强调2
#如果重新以w模式打开文件，则会清空文件内容
with open('d.txt', mode='wt', encoding='utf-8') as f:
    f.write('我擦泪1\n')
with open('d.txt', mode='wt', encoding='utf-8') as f:
    f.write('我擦泪2\n')
    with open('d.txt', mode='wt', encoding='utf-8') as f:
    f.write('我擦泪3\n')

# 案例：w模式用来创建全新的文件
# 文本文件的copy工具

src_file=input('源文件路径>>>: ').strip()
dst_file=input('目标文件路径>>>: ').strip()
with open(r'{}'.format(src_file), mode='rt',encoding='utf-8') as f1,\
     open('{}'.format(dst_file), mode='wt', encoding='utf-8') as f2:
     res=f1.read()
     f2.write(res)

src_file=input('源文件路径>>>: ').strip()
dst_file=input('目标文件路径>>>: ').strip()
with open(r'%s' %(src_file,), mode='rt',encoding='utf-8') as f1,\
     open(r'%s' %(dst_file,), mode='wt', encoding='utf-8') as f2:
     res=f1.read()
     f2.write(res)

src_file=input('源文件路径>>>: ').strip()
dst_file=input('目标文件路径>>>: ').strip()
with open(r'%s' %src_file, mode='rt',encoding='utf-8') as f1,\
     open(r'%s' %dst_file, mode='wt', encoding='utf-8') as f2:
     res=f1.read()
     f2.write(res)
```

<h3 id="gc4Lf"><font style="color:rgb(18, 18, 18);">3.1.3 案例三：a 模式的使用</font></h3>
```python
# a只追加写模式: 在文件不存在时会创建空文档,文件存在会将文件指针直接移动到文件末尾
 with open('c.txt',mode='a',encoding='utf-8') as f:
     # f.read()  # 报错， 不能读
     f.write('44444\n')
     f.write('55555\n')
     
# 强调 w 模式与 a 模式的异同：
# 1 相同点：在打开的文件不关闭的情况下，连续的写入，新写的内容总会跟在前写的内容之后
# 2 不同点：以 a 模式重新打开文件，不会清空原文件内容，会将文件指针直接移动到文件末尾，新写的内容永远写在最后

# 小练习：实现注册功能:
 name=input('username>>>: ').strip()
 pwd=input('password>>>: ').strip()
 with open('db1.txt',mode='a',encoding='utf-8') as f:
     info='%s:%s\n' %(name,pwd)
     f.write(info)

# 注册功能（a模式案例）===a模式在原来有的文件内存的基础上写入新的内容，比如记录日志，注册功能
name=input('your name>>>: ')
passwd=input('your passwd>>>: ')
with open('db.txt', mode='at', encoding='utf-8') as f:
    f.write('{}:{}\n'.format(name,passwd))
```

<h3 id="c8Djc"><font style="color:rgb(18, 18, 18);">3.1.4 案例四：+ 、x模式的使用(了解)</font></h3>
```python
# 1、+模式
r+ w+ a+ :可读可写
在平时工作中，我们只单纯使用r/w/a，要么只读，要么只写，一般不用可读可写的模式



# 2、x模式  了解即可
# 只写模式（文件存在报错，文件不存在则会新建文件）
with open('g.txt', mode='xt', encoding='utf-8') as f:
     pass

with open('g.txt', mode='xt', encoding='utf-8') as f:
    f.read()  # 不可读

with open('h.txt', mode='xt', encoding='utf-8') as f:
    f.write('哈哈哈哈\n')

#windows平台上的换行符是\r\n
#linux、mac上换行符是\n
# bytes类型转换
# print('你'.encode('gbk'))  # b'\xc4\xe3'
```

<h2 id="yB6C0"><font style="color:rgb(18, 18, 18);">3.2 控制文件读写内容的模式</font></h2>
```python
# 大前提: tb模式均不能单独使用,必须与r/w/a之一结合使用
# t（默认的）：文本模式
    1. 读写文件都是以字符串为单位的
    2. 只能针对文本文件
    3. 必须指定encoding参数
# b：二进制模式:
   1.读写文件都是以bytes/二进制为单位的
   2. 可以针对所有文件
   3. 一定不能指定encoding参数
```

<h3 id="YmztP"><font style="color:rgb(18, 18, 18);">3.2.1 案例一：t 模式的使用</font></h3>
```python
# t 模式：如果我们指定的文件打开模式为r/w/a，其实默认就是rt/wt/at
 with open('a.txt',mode='rt',encoding='utf-8') as f:
     res=f.read() 
     print(type(res)) # 输出结果为：<class 'str'>

 with open('a.txt',mode='wt',encoding='utf-8') as f:
     s='abc'
     f.write(s) # 写入的也必须是字符串类型

 #强调：t 模式只能用于操作文本文件,无论读写，都应该以字符串为单位，而存取硬盘本质都是二进制的形式，
# 当指定 t 模式时，内部帮我们做了编码与解码
```

<h3 id="MMfkB"><font style="color:rgb(18, 18, 18);">3.2.2 案例二： b 模式的使用</font></h3>
```python
# b: 读写都是以二进制位单位
 with open('1.mp4',mode='rb') as f:
     data=f.read()
     print(type(data)) # 输出结果为：<class 'bytes'>

 with open('a.txt',mode='wb') as f:
     msg="你好"
     res=msg.encode('utf-8') # res为bytes类型
     f.write(res) # 在b模式下写入文件的只能是bytes类型


# 错误演示： t模式只能读文本文件
with open(r'test.jpg',mode='rt') as f:
    f.read()  # 硬盘的二进制读入内存===》t模式会将读入内存的内容进行decode解码操作

# b模式

with open(r'test.jpg',mode='rb') as f:
    res=f.read()  # 硬盘的二进制读入内存---》b模式下，不做任何转换，直接读入内存。
    print(res, type(res))  # bytes类型==》当成二进制看

with open(r'd.txt',mode='rb') as f:
    res=f.read()  # utf-8的二进制
    print(res,type(res))
    print(res.decode('utf-8'))  # 解码操作

with open(r'd.txt',mode='rt',encoding='utf-8') as f:
    res=f.read()  # utf-8的二进制
    print(res)

with open(r'e.txt', mode='wb') as f:
    # f.write('哈哈哈hello')  # TypeError: a bytes-like object is required, not 'str'
    f.write('哈哈哈hello'.encode('utf-8'))  # 需要吧字符串转为bytes类型，这样才能吧哈哈哈hello写入到文件中

# 优化版====支持任何格式的copy工具
src_file=input('源文件路径>>>: ').strip()
dst_file=input('目标文件路径>>>: ').strip()
with open(r'{}'.format(src_file), mode='rb') as f1,\
     open(r'{}'.format(dst_file), mode='wb') as f2:
     # res=f1.read()  # 内存占用过大
     # f2.write(res)
     for line in f1:
         f2.write(line


     
#强调：b模式对比t模式
1、在操作纯文本文件方面t模式帮我们省去了编码与解码的环节，b模式则需要手动编码与解码，所以此时t模式更为方便
2、针对非文本文件（如图片、视频、音频等）只能使用b模式

# 小练习： 编写拷贝工具
src_file=input('源文件路径: ').strip()
dst_file=input('目标文件路径: ').strip()
with open(r'%s' %src_file,mode='rb') as read_f,open(r'%s' %dst_file,mode='wb') as write_f:
    for line in read_f:
        # print(line)
        write_f.write(line)


# 优化版====支持任何格式的copy工具
src_file=input('源文件路径>>>: ').strip()
dst_file=input('目标文件路径>>>: ').strip()
with open(r'{}'.format(src_file), mode='rb') as f1,\
     open(r'{}'.format(dst_file), mode='wb') as f2:
     # res=f1.read()  # 内存占用过大
     # f2.write(res)
     for line in f1:
         f2.write(line)
```

<h2 id="fKEQC"><font style="color:rgb(18, 18, 18);">四 操作文件的方法</font></h2>
<h2 id="f5Ita"><font style="color:rgb(18, 18, 18);">4.1 重点</font></h2>
```python
# 一、读相关操作
# 1、readline:一次读一行
with open(r'g.txt', mode='rt', encoding='utf-8') as f:
    res1=f.readline()
    res2=f.readline()
    # print(res2)
    res3=f.readlines()
    print(res3)
   # 一次取一行
     while True:
         line=f.readline()
         if len(line) == 0:
             break
         print(line)

# 2、readlines：读取每一行内容,存放于列表中
with open(r'g.txt',mode='rt',encoding='utf-8') as f:
    res=f.readlines()
    print(res)  # ['111\n', '222\n', '333\n', '444\n', '555']

# 读操作
# f.read()  # 读取所有内容,执行完该操作后，文件指针会移动到文件末尾
# f.readline()  # 读取一行内容,光标移动到第二行首部
# f.readlines()  # 读取每一行内容,存放于列表中

# 强调：
# f.read()与f.readlines()都是将内容一次性读入内存，如果内容过大会导致内存溢出，若还想将内容全读入内存，则必须分多次读入，有两种实现方式：

# 二、写相关操作
# f.writelines() : 相当于一个for循环,吧for循环的列表内容写到文件里面去了
with open(r'h.txt',mode='wt', encoding='utf-8') as f:
    # f.write('111\n222\n333\n')
    # 把列表的内容取出来，写到文件里面去。
    l = ['1111\n','2222','3333']
    # for line in l:
    #     f.write(line)
    f.writelines(l)


# b模式
with open(r'h.txt', mode='wb') as f:
    l = [
        '1111\n'.encode('utf-8'),
        '2222'.encode('utf-8'),
        '3333'.encode('utf-8')
    ]

    # 补充1：如果是纯英文字符，可以直接加b前缀，得到bytes类型
    l = [
        '1111aaa\n'.encode('utf-8'),
        '2222bbbb'.encode('utf-8'),
        '33eeee33'.encode('utf-8')
    ]

    # 补充2：'上'.encode('utf-8') 等同于bytes('上',encoding='utf-8')
    l = [
       bytes('上啊', encoding='utf-8'),
       bytes('冲啊', encoding='utf-8'),
       bytes('小辣鸡们', encoding='utf-8'),
    ]

    f.writelines(l)  # 上啊冲啊小辣鸡们

# 3、flush：
with open(r'h.txt',mode='wt',encoding='utf-8') as f:
    f.write('哈哈哈')
    f.flush()  # 一般不会使用，只有在测试环境有可能会用。

# 4、了解知识
f.readable()  # 文件是否可读
f.writable()  # 文件是否可读
f.closed  # 文件是否关闭
f.encoding  # 如果文件打开模式为b,则没有该属性
f.flush()  # 立刻将文件内容从内存刷到硬盘
f.name  # 打印文件的名字
```

<h2 id="Kwc0h"><font style="color:rgb(18, 18, 18);">五 主动控制文件内指针移动</font></h2>
```python
#大前提:文件内指针的移动都是Bytes为单位的,唯一例外的是t模式下的read(n),n以字符为单位


# 指针移动的单位都是以bytes/字节为单位
#   大前提:文件内指针的移动都是Bytes为单位的,
#       唯一例外的是t模式下的read(n),n以字符为单位

with open(r'aaa.txt',mode='rt',encoding='utf-8') as f:
    print(f.read(4))  # abc你  注意只有这个特殊情况，显示的是字符。

# f.seek(n, 模式)：n指的是移动的字节个数
# 模式
# 0：参照物是文件开头位置
f.seek(9,0)
f.seek(3,0)  # 3

# # 1: 参照物是当前指针所在位置
f.seek(9,1)
f.seek(3,1)  # 12

# # 2: 参照物是文件末尾位置，应该倒着移动。
f.seek(-9,2)  # 3
f.seek(-3,2)  # 9

# 强调： 只有0模式可以在t下使用，1、2必须在b模式下用
# f.tell()  # 获取文件当前指针的位置

# 0 模式详解
with open(r'aaa.txt', mode='rb') as f:
    f.seek(9,0)  # 参照文件开头移动了9个字节
    f.seek(3,0)  # 参照文件开头移动了3个字节
    print(f.tell())  # 查看当前文件指针距离文件开头的位置，输出结果为3
    res=f.read()
    print(res.decode('utf-8'))  # 从第3个字节的位置读到文件末尾，输出结果为：你好啊
 # 注意：由于在t模式下，会将读取的内容自动解码，所以必须保证读取的内容是一个完整中文数据，否则解码失败

# 1 模式详解
    f.seek(9, 1)  # 从当前位置往后移动9个字节，而此时的当前位置就是文件开头
    f.seek(3, 1)  # 从当前位置往后移动3个字节，而此时的当前位置就是9
    print(f.tell())  # 输出结果为：12
    res=f.read()
    print(res.decode('utf-8')) # 输出结果为：abc你好

# 2 模式详解
    f.seek(0,2)     # 参照文件末尾移动0个字节， 即直接跳到文件末尾
    f.seek(-9, 2)  # 正3  参照文件末尾往前移动了9个字节
    f.seek(-3, 2)  # 正9   参照文件末尾往前移动了3个字节
    print(f.tell())  # 输出结果：9
    print(f.read().decode('utf-8'))  # 啊


# bytes ==》二进制
    得到bytes类型的三种方法：
    # 1、字符串编码之后的结果
    '上'.encode('utf-8') 等同于bytes('上',encoding='utf-8')
    # 2、b'必须是纯英文字符'
    # 3、b模式下打开文件，f.read()读出的内容


# 案例  tail -f检测功能,实战f.seek的应用，小练习：实现动态查看最新一条日志的效果
import time
with open('access.log',mode='rb') as f:
    f.seek(0,2)
    while True:
        line=f.readline()
        if len(line) == 0:
            time.sleep(0.3)
        else:
            print(line.decode('utf-8'), end='')

#追加内容的py脚本
with open('access.log', mode='at', encoding='utf-8') as f:
    f.write('202203111111 yyy转账600w\n')

# access.log内容
202203111111 yyy转账200w
202203111111 yyy转账100w
202203111111 yyy转账100w
202203111111 yyy转账500w
202203111111 yyy转账500w
202203111111 yyy转账500w
202203111111 yyy转账600w
202203111111 yyy转账600w

#pycharm的控制台输出：
D:\python36\python.exe "D:/py1/python/day11/08 文件的高级操作：控制文件指针移动.py"
202203111111 yyy转账500w

202203111111 yyy转账500w

202203111111 yyy转账600w

202203111111 yyy转账600w

# 之前文件内指针的移动都是由读/写操作而被动触发的，若想读取文件某一特定位置的数据，则则需要用f.seek方法主动控制文件内指针的移动，详细用法如下：
# f.seek(指针移动的字节数,模式控制): 
# 模式控制:
# 0: 默认的模式,该模式代表指针移动的字节数是以文件开头为参照的
# 1: 该模式代表指针移动的字节数是以当前所在的位置为参照的
# 2: 该模式代表指针移动的字节数是以文件末尾的位置为参照的
# 强调:其中0模式可以在t或者b模式使用,而1跟2模式只能在b模式下用
```

<h2 id="uVIjC">![](https://cdn.nlark.com/yuque/0/2023/webp/25700096/1679301073914-1b837287-b373-4dae-b575-6f57733c3228.webp)</h2>
<h2 id="iZdoK"><font style="color:rgb(18, 18, 18);">六 文件的修改</font></h2>
```python
# 文件a.txt内容如下
张一蛋     山东    179    49    12344234523
李二蛋     河北    163    57    13913453521
王全蛋     山西    153    62    18651433422

# 执行操作
with open('a.txt',mode='r+t',encoding='utf-8') as f:
    f.seek(9)
    f.write('<妇女主任>')

# 文件修改后的内容如下
张一蛋<妇女主任> 179    49    12344234523
李二蛋     河北    163    57    13913453521
王全蛋     山西    153    62    18651433422

# 强调：
# 1、硬盘空间是无法修改的,硬盘中数据的更新都是用新内容覆盖旧内容
# 2、内存中的数据是可以修改的
```

![](https://cdn.nlark.com/yuque/0/2023/webp/25700096/1679300996506-742127ee-fc43-4889-a0f9-e70925bc399e.webp)

<font style="color:rgb(18, 18, 18);">文件对应的是硬盘空间,硬盘不能修改对应着文件本质也不能修改, 那我们看到文件的内容可以修改,是如何实现的呢? 大致的思路是将硬盘中文件内容读入内存,然后在内存中修改完毕后再覆盖回硬盘 具体的实现方式分为两种:</font>

<font style="color:rgb(18, 18, 18);"></font>

<h2 id="I4fNn"><font style="color:rgb(18, 18, 18);">6.1 文件修改方式一</font></h2>
```python
# 方式一: 文本编辑器采用的就是这种方式
# 实现思路：将文件内容发一次性全部读入内存,然后在内存中修改完毕后再覆盖写回原文件
# 优点: 在文件修改过程中同一份数据只有一份
# 缺点: 会过多地占用内存

with open(r'k.txt',mode='rt',encoding='utf-8') as f:
    res=f.read()
    data=res.replace('alex', 'egon')
    print(data)

with open(r'k.txt',mode='wt', encoding='utf-8') as f2:
    f2.write(data)


```

<h2 id="bsrln">6.2 <font style="color:rgb(18, 18, 18);">文件修改方式二</font></h2>
```python
# 方式二:
# 实现思路：以读的方式打开原文件,以写的方式打开一个临时文件,一行行读取原文件内容,修改完后写入临时文件...,删掉原文件,将临时文件重命名原文件名
# 优点: 不会占用过多的内存
# 缺点: 在文件修改过程中同一份数据存了两份
import os
with open(r'k.txt', mode='rt', encoding='utf-8') as f,\
    open(r'.k.txt.swap', mode='wt', encoding='utf-8') as f2:
    for line in f:
      f2.write(line.replace('alex', 'jason'))

os.remove('k.txt')
os.rename('.k.txt.swap', 'k.txt')
```

