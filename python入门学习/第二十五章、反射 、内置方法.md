<img width="500" height="375" alt="image" src="https://github.com/user-attachments/assets/71c68cc6-d71c-4954-9f72-5edf767fa641" />


<h2 id="So6WY"><font style="color:rgb(18, 18, 18);">一 反射</font></h2>
![](https://cdn.nlark.com/yuque/0/2023/webp/25700096/1701843963218-fcdb9ad1-c92f-420b-8fa8-2ef01c49d9af.webp)

<font style="color:rgb(18, 18, 18);">  
</font>

<font style="color:rgb(18, 18, 18);">python是动态语言，而反射(reflection)机制被视为动态语言的关键。</font>

<font style="color:rgb(18, 18, 18);">反射机制指的是在程序的运行状态中</font>

<font style="color:rgb(18, 18, 18);">对于任意一个类，都可以知道这个类的所有属性和方法；</font>

<font style="color:rgb(18, 18, 18);">对于任意一个对象，都能够调用他的任意方法和属性。</font>

<font style="color:rgb(18, 18, 18);">这种动态获取程序信息以及动态调用对象的功能称为反射机制</font>

<font style="color:rgb(18, 18, 18);"></font>

<font style="color:rgb(18, 18, 18);">在python中实现反射非常简单，在程序运行过程中，如果我们获取一个不知道存有何种属性的对象，若想操作其内部属性，可以先通过内置函数dir来获取任意一个类或者对象的属性列表，列表中全为字符串格式</font>

```python

>>> class People:
...     def __init__(self,name,age,gender):
...         self.name=name
...         self.age=age
...         self.gender=gender
... 
>>> obj=People('egon',18,'male')
>>> dir(obj) # 列表中查看到的属性全为字符串
[......,'age', 'gender', 'name']

```

<font style="color:rgb(18, 18, 18);"></font>

<font style="color:rgb(18, 18, 18);">接下来就是想办法通过字符串来操作对象的属性了，这就涉及到内置函数hasattr、getattr、setattr、delattr的使用了（Python中一切皆对象，类和对象都可以被这四个函数操作，用法一样）</font>

```python

class People:
    def __init__(self,name,age,gender):
        self.name=name
        self.age=age
        self.gender=gender


obj=People('egon',18,'male')
print(obj.__dict__)  # {'name': 'egon', 'age': 18, 'gender': 'male'}

print(dir(obj))  # 列表中查看到的属性全为字符串
# ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'age', 'gender', 'name']

print(dir(obj)[-2])  # gender

res=hasattr(obj, 'name')  # 按字符串'name'判断有无属性obj.name
print(res)  # True

getattr(obj, 'sex', None)  # 等同于obj.sex,不存在该属性则返回默认值None
print(getattr(obj, 'sex', None))  # None 

print(getattr(obj, 'age'))  # 18

setattr(obj, 'age', 20)  # 等同于obj.age=18

print(delattr(obj, 'age'))  # # 等同于del obj.age
# print(getattr(obj, 'age'))

```

<font style="color:rgb(18, 18, 18);"></font>

```bash

# 判断一把
# obj=10
# if hasattr(obj, 'x'):
#     setattr(obj, 'x', 11111)
# else:
#     pass

```

<font style="color:rgb(18, 18, 18);">基于反射可以十分灵活地操作对象的属性，比如将用户交互的结果反射到具体的功能执行</font>

```python

# 案例
class Ftp:
    def put(self):
        print('正在执行上传功能')
    
    def get(self):
        print('正在执行下载功能')

    # 与用户交互的一个功能
    def interactive(self):
        method=input('>>>: ').strip()  # mothod='put'  因为输入的是字符串，相当于把put赋值给method，但是不能self.method,因为self一般是.属性的，
        if hasattr(self, method):
            getattr(self, method)()
        else:
            print('输入的指令不存在')

obj=Ftp()
obj.interactive()


# 输出结果：
jiangyuanhao@SHMHQMCB23005 day28 % python -u "/Users/jiangyuanhao/Desktop/project-demo/python-demo/day28/08 反射.py"
>>>: put
正在执行上传功能
jiangyuanhao@SHMHQMCB23005 day28 % python -u "/Users/jiangyuanhao/Desktop/project-demo/python-demo/day28/08 反射.py"
>>>: get
正在执行下载功能
jiangyuanhao@SHMHQMCB23005 day28 % python -u "/Users/jiangyuanhao/Desktop/project-demo/python-demo/day28/08 反射.py"
>>>: sss
输入的指令不存在

```

<h2 id="o1gt9"><font style="color:rgb(18, 18, 18);">二 内置方法</font></h2>
<font style="color:rgb(18, 18, 18);">Python的Class机制内置了很多特殊的方法来帮助使用者高度定制自己的类，这些内置方法都是以双下划线开头和结尾的，会在满足某种条件时自动触发，我们以常用的__str__和__del__为例来简单介绍它们的使用。</font>

<font style="color:rgb(18, 18, 18);"></font>

<font style="color:#DF2A3F;">__str__方法</font><font style="color:rgb(18, 18, 18);">会在对象被打印时自动触发，print功能打印的就是它的返回值，我们通常基于方法来定制对象的打印信息，该方法必须返回字符串类型</font>

```python

# 1. 什么是内置方法？
# 定义在类内部，以__开头并以__结尾的方法
# 特点； 会在某种情况下自动出发

# 2. 为何要用内置方法？
# 为了定制化我们的类或者对象

# 3. 如何使用内置方法




#__str__的小案例

class People:
    def __init__(self,name,age):
        self.name=name
        self.age=age

    def say(self):
        print('%s:%s' %(self.name,self.age))

obj=People('辣白菜同学', 18)
print(obj)  # <__main__.People object at 0x100b5afd0>


这就是__str__ 的特性: 在打印对象时会自动触发，并将返回值（必须是字符串类型）当作本次打印的结果输出
class People:
    def __init__(self,name,age):
        self.name=name
        self.age=age

    def __str__(self):
        # print('运行了。。。。')
        # return 'hahhahhhaha a'
        return '%s:%s' %(self.name,self.age)

obj=People('辣白菜同学', 18)
# print(obj.__str__())  # 辣白菜同学:18
print(obj)  # 辣白菜同学:18

```

<font style="color:rgb(18, 18, 18);">__del__会在对象被删除时自动触发。由于Python自带的垃圾回收机制会自动清理Python程序的资源，所以当一个对象只占用应用程序级资源时，完全没必要为对象定制__del__方法，但在产生一个对象的同时涉及到申请系统资源（比如系统打开的文件、网络连接等）的情况下，关于系统资源的回收，Python的垃圾回收机制便派不上用场了，需要我们为对象定制该方法，用来在对象被删除时自动触发回收系统资源的操作</font>

```python

# __del__ ： 在清理对象时触发，会先执行该方法

class People:
    def __init__(self,name,age):
        self.name=name
        self.age=age

    def __del__(self):
        print('运行了。。。')
obj=People('辣白菜同学', 18)
print('==========>')

# 输出：
# ==========>
# 运行了。。。



class People:
    def __init__(self,name,age):
        self.name=name
        self.age=age
        # self.x=open('a.txt',mode='w')
        # self.x = 占据的是操作系统的资源

    def __del__(self):
        print('运行了。。。')
        # 发起系统调用，告诉操作系统回收相关的资源
        # self.x.close()
obj=People('辣白菜同学', 18)

del obj
print('=================>')

# 输出：
# 运行了。。。
# =================>



# 小案例
class People:
    def __init__(self,name,age):
        self.name=name
        self.age=age
        # self.x=open('a.txt',mode='w')
        # self.x = 占据的是操作系统的资源

    def __del__(self):
        print('运行了。。。')
        # 发起系统调用，告诉操作系统回收相关的资源
        # self.x.close()
obj=People('辣白菜同学', 18)

del obj
print('=================>')

```

