![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1679560757096-cbcad3ac-f5ac-4f1b-9b2c-f66360cc522c.png)



<h2 id="vvcqB"><font style="color:rgb(18, 18, 18);">一 名称空间</font></h2>
存放名字的地方，是对栈区的划分

有了名称空间，就可以在栈区中存放相同的名字，



![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1679472289880-24aa1c5b-e590-4933-acee-61daa4cb8dcf.png)



<h2 id="JKaNp">1.1 内置名称空间(1个)</h2>

```python
# 存放的名字： 存放的python解释器内置的名字
# 存活周期：python解释器启动则产生，python解释器关闭则销毁

'''
>>> input
<built-in function input>
>>> print
<built-in function print>  #built-in内建
>>>
'''

'''
# python程序运行的三步骤：
# 1、python解释器启动
# 2、把python文件加载到内存
# 3、运行python代码
'''


```





<h2 id="NJfCx"><font style="color:rgb(18, 18, 18);">1.2 </font>1.2 全局名称空间(1个)</h2>


```python

# 存放的名字：只要不是函数内定义、也不是内置的，剩下的都是全局名称空间。
# 存活周期：python文件执行则产生，python文件运行完毕后销毁。
x=10
if 13 >3:
    y=20
    if 3 ==3:
        z=30

# func=函数的内存地址
def func():
    a=111
    b=222

class Foo:
    pass

```



<h2 id="JWCh0">1.3 局部名称空间（多个）</h2>

```python

# 存放的名字：在调用函数时，运行函数体代码的过程中产生的函数内的名字。
# 存活周期：在调用函数时存活，函数调用完毕后则销毁。
# 局部名称空间有多个，调一次产生一次名称空间，哪怕是同一个函数。

```



<h2 id="tYSJS">1.4 名称空间的加载顺序</h2>

```python

# 内置名称空间>全局名称空间>局部名称空间
# 局部名称空间可能没有，但是其余两个是一定有的。

```



<h2 id="AgsSx">1.5 名称空间的销毁顺序</h2>

```python

# 局部名称空间>全局名称空间>内置名称空间

```

<h2 id="eWs3b">1.6 名字查找优先级： 当前所在的位置向上一层一层查找</h2>

```python

# 如果当前在局部名称空间
# 局部名称空间-->全局名称空间-->内置名称空间



# 示例1
input=333
def func():
    input=444
    print(input)

func()  # 输出结果： 444

#示例2
input=333
def func():
    #input=444
    print(input)



func()  # 输出结果： 333



# 示例3
#input=333
def func():
    #input=444
    print(input)

func()  # 输出结果：<built-in function input>

# 示例4
input=333
def func():
    input=444


func()  
print(input)  # 输出结果：333


#示例5
# input=333
def func():
    input=444

func()  
print(input)  # 输出结果：<built-in function input>

```



如果当前在全局名称空间

全局名称空间-->内置名称空间

```python

# 示例1
def func():
    print(x)

x=111
func()  # 输出结果： 111

# 示例
x=111
def func():
    print(x)


func()  # 输出结果： 111

# 示范2：名称空间的“嵌套”关系是以函数定义阶段为准的，与调用位置无关。
x=1
def func():
    print(x)

def foo():
    x=222
    func()

foo()  # 输出结果： 1


# 示例3: 函数嵌套定义
input=111
def f1():
    input=222
    def f2():
        input=333
        print(input)
    f2()

f1()  # 输出结果： 333


input=111
def f1():
    input=222
    def f2():
        #input=333
        print(input)
    f2()

f1()  # 输出结果： 222


input=111
def f1():
    #input=222
    def f2():
        #input=333
        print(input)
    f2()

f1()  # 输出结果： 111


# input=111
def f1():
    #input=222
    def f2():
        #input=333
        print(input)
    f2()

f1()  # 输出结果： <built-in function input>


input=111
def f1():
    def f2():
        #input=333
        print(input)
    input=222
    f2()

f1()  # 输出结果： 222


# 示例
input=333
def func():
    # input=444
    print(input)

input=555

func()  # 输出结果： 555

```

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1679639012802-c0408498-c41e-4f91-bb97-d79028d9f87c.png)

辅助理解图：

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1679475027643-41ceea74-9d3e-4f82-8686-8452cbe8f353.png)



从你当前所在的层为起始，没有去外面一层函数找，

先去函数外面一层找----再去函数外面一层找---如果没有就去全局名称空间找----如果没有再去内置名称空间找

```python

# 示范4
x=111
def func():
    print(x)
    x=222

func()  # 报错：UnboundLocalError: local variable 'x' referenced before assignment

```

<h1 id="dwCDM">二、作用域==>作用范围</h1>
<h2 id="jKVwg"><font style="color:rgb(18, 18, 18);">2.1 全局作用域与局部作用域</font></h2>
<font style="color:#DF2A3F;background-color:#8CCF17;">全局作用域</font><font style="color:#DF2A3F;">：内置名称空间，全局名称空间</font>

<font style="color:#DF2A3F;">1、全局存活</font>

<font style="color:#DF2A3F;">2、全局有效: 被所有函数共享</font>

```python

x=111

def foo():
    print(x, id(x))

def bar():
    print(x,id(x))

foo()
bar()
print(x,id(x))

# 输出结果：
111 1373057904
111 1373057904
111 1373057904

```

<font style="color:#DF2A3F;background-color:#8CCF17;">局部作用域</font><font style="color:#DF2A3F;">： 局部名称空间的名字</font>

<font style="color:#DF2A3F;">1、临时存活</font>

<font style="color:#DF2A3F;">2、局部有效: 函数内有效</font>

```python

def foo(x):
    def f1():
        def f2():
            print(x)

#LEGB的由来
builtin
global
def f1():
    # enclosing
    def f2():
        # enclosing
        def f3():
            # local
            pass
```

<h2 id="PYzoh">2.2 global与nonlocal的用法</h2>
<h3 id="uIOEE">2.2.1 global</h3>

```python

# 示范1
x=111
def func():
    x=222  # 此处x与外面的x没有任何关系，这里只是吧222的内存地址赋值到x上了。

func()
print(x)  # 输出结果： 111


# 针对不可变类型的修改
# 示范2： 如果在局部想要修改全局的名字对应的值（不可变类型），需要用global字眼。
x=111
def func():
    global x  # 声明x这个名字是全局的名字，不要再造新的名字。
    x=222

func()
print(x)  # 输出结果： 222


# 示例3
l=[111,222]
def func():
    l.append(333)
func()
print(l)  # 输出结果：[111, 222, 333]



```

<h3 id="LKJD9">2.2.2 nonlocal用法</h3>

```python

# nonlocal（了解）：修改函数外层函数包含的名字对应的值（不可变类型）
# 示例1
x=0
def f1():
    x=11
    def f2():
        global x
        x=222
    f2()
    print('f1内的x：', x)  # 输出结果：f1内的x： 11

f1()
print(x)  # 输出结果：222



# 示例2
x=0
def f1():
    x=11
    def f2():
        nonlocal x
        x=222
    f2()
    print('f1内的x：', x)  # 输出结果：f1内的x： 222

f1()
print(x)  # 输出结果：0


# 示例3：针对可变类型
def f1():
    x=[]
    def f2():
        x.append(11111)
    f2()
    print('f1内的x：',x)  # 输出结果：f1内的x： [11111]

f1()






对于嵌套多层的函数，使用nonlocal关键字可以将名字声明为来自外部嵌套函数定义的作用域（非全局）
def  f1():
    x=2
    def f2():
        nonlocal x
        x=3
    f2() #调用f2(),修改f1作用域中名字x的值
    print(x) #在f1作用域查看x

f1()

#结果
3

nonlocal x会从当前函数的外层函数开始一层层去查找名字x，若是一直到最外层函数都找不到，则会抛出异常。

```



<font style="color:#E746A4;">重点1：</font>

<font style="color:#E746A4;">名字查找： 当前所在的位置向外查找</font>

<font style="color:#E746A4;">局部名称空间==》全局名称空间==》内置名称空间</font>

<font style="color:#E746A4;"></font>

<font style="color:#E746A4;">重点2:</font>

<font style="color:#E746A4;">名称空间只有优先级之分，本身并无嵌套关系，画图只是为了帮助理解</font>

<font style="color:#E746A4;"></font>

<font style="color:#E746A4;">重点3：</font>

<font style="color:#E746A4;">名称空间的嵌套关系决定了名字的查找关系</font>

<font style="color:#E746A4;">而名称空间的嵌套关系是以函数定义阶段为准的</font>

<font style="color:#E746A4;">即函数的嵌套关系与名字的查找顺序是在定义节点已经确定好的了。</font>

<font style="color:#E746A4;"></font>



<font style="color:#E746A4;"></font>

<font style="color:#E746A4;">参考链接：</font>[https://zhuanlan.zhihu.com/p/108924801](https://zhuanlan.zhihu.com/p/108924801)





<h1 id="TJ1eR">三、作业题</h1>

```python

# 示例1
input=333
def func():
    input=444
    print(input)  # 输出结果： 444   # 在函数局部找

func()
print(input)  # # 输出结果： 333  # 在全局找

```

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1679628089772-42d3b653-4dc9-4df4-92ec-5e832fc64691.png)

```python

# 示例2
def func():
    print(x)  # 输出结果： 111
x = 111

func()

```

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1679635504999-d7cb34db-92bc-4bfc-a3aa-059185e242ad.png)

```python

# 示例3
x=1
def func():
    print(x)

def foo():
    x=222
    func()

    
x=333



foo()
# 输出结果： 333

```

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1679636375100-feb78b01-fcbc-4f19-a8f9-7a634d8873d6.png)

```python

# 示例4：
input=111
def f1():
    def f2():
        # input=333
        print(input)
    input=222
    f2()

input=333

f1()

# 输出结果： 222

```

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1679637028076-6e826111-a461-45df-b2f1-5ae4114032a7.png)

