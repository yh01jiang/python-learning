

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1701843909894-981c2571-f990-411b-80b2-938e19a010d9.png)![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1701843880306-51add2e1-bfc3-4ebc-9601-4121af755941.png)

<h2 id="vGM3J"><font style="color:rgb(18, 18, 18);">多态与多态性</font></h2>
<font style="color:rgb(18, 18, 18);">多态指的是一类事物有多种形态，比如动物有多种形态：猫、狗、</font>

```python

# 1. 什么是多态？
    # 多态指的是一类事物有多种形态，比如动物有多种形态：猫、狗、猪
class Animal:
    def say(self):
        print('动物的发生频率。。。', end='')

class People(Animal):
    pass       

class Dog(Animal):
    pass

class Pig(Animal):
    pass



# 2. 为何要有多态========多态性
        # 多态性指得是不考虑对象类型的情况下，直接使用对象

class Animal:  # 统一所有子类的方法
    def say(self):
        print('动物的发生频率。。。', end='')

class People(Animal):
    def say(self):
        super().say()
        print('滋滋滋滋滋')        

class Dog(Animal):
    def say(self):
        super().say()
        print('汪汪汪') 

class Pig(Animal):
    def say(self):
        super().say()
        print('哼哼哼') 

obj1=People()
obj2=Dog()
obj3=Pig()


# 输出
# 动物的发生频率。。。滋滋滋滋滋
# 动物的发生频率。。。汪汪汪
# 动物的发生频率。。。哼哼哼

# 更进一步，定义统一的接口，接受传入的动物对象
def animal_say(animal):
    animal.say()


animal_say(obj1)  # 直接传入对象
animal_say(obj2)
animal_say(obj3)

# 输出：
# 动物的发生频率。。。滋滋滋滋滋
# 动物的发生频率。。。汪汪汪
# 动物的发生频率。。。哼哼哼


# 但是python不是推崇继承的方式，来实现多态



# python应该这样用

# python推崇的是鸭子类型

class Cpu:
    def read(self):
        print('cpu read')
    def write(self):
        print('cpu write')

class Mem:
    def read(self):
        print('mem read')
    def write(self):
        print('mem write')   

class Txt:
    def read(self):
        print('txt read')
    def write(self):
        print('txt write')


obj1=Cpu()
obj2=Mem()
obj3=Txt()


obj1.read()
obj1.write()

obj2.read()
obj2.write()


obj3.read()
obj3.write()

# 输出
# cpu read
# cpu write
# mem read
# mem write
# txt read
# txt write

```



<h1 id="HVcxo"><font style="color:rgb(18, 18, 18);">绑定方法与非绑定方法</font></h1>

```python

# 一 绑定方法： 特殊之处在于将调用者本身当作第一个参数自动传入
    # 1. 绑定给对象的方法： 调用者是对象，自动传入的是对象
    # 2. 绑定给类的方法：   调用者是类，自动传入的是类

import settings

class Mysql: # （比如以后是mariadb）
    def __init__(self,ip,port):
        self.ip=ip
        self.port=port

    def func(self):
        print('%s:%s' %(self.ip, self.port))

    @classmethod  # 将下面的函数装饰城绑定给类的方法
    def from_conf(cls):  # 是为了把类Mysql写活（比如以后是mariadb）,cls约定成俗.# 从配置文件中读取配置进行初始化
        return cls(settings.IP,settings.PORT)


obj1=Mysql('1.1.1.1', 3306)


# 把setting.py 用户配置的ip port 传入到Mysql类中




# obj2=Mysql(settings.IP,settings.PORT)

# 应用场景：比较窄
# 实现自动的从配置文件加载配置
obj2=Mysql.from_conf()
print(obj2.__dict__)

# 输出
# {'ip': '127.0.0.1', 'port': 3306}




# 二 非绑定方法===》静态方法（谁都可以来调用）
    # 没有绑定给任何人：调用者可以是类，可以是对象，没有自动传参的效果
	# 为类中某个函数加上装饰器@staticmethod后，该函数就变成了非绑定方法，也称为静态方法。
	# 该方法不与类或对象绑定，类与对象都可以来调用它，但它就是一个普通函数而已，
	# 因而没有自动传值那么一说


class Mysql:
    def __init__(self,ip,port):
        self.uuid= self.create_id  # 更进一步直接获取
        self.ip=ip
        self.port=port

    @staticmethod  # 将下述函数装饰成一个静态方法
    def create_id():
        import uuid
        return uuid.uuid4
    
    @classmethod
    def f1(self):
        pass

    def f2(self):
        pass
    
obj1=Mysql('127.0.0.1', 3306)

# print(Mysql.create_id)  # <function Mysql.create_id at 0x1005789d0>
# print(obj1.create_id)   # <function Mysql.create_id at 0x1005789d0>


# Mysql.create_id(1,2,3)  # 1 2 3
# obj1.create_id(4,5,6)   # 4 5 6





print(Mysql.create_id)  # <function Mysql.create_id at 0x104fa89d0>
print(Mysql.f1)         # <bound method Mysql.f1 of <class '__main__.Mysql'>>
print(obj1.f2)          # <bound method Mysql.f2 of <__main__.Mysql object at 0x102a16f10>>


# 类中的三种方法：
# 不加任何装饰的情况下：默认绑定给对象，会将对象自动传入
# 还有一种绑定给类的，调用者是类，将类传入自动传入
# 还有一种非绑定的，调用者可以是类，也可以是对象，调用的时候就是一个普通函数，该怎么传参就怎么传参

'''
细节：
如果类体代码不需要类，也不需要对象，还能运行，并且还需要将此防范在再类体代码中集成，那么就的使用静态非绑定方法

'''

```



配置文件settings.py的内容

```python

IP='127.0.0.1'
PORT=3306

```

![](https://cdn.nlark.com/yuque/0/2023/png/25700096/1701673361476-6e42e2f1-66f1-4b5a-b14e-2d8763a4cbe8.png)



<h4 id="Jhr57">总结：</h4>
<font style="color:#DF2A3F;">总结绑定方法与非绑定方法的使用：若类中需要一个功能，该功能的实现代码中需要引用对象则将其定义成对象方法、需要引用类则将其定义成类方法、无需引用类或对象则将其定义成静态方法。</font>

