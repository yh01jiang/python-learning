<img width="720" height="589" alt="image" src="https://github.com/user-attachments/assets/1f60dea4-33dd-46e2-a43b-bcafd9d970dd" />

<h1 id="Cl15P">一 迭代器介绍</h1>
<h2 id="bHj7Y">1、什么是迭代器</h2>
迭代器即用来迭代取值的工具，而迭代是一个重复的过程，

每次重复都是基于上一次的结果而继续的，单纯的重复并不是迭代。

```python

while True:
    msg = input('>>: ').strip()
    print(msg)

```

<font style="color:rgb(18, 18, 18);">下述while循环才是一个迭代过程，不仅满足重复，而且以每次重新赋值后的index值作为下一次循环中新的索引进行取值，反复迭代，最终可以取尽列表中的值</font>

```python

goods=['mac','lenovo','acer','dell','sony']

index=0
while index < len(goods):
    print(goods[index])
    index+=1

```

<h2 id="CdMbk">2、为何要有迭代器</h2>
迭代器是用来取值的公户，而涉及到吧多个值循环取出来的类型有（列表、字符串、元组、字典、集合、文件）

```python

i=0
    l=[11,22,33]
    while i<len(l):
        print(l[i])
        i+=1

    # 上述迭代取值的方式只适用于有索引的数据类型：列表、字符串、元组
    # 为了解决索引的迭代取值的局限性，python必须提供一种不依赖于索引的取值方式，这就是迭代器。

```

<h3 id="AE8us">2.1 可迭代的对象：但凡内置有__iter__方法的都称之为可迭代的对象</h3>

```python

s1=''
# s1.__iter__()

l=[]
# l.__iter__()

toupe=()
# toupe.__iter__()

dic={'a':1}
# dic.__iter__()

set={1,2,3}
# set.__iter__()

with open('a.txt',mode='w') as f:
    # f.__iter__()

```

<h3 id="cxE4w">2.2 调用可迭代对象下的__iter__方法会将其转换成迭代器对象</h3>

```python

dic={'a':1,'b':2,'c':3}
d_iterator=dic.__iter__()
# print(d_iterator)  # 输出结果：<dict_keyiterator object at 0x01CBF330>
print(d_iterator.__next__())
print(d_iterator.__next__())
print(d_iterator.__next__())
print(d_iterator.__next__())  # 抛出异常StopIteration






# 使用while循环
dic={'a':1,'b':2,'c':3}
d_iterator=dic.__iter__()
while True:
    try:
        print(d_iterator.__next__())
    except StopIteration:  # 捕捉异常
        break

print('======>>>')  # 对一个迭代器取值取干净的情况下，再对其取值取不到。
while True:
    try:
        print(d_iterator.__next__())
    except StopIteration:  # 捕捉异常
        break
# 输出结果：
a
b
c
======>>>


dic={'a':1,'b':2,'c':3}
d_iterator=dic.__iter__()
while True:
    try:
        print(d_iterator.__next__())
    except StopIteration:  # 捕捉异常
        break

print('======>>>')  # 对一个迭代器取值取干净的情况下，再对其取值取不到。
dic={'a':1,'b':2,'c':3}
d_iterator=dic.__iter__()
while True:
    try:
        print(d_iterator.__next__())
    except StopIteration:  # 捕捉异常
        break

# 输出结果：
a
b
c
======>>>
a
b
c

# 基于索引的类型，也可以使用迭代器。
l=[11,22,33,44,55]
l_iterator=l.__iter__()

while True:
    try:
        print(l_iterator.__next__())
    except StopIteration:
        break
# 输出结果
11
22
33
44
55

```

<h2 id="Oi8VS">3、可迭代对象与迭代器对象详解</h2>
<h3 id="UbsAT">3.1可迭代对象</h3>
<font style="color:#DF2A3F;">可迭代对象：（可以转换为迭代器的对象）：内置有__iter__方法对象</font>

<font style="color:#DF2A3F;">可迭代对象.__iter__(): 得到迭代器对象</font>

<h3 id="Vf0oI">3.2迭代器对象</h3>
<font style="color:#DF2A3F;">迭代器对象： 内置有__next__方法并且内置有__iter__方法的对象</font>

<font style="color:#DF2A3F;">迭代器对象.__next__(): 得到迭代器的下一个值</font>

<font style="color:#DF2A3F;">迭代器对象.__iter__(): 得到迭代器本身，说白了调了和没调一样。</font>

说明：

<font style="color:#8CCF17;">可迭代对象：列表、字符串、字典、元组、集合、文件对象</font>

<font style="color:#8CCF17;">迭代器对象：文件对象</font>



<h2 id="f0Iza">4、for循环的工作原理：for循环又称为迭代循环</h2>

```python

dic={'a':1,'b':2,'c':3}
d_iterator=dic.__iter__()
while True:
    try:
        print(d_iterator.__next__())
    except StopIteration:  # 捕捉异常
        break
        
# for循环原理
1、dic.__iter__()得到一个迭代器对象
2、迭代器对象.__next__()拿到一个返回值，然后将该返回值赋值给key
3、循环往复步骤2，直到抛出异常StopIterationfor循环会捕捉异常，然后结束。

for循环又称为迭代循环，in后可以跟任意可迭代对象，上述while循环可以简写为
for key in dic:vs
    print(key)

with open('a.txt',mode='rt',encoding='utf-8') as f:
    for line in f:
        print(line, end='')

list('hello')  # 原理同for循环

```

<h2 id="m3ktK">5、迭代器的优缺点总结</h2>

```python

# 5.1 优点：
1、为序列和非序列类型提供了一种统一的迭代取值方式。
2、惰性计算：迭代器对象表示的是一个数据流，可以只在需要时才去调用next来计算出一个值，就迭代器本身来说，同一时刻在内存中只有一个值，因而可以存放无限大的数据流，
而对于其他容器类型，如列表，需要把所有的元素都存放于内存中，受内存大小的限制，可以存放的值的个数是有限的。

# 5.2 缺点：
1、除非取尽，否则无法获取迭代器的长度

2、只能取下一个值，不能回到开始，更像是‘一次性的’，迭代器产生后的唯一目标就是重复执行next方法直到值取尽，否则就会停留在某个位置，等待下一次调用next；
若是要再次迭代同个对象，你只能重新调用iter方法去创建一个新的迭代器对象，如果有两个或者多个循环使用同一个迭代器，必然只会有一个循环能取到值。


```

参考链接：[https://zhuanlan.zhihu.com/p/109083551](https://zhuanlan.zhihu.com/p/109083551)

[迭代器 - Python教程 - 廖雪峰的官方网站 (liaoxuefeng.com)](https://liaoxuefeng.com/books/python/advanced/iterator/index.html)

